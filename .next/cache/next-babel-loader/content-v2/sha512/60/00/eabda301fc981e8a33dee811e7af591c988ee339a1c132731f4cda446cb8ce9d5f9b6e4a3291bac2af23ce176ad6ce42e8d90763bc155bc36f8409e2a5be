{"ast":null,"code":"function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport { AbstractDisplacementState, Action, InputType } from '@projectstorm/react-canvas-core';\nimport { CustomPortModel } from '../CustomPortModel';\nexport class DragNewLinkState extends AbstractDisplacementState {\n  constructor(options = {}) {\n    super({\n      name: 'drag-new-link'\n    });\n\n    _defineProperty(this, \"port\", void 0);\n\n    _defineProperty(this, \"link\", void 0);\n\n    _defineProperty(this, \"config\", void 0);\n\n    this.config = _objectSpread({\n      allowLooseLinks: true,\n      allowLinksFromLockedPorts: false\n    }, options);\n    this.registerAction(new Action({\n      type: InputType.MOUSE_DOWN,\n      fire: event => {\n        this.port = this.engine.getMouseElement(event.event);\n\n        if (!this.config.allowLinksFromLockedPorts && this.port.isLocked()) {\n          this.eject();\n          return;\n        }\n\n        this.link = this.port.createLinkModel(); // if no link is given, just eject the state\n\n        if (!this.link) {\n          this.eject();\n          return;\n        }\n\n        this.link.setSelected(true);\n        this.link.setSourcePort(this.port);\n        this.engine.getModel().addLink(this.link);\n        this.port.reportPosition();\n      }\n    }));\n    this.registerAction(new Action({\n      type: InputType.MOUSE_UP,\n      fire: event => {\n        const model = this.engine.getMouseElement(event.event); // check to see if we connected to a new port\n\n        if (model instanceof CustomPortModel) {\n          if (this.port.canLinkToPort(model)) {\n            this.link.setTargetPort(model);\n            model.reportPosition();\n            this.engine.repaintCanvas();\n            return;\n          } else {\n            this.link.remove();\n            this.engine.repaintCanvas();\n            return;\n          }\n        }\n\n        if (!this.config.allowLooseLinks) {\n          this.link.remove();\n          this.engine.repaintCanvas();\n        }\n      }\n    }));\n  }\n  /**\n   * Calculates the link's far-end point position on mouse move.\n   * In order to be as precise as possible the mouse initialXRelative & initialYRelative are taken into account as well\n   * as the possible engine offset\n   */\n\n\n  fireMouseMoved(event) {\n    const portPos = this.port.getPosition();\n    const zoomLevelPercentage = this.engine.getModel().getZoomLevel() / 100;\n    const engineOffsetX = this.engine.getModel().getOffsetX() / zoomLevelPercentage;\n    const engineOffsetY = this.engine.getModel().getOffsetY() / zoomLevelPercentage;\n    const initialXRelative = this.initialXRelative / zoomLevelPercentage;\n    const initialYRelative = this.initialYRelative / zoomLevelPercentage;\n    const linkNextX = portPos.x - engineOffsetX + (initialXRelative - portPos.x) + event.virtualDisplacementX;\n    const linkNextY = portPos.y - engineOffsetY + (initialYRelative - portPos.y) + event.virtualDisplacementY;\n    this.link.getLastPoint().setPosition(linkNextX, linkNextY);\n    this.engine.repaintCanvas();\n  }\n\n}","map":{"version":3,"sources":["/home/tuanquang/admin_ssr/src/components/Test/state/DragNewLinkState.ts"],"names":["AbstractDisplacementState","Action","InputType","CustomPortModel","DragNewLinkState","constructor","options","name","config","allowLooseLinks","allowLinksFromLockedPorts","registerAction","type","MOUSE_DOWN","fire","event","port","engine","getMouseElement","isLocked","eject","link","createLinkModel","setSelected","setSourcePort","getModel","addLink","reportPosition","MOUSE_UP","model","canLinkToPort","setTargetPort","repaintCanvas","remove","fireMouseMoved","portPos","getPosition","zoomLevelPercentage","getZoomLevel","engineOffsetX","getOffsetX","engineOffsetY","getOffsetY","initialXRelative","initialYRelative","linkNextX","x","virtualDisplacementX","linkNextY","y","virtualDisplacementY","getLastPoint","setPosition"],"mappings":";;;;;;AAAA,SACCA,yBADD,EAGCC,MAHD,EAKCC,SALD,QAMO,iCANP;AAOA,SAASC,eAAT,QAAgC,oBAAhC;AAiBA,OAAO,MAAMC,gBAAN,SAA+BJ,yBAA/B,CAAwE;AAK9EK,EAAAA,WAAW,CAACC,OAAgC,GAAG,EAApC,EAAwC;AAClD,UAAM;AAAEC,MAAAA,IAAI,EAAE;AAAR,KAAN;;AADkD;;AAAA;;AAAA;;AAGlD,SAAKC,MAAL;AACCC,MAAAA,eAAe,EAAE,IADlB;AAECC,MAAAA,yBAAyB,EAAE;AAF5B,OAGIJ,OAHJ;AAMA,SAAKK,cAAL,CACC,IAAIV,MAAJ,CAAW;AACVW,MAAAA,IAAI,EAAEV,SAAS,CAACW,UADN;AAEVC,MAAAA,IAAI,EAAGC,KAAD,IAAqD;AAC1D,aAAKC,IAAL,GAAY,KAAKC,MAAL,CAAYC,eAAZ,CAA4BH,KAAK,CAACA,KAAlC,CAAZ;;AACA,YAAI,CAAC,KAAKP,MAAL,CAAYE,yBAAb,IAA0C,KAAKM,IAAL,CAAUG,QAAV,EAA9C,EAAoE;AACnE,eAAKC,KAAL;AACA;AACA;;AACD,aAAKC,IAAL,GAAY,KAAKL,IAAL,CAAUM,eAAV,EAAZ,CAN0D,CAQ1D;;AACA,YAAI,CAAC,KAAKD,IAAV,EAAgB;AACf,eAAKD,KAAL;AACA;AACA;;AACD,aAAKC,IAAL,CAAUE,WAAV,CAAsB,IAAtB;AACA,aAAKF,IAAL,CAAUG,aAAV,CAAwB,KAAKR,IAA7B;AACA,aAAKC,MAAL,CAAYQ,QAAZ,GAAuBC,OAAvB,CAA+B,KAAKL,IAApC;AACA,aAAKL,IAAL,CAAUW,cAAV;AACA;AAnBS,KAAX,CADD;AAwBA,SAAKhB,cAAL,CACC,IAAIV,MAAJ,CAAW;AACVW,MAAAA,IAAI,EAAEV,SAAS,CAAC0B,QADN;AAEVd,MAAAA,IAAI,EAAGC,KAAD,IAAoC;AACzC,cAAMc,KAAK,GAAG,KAAKZ,MAAL,CAAYC,eAAZ,CAA4BH,KAAK,CAACA,KAAlC,CAAd,CADyC,CAEzC;;AACA,YAAIc,KAAK,YAAY1B,eAArB,EAAsC;AACrC,cAAI,KAAKa,IAAL,CAAUc,aAAV,CAAwBD,KAAxB,CAAJ,EAAoC;AACnC,iBAAKR,IAAL,CAAUU,aAAV,CAAwBF,KAAxB;AACAA,YAAAA,KAAK,CAACF,cAAN;AACA,iBAAKV,MAAL,CAAYe,aAAZ;AACA;AACA,WALD,MAKO;AACN,iBAAKX,IAAL,CAAUY,MAAV;AACA,iBAAKhB,MAAL,CAAYe,aAAZ;AACA;AACA;AACD;;AAED,YAAI,CAAC,KAAKxB,MAAL,CAAYC,eAAjB,EAAkC;AACjC,eAAKY,IAAL,CAAUY,MAAV;AACA,eAAKhB,MAAL,CAAYe,aAAZ;AACA;AACD;AAtBS,KAAX,CADD;AA0BA;AAED;AACD;AACA;AACA;AACA;;;AACCE,EAAAA,cAAc,CAACnB,KAAD,EAA6C;AAC1D,UAAMoB,OAAO,GAAG,KAAKnB,IAAL,CAAUoB,WAAV,EAAhB;AACA,UAAMC,mBAAmB,GAAG,KAAKpB,MAAL,CAAYQ,QAAZ,GAAuBa,YAAvB,KAAwC,GAApE;AACA,UAAMC,aAAa,GAAG,KAAKtB,MAAL,CAAYQ,QAAZ,GAAuBe,UAAvB,KAAsCH,mBAA5D;AACA,UAAMI,aAAa,GAAG,KAAKxB,MAAL,CAAYQ,QAAZ,GAAuBiB,UAAvB,KAAsCL,mBAA5D;AACA,UAAMM,gBAAgB,GAAG,KAAKA,gBAAL,GAAwBN,mBAAjD;AACA,UAAMO,gBAAgB,GAAG,KAAKA,gBAAL,GAAwBP,mBAAjD;AACA,UAAMQ,SAAS,GAAGV,OAAO,CAACW,CAAR,GAAYP,aAAZ,IAA6BI,gBAAgB,GAAGR,OAAO,CAACW,CAAxD,IAA6D/B,KAAK,CAACgC,oBAArF;AACA,UAAMC,SAAS,GAAGb,OAAO,CAACc,CAAR,GAAYR,aAAZ,IAA6BG,gBAAgB,GAAGT,OAAO,CAACc,CAAxD,IAA6DlC,KAAK,CAACmC,oBAArF;AAEA,SAAK7B,IAAL,CAAU8B,YAAV,GAAyBC,WAAzB,CAAqCP,SAArC,EAAgDG,SAAhD;AACA,SAAK/B,MAAL,CAAYe,aAAZ;AACA;;AAnF6E","sourcesContent":["import {\n\tAbstractDisplacementState,\n\tAbstractDisplacementStateEvent,\n\tAction,\n\tActionEvent,\n\tInputType\n} from '@projectstorm/react-canvas-core';\nimport { CustomPortModel } from '../CustomPortModel';\nimport { MouseEvent } from 'react';\nimport { CustomLinkModel } from '../entities/link/CustomLinkModel';\nimport { DiagramEngine } from '../DiagramEngine';\n\nexport interface DragNewLinkStateOptions {\n\t/**\n\t * If enabled, the links will stay on the canvas if they dont connect to a port\n\t * when dragging finishes\n\t */\n\tallowLooseLinks?: boolean;\n\t/**\n\t * If enabled, then a link can still be drawn from the port even if it is locked\n\t */\n\tallowLinksFromLockedPorts?: boolean;\n}\n\nexport class DragNewLinkState extends AbstractDisplacementState<DiagramEngine> {\n\tport: CustomPortModel;\n\tlink: CustomLinkModel;\n\tconfig: DragNewLinkStateOptions;\n\n\tconstructor(options: DragNewLinkStateOptions = {}) {\n\t\tsuper({ name: 'drag-new-link' });\n\n\t\tthis.config = {\n\t\t\tallowLooseLinks: true,\n\t\t\tallowLinksFromLockedPorts: false,\n\t\t\t...options\n\t\t};\n\n\t\tthis.registerAction(\n\t\t\tnew Action({\n\t\t\t\ttype: InputType.MOUSE_DOWN,\n\t\t\t\tfire: (event: ActionEvent<MouseEvent, CustomPortModel>) => {\n\t\t\t\t\tthis.port = this.engine.getMouseElement(event.event) as CustomPortModel;\n\t\t\t\t\tif (!this.config.allowLinksFromLockedPorts && this.port.isLocked()) {\n\t\t\t\t\t\tthis.eject();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthis.link = this.port.createLinkModel();\n\n\t\t\t\t\t// if no link is given, just eject the state\n\t\t\t\t\tif (!this.link) {\n\t\t\t\t\t\tthis.eject();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthis.link.setSelected(true);\n\t\t\t\t\tthis.link.setSourcePort(this.port);\n\t\t\t\t\tthis.engine.getModel().addLink(this.link);\n\t\t\t\t\tthis.port.reportPosition();\n\t\t\t\t}\n\t\t\t})\n\t\t);\n\n\t\tthis.registerAction(\n\t\t\tnew Action({\n\t\t\t\ttype: InputType.MOUSE_UP,\n\t\t\t\tfire: (event: ActionEvent<MouseEvent>) => {\n\t\t\t\t\tconst model = this.engine.getMouseElement(event.event);\n\t\t\t\t\t// check to see if we connected to a new port\n\t\t\t\t\tif (model instanceof CustomPortModel) {\n\t\t\t\t\t\tif (this.port.canLinkToPort(model)) {\n\t\t\t\t\t\t\tthis.link.setTargetPort(model);\n\t\t\t\t\t\t\tmodel.reportPosition();\n\t\t\t\t\t\t\tthis.engine.repaintCanvas();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.link.remove();\n\t\t\t\t\t\t\tthis.engine.repaintCanvas();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!this.config.allowLooseLinks) {\n\t\t\t\t\t\tthis.link.remove();\n\t\t\t\t\t\tthis.engine.repaintCanvas();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t);\n\t}\n\n\t/**\n\t * Calculates the link's far-end point position on mouse move.\n\t * In order to be as precise as possible the mouse initialXRelative & initialYRelative are taken into account as well\n\t * as the possible engine offset\n\t */\n\tfireMouseMoved(event: AbstractDisplacementStateEvent): any {\n\t\tconst portPos = this.port.getPosition();\n\t\tconst zoomLevelPercentage = this.engine.getModel().getZoomLevel() / 100;\n\t\tconst engineOffsetX = this.engine.getModel().getOffsetX() / zoomLevelPercentage;\n\t\tconst engineOffsetY = this.engine.getModel().getOffsetY() / zoomLevelPercentage;\n\t\tconst initialXRelative = this.initialXRelative / zoomLevelPercentage;\n\t\tconst initialYRelative = this.initialYRelative / zoomLevelPercentage;\n\t\tconst linkNextX = portPos.x - engineOffsetX + (initialXRelative - portPos.x) + event.virtualDisplacementX;\n\t\tconst linkNextY = portPos.y - engineOffsetY + (initialYRelative - portPos.y) + event.virtualDisplacementY;\n\n\t\tthis.link.getLastPoint().setPosition(linkNextX, linkNextY);\n\t\tthis.engine.repaintCanvas();\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}