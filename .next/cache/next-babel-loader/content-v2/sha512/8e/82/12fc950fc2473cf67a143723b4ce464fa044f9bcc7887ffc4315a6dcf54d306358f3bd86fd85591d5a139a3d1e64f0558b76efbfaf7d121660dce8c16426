{"ast":null,"code":"import { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nvar _jsxFileName = \"/home/tuanquang/admin_ssr/src/components/Test/CustomLinkWidget.tsx\";\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport * as React from 'react';\nimport { LinkWidget, PointModel } from '@projectstorm/react-diagrams-core';\nimport { DefaultLinkSegmentWidget } from '@projectstorm/react-diagrams-defaults';\nimport { Point } from '@projectstorm/geometry';\nexport class CustomLinkWidget extends React.Component {\n  // DOM references to the label and paths (if label is given), used to calculate dynamic positioning\n  constructor(props) {\n    super(props);\n\n    _defineProperty(this, \"refPaths\", void 0);\n\n    _defineProperty(this, \"refLabels\", void 0);\n\n    _defineProperty(this, \"dragging_index\", void 0);\n\n    _defineProperty(this, \"handleMove\", function (event) {\n      this.draggingEvent(event, this.dragging_index);\n    }.bind(this));\n\n    _defineProperty(this, \"handleUp\", function (event) {\n      // Unregister handlers to avoid multiple event handlers for other links\n      this.setState({\n        canDrag: false,\n        selected: false\n      });\n      window.removeEventListener('mousemove', this.handleMove);\n      window.removeEventListener('mouseup', this.handleUp);\n    }.bind(this));\n\n    this.refPaths = [];\n    this.state = {\n      selected: false,\n      canDrag: false\n    };\n    this.dragging_index = 0;\n  }\n\n  componentDidUpdate() {\n    this.props.link.setRenderedPaths(this.refPaths.map(ref => {\n      return ref.current;\n    }));\n  }\n\n  componentDidMount() {\n    this.props.link.setRenderedPaths(this.refPaths.map(ref => {\n      return ref.current;\n    }));\n  }\n\n  componentWillUnmount() {\n    this.props.link.setRenderedPaths([]);\n  }\n\n  generateLink(path, extraProps, id) {\n    const ref = /*#__PURE__*/React.createRef();\n    this.refPaths.push(ref);\n    return /*#__PURE__*/_jsxDEV(DefaultLinkSegmentWidget, {\n      path: path,\n      selected: this.state.selected,\n      diagramEngine: this.props.diagramEngine,\n      factory: this.props.diagramEngine.getFactoryForLink(this.props.link),\n      link: this.props.link,\n      forwardRef: ref,\n      onSelection: selected => {\n        this.setState({\n          selected: selected\n        });\n      },\n      extras: extraProps\n    }, `link-${id}`, false, {\n      fileName: _jsxFileName,\n      lineNumber: 76,\n      columnNumber: 7\n    }, this);\n  }\n\n  calculatePositions(points, event, index, coordinate) {\n    // If path is first or last add another point to keep node port on its position\n    if (index === 0) {\n      let point = new PointModel({\n        link: this.props.link,\n        position: new Point(points[index].getX(), points[index].getY())\n      });\n      this.props.link.addPoint(point, index);\n      this.dragging_index++;\n      return;\n    } else if (index === points.length - 2) {\n      let point = new PointModel({\n        link: this.props.link,\n        position: new Point(points[index + 1].getX(), points[index + 1].getY())\n      });\n      this.props.link.addPoint(point, index + 1);\n      return;\n    } // Merge two points if it is not close to node port and close to each other\n\n\n    if (index - 2 > 0) {\n      let _points = {\n        [index - 2]: points[index - 2].getPosition(),\n        [index + 1]: points[index + 1].getPosition(),\n        [index - 1]: points[index - 1].getPosition()\n      };\n\n      if (Math.abs(_points[index - 1][coordinate] - _points[index + 1][coordinate]) < 5) {\n        _points[index - 2][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n        _points[index + 1][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n        points[index - 2].setPosition(_points[index - 2]);\n        points[index + 1].setPosition(_points[index + 1]);\n        points[index - 1].remove();\n        points[index - 1].remove();\n        this.dragging_index--;\n        this.dragging_index--;\n        return;\n      }\n    } // Merge two points if it is not close to node port\n\n\n    if (index + 2 < points.length - 2) {\n      let _points = {\n        [index + 3]: points[index + 3].getPosition(),\n        [index + 2]: points[index + 2].getPosition(),\n        [index + 1]: points[index + 1].getPosition(),\n        [index]: points[index].getPosition()\n      };\n\n      if (Math.abs(_points[index + 1][coordinate] - _points[index + 2][coordinate]) < 5) {\n        _points[index][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n        _points[index + 3][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n        points[index].setPosition(_points[index]);\n        points[index + 3].setPosition(_points[index + 3]);\n        points[index + 1].remove();\n        points[index + 1].remove();\n        return;\n      }\n    } // If no condition above handled then just update path points position\n\n\n    let _points = {\n      [index]: points[index].getPosition(),\n      [index + 1]: points[index + 1].getPosition()\n    };\n    _points[index][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n    _points[index + 1][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n    points[index].setPosition(_points[index]);\n    points[index + 1].setPosition(_points[index + 1]);\n  }\n\n  draggingEvent(event, index) {\n    let points = this.props.link.getPoints(); // get moving difference. Index + 1 will work because links indexes has\n    // length = points.lenght - 1\n\n    let dx = Math.abs(points[index].getX() - points[index + 1].getX());\n    let dy = Math.abs(points[index].getY() - points[index + 1].getY()); // moving with y direction\n\n    if (dx === 0) {\n      this.calculatePositions(points, event, index, 'x');\n    } else if (dy === 0) {\n      this.calculatePositions(points, event, index, 'y');\n    }\n\n    this.props.link.setFirstAndLastPathsDirection();\n  }\n\n  render() {\n    //ensure id is present for all points on the path\n    let points = this.props.link.getPoints();\n    let paths = []; // Get points based on link orientation\n\n    let pointLeft = points[0];\n    let pointRight = points[points.length - 1];\n    let hadToSwitch = false;\n\n    if (pointLeft.getX() > pointRight.getX()) {\n      pointLeft = points[points.length - 1];\n      pointRight = points[0];\n      hadToSwitch = true;\n    }\n\n    let dy = Math.abs(points[0].getY() - points[points.length - 1].getY()); // When new link add one middle point to get everywhere 90° angle\n\n    if (this.props.link.getTargetPort() === null && points.length === 2) {\n      [...Array(2)].forEach(item => {\n        this.props.link.addPoint(new PointModel({\n          link: this.props.link,\n          position: new Point(pointLeft.getX(), pointRight.getY())\n        }), 1);\n      });\n      this.props.link.setManuallyFirstAndLastPathsDirection(true, true);\n    } // When new link is moving and not connected to target port move with middle point\n    // TODO: @DanielLazarLDAPPS This will be better to update in DragNewLinkState\n    //  in function fireMouseMoved to avoid calling this unexpectedly e.g. after Deserialize\n    else if (this.props.link.getTargetPort() === null && this.props.link.getSourcePort() !== null) {\n        points[1].setPosition(pointRight.getX() + (pointLeft.getX() - pointRight.getX()) / 2, !hadToSwitch ? pointLeft.getY() : pointRight.getY());\n        points[2].setPosition(pointRight.getX() + (pointLeft.getX() - pointRight.getX()) / 2, !hadToSwitch ? pointRight.getY() : pointLeft.getY());\n      } // Render was called but link is not moved but user.\n      // Node is moved and in this case fix coordinates to get 90° angle.\n      // For loop just for first and last path\n      else if (!this.state.canDrag && points.length > 2) {\n          // Those points and its position only will be moved\n          for (let i = 1; i < points.length; i += points.length - 2) {\n            if (i - 1 === 0) {\n              if (this.props.link.getFirstPathXdirection()) {\n                points[i].setPosition(points[i].getX(), points[i - 1].getY());\n              } else {\n                points[i].setPosition(points[i - 1].getX(), points[i].getY());\n              }\n            } else {\n              if (this.props.link.getLastPathXdirection()) {\n                points[i - 1].setPosition(points[i - 1].getX(), points[i].getY());\n              } else {\n                points[i - 1].setPosition(points[i].getX(), points[i - 1].getY());\n              }\n            }\n          }\n        } // If there is existing link which has two points add one\n    // NOTE: It doesn't matter if check is for dy or dx\n\n\n    if (points.length === 2 && dy !== 0 && !this.state.canDrag) {\n      this.props.link.addPoint(new PointModel({\n        link: this.props.link,\n        position: new Point(pointLeft.getX(), pointRight.getY())\n      }));\n    }\n\n    for (let j = 0; j < points.length - 1; j++) {\n      paths.push(this.generateLink(LinkWidget.generateLinePath(points[j], points[j + 1]), {\n        'data-linkid': this.props.link.getID(),\n        'data-point': j,\n        onMouseDown: event => {\n          if (event.button === 0) {\n            this.setState({\n              canDrag: true\n            });\n            this.dragging_index = j; // Register mouse move event to track mouse position\n            // On mouse up these events are unregistered check \"this.handleUp\"\n\n            window.addEventListener('mousemove', this.handleMove);\n            window.addEventListener('mouseup', this.handleUp);\n          }\n        },\n        onMouseEnter: event => {\n          this.setState({\n            selected: true\n          });\n          this.props.link.lastHoverIndexOfPath = j;\n        }\n      }, j));\n    }\n\n    this.refPaths = [];\n    return /*#__PURE__*/_jsxDEV(\"g\", {\n      \"data-default-link-test\": this.props.link.getOptions().testName,\n      children: [paths, _.map(this.props.link.getLabels(), (labelModel, index) => {\n        return /*#__PURE__*/_jsxDEV(LabelWidget, {\n          engine: this.props.diagramEngine,\n          label: labelModel,\n          index: index,\n          xIndex: pointLeft.getX(),\n          xIndex: pointLeft.getX()\n        }, labelModel.getID(), false, {\n          fileName: _jsxFileName,\n          lineNumber: 307,\n          columnNumber: 13\n        }, this);\n      })]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 303,\n      columnNumber: 7\n    }, this);\n  }\n\n}\n\n_defineProperty(CustomLinkWidget, \"defaultProps\", {\n  color: 'red',\n  width: 3,\n  link: null,\n  smooth: false,\n  diagramEngine: null,\n  factory: null\n});","map":{"version":3,"sources":["/home/tuanquang/admin_ssr/src/components/Test/CustomLinkWidget.tsx"],"names":["React","LinkWidget","PointModel","DefaultLinkSegmentWidget","Point","CustomLinkWidget","Component","constructor","props","event","draggingEvent","dragging_index","bind","setState","canDrag","selected","window","removeEventListener","handleMove","handleUp","refPaths","state","componentDidUpdate","link","setRenderedPaths","map","ref","current","componentDidMount","componentWillUnmount","generateLink","path","extraProps","id","createRef","push","diagramEngine","getFactoryForLink","calculatePositions","points","index","coordinate","point","position","getX","getY","addPoint","length","_points","getPosition","Math","abs","getRelativeMousePoint","setPosition","remove","getPoints","dx","dy","setFirstAndLastPathsDirection","render","paths","pointLeft","pointRight","hadToSwitch","getTargetPort","Array","forEach","item","setManuallyFirstAndLastPathsDirection","getSourcePort","i","getFirstPathXdirection","getLastPathXdirection","j","generateLinePath","getID","onMouseDown","button","addEventListener","onMouseEnter","lastHoverIndexOfPath","getOptions","testName","_","getLabels","labelModel","color","width","smooth","factory"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { DiagramEngine, LinkWidget, PointModel } from '@projectstorm/react-diagrams-core';\nimport { CustomLinkFactory } from './CustomLinkFactory';\nimport { DefaultLinkSegmentWidget } from '@projectstorm/react-diagrams-defaults';\nimport { Point } from '@projectstorm/geometry';\nimport { MouseEvent } from 'react';\nimport { CustomLinkModel } from './CustomLinkModel';\n// import store from '../../store';\n// import * as action from '../../actions/node';\nexport interface CustomLinkProps {\n  color?: string;\n  width?: number;\n  smooth?: boolean;\n  link: CustomLinkModel;\n  diagramEngine: DiagramEngine;\n  factory: CustomLinkFactory;\n}\n\nexport interface CustomLinkState {\n  selected: boolean;\n  canDrag: boolean;\n}\n\nexport class CustomLinkWidget extends React.Component<CustomLinkProps, CustomLinkState> {\n  public static defaultProps: CustomLinkProps = {\n    color: 'red',\n    width: 3,\n    link: null,\n    smooth: false,\n    diagramEngine: null,\n    factory: null,\n  };\n\n  refPaths: React.RefObject<SVGPathElement>[];\n\n  // DOM references to the label and paths (if label is given), used to calculate dynamic positioning\n  refLabels: { [id: string]: HTMLElement };\n  dragging_index: number;\n\n  constructor(props: CustomLinkProps) {\n    super(props);\n\n    this.refPaths = [];\n    this.state = {\n      selected: false,\n      canDrag: false,\n    };\n\n    this.dragging_index = 0;\n  }\n\n  componentDidUpdate(): void {\n    this.props.link.setRenderedPaths(\n      this.refPaths.map(ref => {\n        return ref.current;\n      })\n    );\n  }\n\n  componentDidMount(): void {\n    this.props.link.setRenderedPaths(\n      this.refPaths.map(ref => {\n        return ref.current;\n      })\n    );\n  }\n\n  componentWillUnmount(): void {\n    this.props.link.setRenderedPaths([]);\n  }\n\n  generateLink(path: string, extraProps: any, id: string | number): JSX.Element {\n    const ref = React.createRef<SVGPathElement>();\n    this.refPaths.push(ref);\n    return (\n      <DefaultLinkSegmentWidget\n        key={`link-${id}`}\n        path={path}\n        selected={this.state.selected}\n        diagramEngine={this.props.diagramEngine}\n        factory={this.props.diagramEngine.getFactoryForLink(this.props.link)}\n        link={this.props.link}\n        forwardRef={ref}\n        onSelection={selected => {\n          this.setState({ selected: selected });\n        }}\n        extras={extraProps}\n      />\n    );\n  }\n\n  calculatePositions(points: PointModel[], event: MouseEvent, index: number, coordinate: string) {\n    // If path is first or last add another point to keep node port on its position\n    if (index === 0) {\n      let point = new PointModel({\n        link: this.props.link,\n        position: new Point(points[index].getX(), points[index].getY()),\n      });\n      this.props.link.addPoint(point, index);\n      this.dragging_index++;\n      return;\n    } else if (index === points.length - 2) {\n      let point = new PointModel({\n        link: this.props.link,\n        position: new Point(points[index + 1].getX(), points[index + 1].getY()),\n      });\n      this.props.link.addPoint(point, index + 1);\n      return;\n    }\n\n    // Merge two points if it is not close to node port and close to each other\n    if (index - 2 > 0) {\n      let _points = {\n        [index - 2]: points[index - 2].getPosition(),\n        [index + 1]: points[index + 1].getPosition(),\n        [index - 1]: points[index - 1].getPosition(),\n      };\n      if (Math.abs(_points[index - 1][coordinate] - _points[index + 1][coordinate]) < 5) {\n        _points[index - 2][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[\n          coordinate\n        ];\n        _points[index + 1][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[\n          coordinate\n        ];\n        points[index - 2].setPosition(_points[index - 2]);\n        points[index + 1].setPosition(_points[index + 1]);\n        points[index - 1].remove();\n        points[index - 1].remove();\n        this.dragging_index--;\n        this.dragging_index--;\n        return;\n      }\n    }\n\n    // Merge two points if it is not close to node port\n    if (index + 2 < points.length - 2) {\n      let _points = {\n        [index + 3]: points[index + 3].getPosition(),\n        [index + 2]: points[index + 2].getPosition(),\n        [index + 1]: points[index + 1].getPosition(),\n        [index]: points[index].getPosition(),\n      };\n      if (Math.abs(_points[index + 1][coordinate] - _points[index + 2][coordinate]) < 5) {\n        _points[index][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[\n          coordinate\n        ];\n        _points[index + 3][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[\n          coordinate\n        ];\n        points[index].setPosition(_points[index]);\n        points[index + 3].setPosition(_points[index + 3]);\n        points[index + 1].remove();\n        points[index + 1].remove();\n        return;\n      }\n    }\n\n    // If no condition above handled then just update path points position\n    let _points = {\n      [index]: points[index].getPosition(),\n      [index + 1]: points[index + 1].getPosition(),\n    };\n    _points[index][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n    _points[index + 1][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[\n      coordinate\n    ];\n    points[index].setPosition(_points[index]);\n    points[index + 1].setPosition(_points[index + 1]);\n  }\n\n  draggingEvent(event: MouseEvent, index: number) {\n    let points = this.props.link.getPoints();\n    // get moving difference. Index + 1 will work because links indexes has\n    // length = points.lenght - 1\n    let dx = Math.abs(points[index].getX() - points[index + 1].getX());\n    let dy = Math.abs(points[index].getY() - points[index + 1].getY());\n\n    // moving with y direction\n    if (dx === 0) {\n      this.calculatePositions(points, event, index, 'x');\n    } else if (dy === 0) {\n      this.calculatePositions(points, event, index, 'y');\n    }\n    this.props.link.setFirstAndLastPathsDirection();\n  }\n\n  handleMove = function(event: MouseEvent) {\n    this.draggingEvent(event, this.dragging_index);\n  }.bind(this);\n\n  handleUp = function(event: MouseEvent) {\n    // Unregister handlers to avoid multiple event handlers for other links\n    this.setState({ canDrag: false, selected: false });\n    window.removeEventListener('mousemove', this.handleMove);\n    window.removeEventListener('mouseup', this.handleUp);\n  }.bind(this);\n\n  render() {\n    //ensure id is present for all points on the path\n    let points = this.props.link.getPoints();\n    let paths = [];\n\n    // Get points based on link orientation\n    let pointLeft = points[0];\n    let pointRight = points[points.length - 1];\n    let hadToSwitch = false;\n    if (pointLeft.getX() > pointRight.getX()) {\n      pointLeft = points[points.length - 1];\n      pointRight = points[0];\n      hadToSwitch = true;\n    }\n    let dy = Math.abs(points[0].getY() - points[points.length - 1].getY());\n\n    // When new link add one middle point to get everywhere 90° angle\n    if (this.props.link.getTargetPort() === null && points.length === 2) {\n      [...Array(2)].forEach(item => {\n        this.props.link.addPoint(\n          new PointModel({\n            link: this.props.link,\n            position: new Point(pointLeft.getX(), pointRight.getY()),\n          }),\n          1\n        );\n      });\n      this.props.link.setManuallyFirstAndLastPathsDirection(true, true);\n    }\n    // When new link is moving and not connected to target port move with middle point\n    // TODO: @DanielLazarLDAPPS This will be better to update in DragNewLinkState\n    //  in function fireMouseMoved to avoid calling this unexpectedly e.g. after Deserialize\n    else if (this.props.link.getTargetPort() === null && this.props.link.getSourcePort() !== null) {\n      points[1].setPosition(\n        pointRight.getX() + (pointLeft.getX() - pointRight.getX()) / 2,\n        !hadToSwitch ? pointLeft.getY() : pointRight.getY()\n      );\n      points[2].setPosition(\n        pointRight.getX() + (pointLeft.getX() - pointRight.getX()) / 2,\n        !hadToSwitch ? pointRight.getY() : pointLeft.getY()\n      );\n    }\n    // Render was called but link is not moved but user.\n    // Node is moved and in this case fix coordinates to get 90° angle.\n    // For loop just for first and last path\n    else if (!this.state.canDrag && points.length > 2) {\n      // Those points and its position only will be moved\n      for (let i = 1; i < points.length; i += points.length - 2) {\n        if (i - 1 === 0) {\n          if (this.props.link.getFirstPathXdirection()) {\n            points[i].setPosition(points[i].getX(), points[i - 1].getY());\n          } else {\n            points[i].setPosition(points[i - 1].getX(), points[i].getY());\n          }\n        } else {\n          if (this.props.link.getLastPathXdirection()) {\n            points[i - 1].setPosition(points[i - 1].getX(), points[i].getY());\n          } else {\n            points[i - 1].setPosition(points[i].getX(), points[i - 1].getY());\n          }\n        }\n      }\n    }\n\n    // If there is existing link which has two points add one\n    // NOTE: It doesn't matter if check is for dy or dx\n    if (points.length === 2 && dy !== 0 && !this.state.canDrag) {\n      this.props.link.addPoint(\n        new PointModel({\n          link: this.props.link,\n          position: new Point(pointLeft.getX(), pointRight.getY()),\n        })\n      );\n    }\n\n    for (let j = 0; j < points.length - 1; j++) {\n      paths.push(\n        this.generateLink(\n          LinkWidget.generateLinePath(points[j], points[j + 1]),\n          {\n            'data-linkid': this.props.link.getID(),\n            'data-point': j,\n            onMouseDown: (event: MouseEvent) => {\n              if (event.button === 0) {\n                this.setState({ canDrag: true });\n                this.dragging_index = j;\n                // Register mouse move event to track mouse position\n                // On mouse up these events are unregistered check \"this.handleUp\"\n                window.addEventListener('mousemove', this.handleMove);\n                window.addEventListener('mouseup', this.handleUp);\n              }\n            },\n            onMouseEnter: (event: MouseEvent) => {\n              this.setState({ selected: true });\n              this.props.link.lastHoverIndexOfPath = j;\n            },\n          },\n          j\n        )\n      );\n    }\n\n    this.refPaths = [];\n\n    return (\n      <g data-default-link-test={this.props.link.getOptions().testName}>\n        {paths}\n        {_.map(this.props.link.getLabels(), (labelModel, index) => {\n          return (\n            <LabelWidget\n              key={labelModel.getID()}\n              engine={this.props.diagramEngine}\n              label={labelModel}\n              index={index}\n              xIndex={pointLeft.getX()}\n              xIndex={pointLeft.getX()}\n            />\n          );\n        })}\n      </g>\n    );\n  }\n}\n"]},"metadata":{},"sourceType":"module"}