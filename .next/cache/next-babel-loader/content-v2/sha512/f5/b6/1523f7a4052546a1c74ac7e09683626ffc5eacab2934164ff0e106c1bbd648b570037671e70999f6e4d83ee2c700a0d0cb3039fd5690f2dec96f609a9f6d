{"ast":null,"code":"import \"antd/lib/notification/style\";\nimport _notification from \"antd/lib/notification\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nimport axios from 'axios';\nimport moment from 'moment';\nimport { history } from 'next/link';\nimport { stringify, parse } from 'qs';\nimport store, { storeKeys } from './persistent-store';\nlet refreshTimeout;\nlet lastAccessTime;\nexport const baseURL = '/cms';\nexport const contentType = {\n  form: 'application/x-www-form-urlencoded',\n  json: 'application/json'\n};\nexport const headerKeys = {\n  ContentType: 'Content-Type',\n  Authorization: 'Authorization'\n};\nexport const methods = {\n  GET: 'GET',\n  POST: 'POST',\n  PUT: 'PUT',\n  DELETE: 'DELETE',\n  PATCH: 'PATCH',\n  HEAD: 'HEAD',\n  OPTIONS: 'OPTIONS'\n}; // Get access token\n\nexport function getAccessToken() {\n  const token = store.get(storeKeys.AccessToken);\n\n  if (!token) {\n    return '';\n  }\n\n  return token.access_token;\n  return '';\n} // Wrap the URL with the token\n\nexport function wrapURLWithToken(url) {\n  const ss = url.split('?');\n  const query = parse(ss[1]);\n  query.accessToken = getAccessToken();\n  return `${ss[0]}?${stringify(query)}`;\n} // Sign out\n\nexport function logout() {\n  if (refreshTimeout) {\n    clearTimeout(refreshTimeout);\n  }\n\n  store.remove(storeKeys.AccessToken);\n  const {\n    redirect\n  } = parse(window.location.href.split('?')[1]);\n\n  if (window.location.pathname !== '/login' && !redirect) {\n    window.location = '/login'; // window.history.replace({\n    //   pathname: '/user/login',\n    //   search: stringify({\n    //     redirect: window.location.href,\n    //   }),\n    // });\n  }\n} // request Interceptor\n\nfunction requestInterceptors(c) {\n  const config = _objectSpread({}, c);\n\n  const token = store.get(storeKeys.AccessToken);\n\n  if (token) {\n    config.headers[headerKeys.Authorization] = `${token.token_type} ${token.access_token}`;\n  }\n\n  return config;\n} // ajax request\n\n\nexport default function request(url, options = {}) {\n  // console.log('request_cms.request: AccessToken: ', storeKeys.AccessToken);\n  const oldToken = store.get(storeKeys.AccessToken); // console.log(\"oldToken: \", oldToken);\n\n  if (oldToken && oldToken.expires_at - lastAccessTime <= 0) {\n    if (refreshTimeout) {\n      clearTimeout(refreshTimeout);\n    }\n\n    logout(); // eslint-disable-next-line compat/compat\n\n    return Promise.reject(new Error('The token has expired'));\n  }\n\n  lastAccessTime = moment().unix();\n\n  const opts = _objectSpread({}, options);\n\n  let showNotify = true;\n\n  if (opts.hideNotify) {\n    showNotify = false;\n    delete opts.hideNotify;\n  }\n\n  const config = _objectSpread({\n    method: methods.GET,\n    baseURL,\n    headers: {},\n    transformRequest: (data, headers) => {\n      switch (headers[headerKeys.ContentType]) {\n        case contentType.json:\n          return JSON.stringify(data);\n\n        case contentType.form:\n          return stringify(data);\n\n        default:\n          return data;\n      }\n    },\n    paramsSerializer: params => {\n      return stringify(params);\n    },\n    timeout: 60000\n  }, opts);\n\n  if (!(config.headers && config.headers[headerKeys.ContentType]) && [methods.POST, methods.PUT, methods.PATCH].indexOf(config.method) > -1) {\n    config.headers[headerKeys.ContentType] = contentType.json;\n  }\n\n  const instance = axios.create(config);\n  instance.interceptors.request.use(requestInterceptors);\n  return instance.request({\n    url\n  }).then(res => {\n    const {\n      data\n    } = res; // console.log('request_cms.request: Data', data);\n\n    return data;\n  }).catch(error => {\n    const {\n      response\n    } = error;\n    const {\n      status,\n      data\n    } = response;\n\n    if (status === 401 && data.error && data.error.code === 9999) {\n      logout();\n      return response;\n    }\n\n    if (showNotify) {\n      let msg = 'Request error';\n\n      if (status === 504) {\n        msg = 'Not connected to server';\n      } else if (data && data.error) {\n        msg = data.error.message;\n      }\n\n      _notification.error({\n        message: `${config.baseURL}${url}`,\n        description: msg\n      });\n    }\n\n    return response;\n  });\n} // Put in the access token\n\nexport function setToken(token) {\n  lastAccessTime = token.expires_at;\n  store.set(storeKeys.AccessToken, token);\n\n  if (refreshTimeout) {\n    clearTimeout(refreshTimeout);\n  } // Renew the token 10 minutes in advance\n\n\n  const timeout = token.expires_at - moment().unix() - 10;\n\n  if (timeout > 0) {\n    refreshTimeout = setTimeout(() => {\n      const oldToken = store.get(storeKeys.AccessToken);\n\n      if (oldToken && oldToken.expires_at - lastAccessTime <= 0) {\n        if (refreshTimeout) {\n          clearTimeout(refreshTimeout);\n        }\n\n        return;\n      }\n\n      request('/v1/pub/refresh-token', {\n        method: methods.POST\n      }).then(res => {\n        setToken(res);\n      });\n    }, timeout * 1000);\n  }\n}","map":null,"metadata":{},"sourceType":"module"}