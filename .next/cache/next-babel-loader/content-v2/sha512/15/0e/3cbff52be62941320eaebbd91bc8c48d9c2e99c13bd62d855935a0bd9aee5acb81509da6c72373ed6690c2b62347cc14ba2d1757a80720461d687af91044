{"ast":null,"code":"import _classCallCheck from \"/home/tuanquang/admin_ssr/node_modules/next/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/tuanquang/admin_ssr/node_modules/next/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"/home/tuanquang/admin_ssr/node_modules/next/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"/home/tuanquang/admin_ssr/node_modules/next/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"/home/tuanquang/admin_ssr/node_modules/next/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/home/tuanquang/admin_ssr/node_modules/next/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _defineProperty from \"/home/tuanquang/admin_ssr/node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport { AbstractDisplacementState, Action, InputType } from '@projectstorm/react-canvas-core';\nimport { CustomPortModel } from '../entities/port/CustomPortModel';\nexport var DragNewLinkState = /*#__PURE__*/function (_AbstractDisplacement) {\n  _inherits(DragNewLinkState, _AbstractDisplacement);\n\n  var _super = _createSuper(DragNewLinkState);\n\n  function DragNewLinkState() {\n    var _this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, DragNewLinkState);\n\n    _this = _super.call(this, {\n      name: 'drag-new-link'\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"port\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"link\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"config\", void 0);\n\n    _this.config = _objectSpread({\n      allowLooseLinks: true,\n      allowLinksFromLockedPorts: false\n    }, options);\n\n    _this.registerAction(new Action({\n      type: InputType.MOUSE_DOWN,\n      fire: function fire(event) {\n        _this.port = _this.engine.getMouseElement(event.event);\n\n        if (!_this.config.allowLinksFromLockedPorts && _this.port.isLocked()) {\n          _this.eject();\n\n          return;\n        }\n\n        _this.link = _this.port.createLinkModel(); // if no link is given, just eject the state\n\n        if (!_this.link) {\n          _this.eject();\n\n          return;\n        }\n\n        _this.link.setSelected(true);\n\n        _this.link.setSourcePort(_this.port);\n\n        _this.engine.getModel().addLink(_this.link);\n\n        _this.port.reportPosition();\n      }\n    }));\n\n    _this.registerAction(new Action({\n      type: InputType.MOUSE_UP,\n      fire: function fire(event) {\n        var model = _this.engine.getMouseElement(event.event); // check to see if we connected to a new port\n\n\n        if (model instanceof CustomPortModel) {\n          if (_this.port.canLinkToPort(model)) {\n            _this.link.setTargetPort(model);\n\n            model.reportPosition();\n\n            _this.engine.repaintCanvas();\n\n            return;\n          } else {\n            _this.link.remove();\n\n            _this.engine.repaintCanvas();\n\n            return;\n          }\n        }\n\n        if (!_this.config.allowLooseLinks) {\n          _this.link.remove();\n\n          _this.engine.repaintCanvas();\n        }\n      }\n    }));\n\n    return _this;\n  }\n  /**\n   * Calculates the link's far-end point position on mouse move.\n   * In order to be as precise as possible the mouse initialXRelative & initialYRelative are taken into account as well\n   * as the possible engine offset\n   */\n\n\n  _createClass(DragNewLinkState, [{\n    key: \"fireMouseMoved\",\n    value: function fireMouseMoved(event) {\n      var portPos = this.port.getPosition();\n      var zoomLevelPercentage = this.engine.getModel().getZoomLevel() / 100;\n      var engineOffsetX = this.engine.getModel().getOffsetX() / zoomLevelPercentage;\n      var engineOffsetY = this.engine.getModel().getOffsetY() / zoomLevelPercentage;\n      var initialXRelative = this.initialXRelative / zoomLevelPercentage;\n      var initialYRelative = this.initialYRelative / zoomLevelPercentage;\n      var linkNextX = portPos.x - engineOffsetX + (initialXRelative - portPos.x) + event.virtualDisplacementX;\n      var linkNextY = portPos.y - engineOffsetY + (initialYRelative - portPos.y) + event.virtualDisplacementY;\n      this.link.getLastPoint().setPosition(linkNextX, linkNextY);\n      this.engine.repaintCanvas();\n    }\n  }]);\n\n  return DragNewLinkState;\n}(AbstractDisplacementState);","map":{"version":3,"sources":["/home/tuanquang/admin_ssr/src/components/Test/state/DragNewLinkState.ts"],"names":["AbstractDisplacementState","Action","InputType","CustomPortModel","DragNewLinkState","options","name","config","allowLooseLinks","allowLinksFromLockedPorts","registerAction","type","MOUSE_DOWN","fire","event","port","engine","getMouseElement","isLocked","eject","link","createLinkModel","setSelected","setSourcePort","getModel","addLink","reportPosition","MOUSE_UP","model","canLinkToPort","setTargetPort","repaintCanvas","remove","portPos","getPosition","zoomLevelPercentage","getZoomLevel","engineOffsetX","getOffsetX","engineOffsetY","getOffsetY","initialXRelative","initialYRelative","linkNextX","x","virtualDisplacementX","linkNextY","y","virtualDisplacementY","getLastPoint","setPosition"],"mappings":"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","sourcesContent":["import {\n\tAbstractDisplacementState,\n\tAbstractDisplacementStateEvent,\n\tAction,\n\tActionEvent,\n\tInputType\n} from '@projectstorm/react-canvas-core';\nimport { CustomPortModel } from '../entities/port/CustomPortModel';\nimport { MouseEvent } from 'react';\nimport { LinkModel } from '../entities/link/LinkModel';\nimport { DiagramEngine } from '../DiagramEngine';\n\nexport interface DragNewLinkStateOptions {\n\t/**\n\t * If enabled, the links will stay on the canvas if they dont connect to a port\n\t * when dragging finishes\n\t */\n\tallowLooseLinks?: boolean;\n\t/**\n\t * If enabled, then a link can still be drawn from the port even if it is locked\n\t */\n\tallowLinksFromLockedPorts?: boolean;\n}\n\nexport class DragNewLinkState extends AbstractDisplacementState<DiagramEngine> {\n\tport: CustomPortModel;\n\tlink: LinkModel;\n\tconfig: DragNewLinkStateOptions;\n\n\tconstructor(options: DragNewLinkStateOptions = {}) {\n\t\tsuper({ name: 'drag-new-link' });\n\n\t\tthis.config = {\n\t\t\tallowLooseLinks: true,\n\t\t\tallowLinksFromLockedPorts: false,\n\t\t\t...options\n\t\t};\n\n\t\tthis.registerAction(\n\t\t\tnew Action({\n\t\t\t\ttype: InputType.MOUSE_DOWN,\n\t\t\t\tfire: (event: ActionEvent<MouseEvent, CustomPortModel>) => {\n\t\t\t\t\tthis.port = this.engine.getMouseElement(event.event) as CustomPortModel;\n\t\t\t\t\tif (!this.config.allowLinksFromLockedPorts && this.port.isLocked()) {\n\t\t\t\t\t\tthis.eject();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthis.link = this.port.createLinkModel();\n\n\t\t\t\t\t// if no link is given, just eject the state\n\t\t\t\t\tif (!this.link) {\n\t\t\t\t\t\tthis.eject();\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tthis.link.setSelected(true);\n\t\t\t\t\tthis.link.setSourcePort(this.port);\n\t\t\t\t\tthis.engine.getModel().addLink(this.link);\n\t\t\t\t\tthis.port.reportPosition();\n\t\t\t\t}\n\t\t\t})\n\t\t);\n\n\t\tthis.registerAction(\n\t\t\tnew Action({\n\t\t\t\ttype: InputType.MOUSE_UP,\n\t\t\t\tfire: (event: ActionEvent<MouseEvent>) => {\n\t\t\t\t\tconst model = this.engine.getMouseElement(event.event);\n\t\t\t\t\t// check to see if we connected to a new port\n\t\t\t\t\tif (model instanceof CustomPortModel) {\n\t\t\t\t\t\tif (this.port.canLinkToPort(model)) {\n\t\t\t\t\t\t\tthis.link.setTargetPort(model);\n\t\t\t\t\t\t\tmodel.reportPosition();\n\t\t\t\t\t\t\tthis.engine.repaintCanvas();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthis.link.remove();\n\t\t\t\t\t\t\tthis.engine.repaintCanvas();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!this.config.allowLooseLinks) {\n\t\t\t\t\t\tthis.link.remove();\n\t\t\t\t\t\tthis.engine.repaintCanvas();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})\n\t\t);\n\t}\n\n\t/**\n\t * Calculates the link's far-end point position on mouse move.\n\t * In order to be as precise as possible the mouse initialXRelative & initialYRelative are taken into account as well\n\t * as the possible engine offset\n\t */\n\tfireMouseMoved(event: AbstractDisplacementStateEvent): any {\n\t\tconst portPos = this.port.getPosition();\n\t\tconst zoomLevelPercentage = this.engine.getModel().getZoomLevel() / 100;\n\t\tconst engineOffsetX = this.engine.getModel().getOffsetX() / zoomLevelPercentage;\n\t\tconst engineOffsetY = this.engine.getModel().getOffsetY() / zoomLevelPercentage;\n\t\tconst initialXRelative = this.initialXRelative / zoomLevelPercentage;\n\t\tconst initialYRelative = this.initialYRelative / zoomLevelPercentage;\n\t\tconst linkNextX = portPos.x - engineOffsetX + (initialXRelative - portPos.x) + event.virtualDisplacementX;\n\t\tconst linkNextY = portPos.y - engineOffsetY + (initialYRelative - portPos.y) + event.virtualDisplacementY;\n\n\t\tthis.link.getLastPoint().setPosition(linkNextX, linkNextY);\n\t\tthis.engine.repaintCanvas();\n\t}\n}\n"]},"metadata":{},"sourceType":"module"}