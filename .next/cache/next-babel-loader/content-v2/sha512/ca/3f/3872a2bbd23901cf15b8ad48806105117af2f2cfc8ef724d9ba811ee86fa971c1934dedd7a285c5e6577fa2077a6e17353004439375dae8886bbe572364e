{"ast":null,"code":"import _toConsumableArray from \"/home/tuanquang/admin_ssr/node_modules/next/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nimport _classCallCheck from \"/home/tuanquang/admin_ssr/node_modules/next/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/tuanquang/admin_ssr/node_modules/next/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"/home/tuanquang/admin_ssr/node_modules/next/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"/home/tuanquang/admin_ssr/node_modules/next/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _possibleConstructorReturn from \"/home/tuanquang/admin_ssr/node_modules/next/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _getPrototypeOf from \"/home/tuanquang/admin_ssr/node_modules/next/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _defineProperty from \"/home/tuanquang/admin_ssr/node_modules/next/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nvar _jsxFileName = \"/home/tuanquang/admin_ssr/src/components/Test/CustomLinkWidget.tsx\";\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nimport * as React from 'react';\nimport { LinkWidget, PointModel } from '@projectstorm/react-diagrams-core';\nimport { DefaultLinkSegmentWidget } from '@projectstorm/react-diagrams-defaults';\nimport { Point } from '@projectstorm/geometry';\nexport var RightAngleLinkWidget = /*#__PURE__*/function (_React$Component) {\n  _inherits(RightAngleLinkWidget, _React$Component);\n\n  var _super = _createSuper(RightAngleLinkWidget);\n\n  // DOM references to the label and paths (if label is given), used to calculate dynamic positioning\n  function RightAngleLinkWidget(props) {\n    var _this;\n\n    _classCallCheck(this, RightAngleLinkWidget);\n\n    _this = _super.call(this, props);\n\n    _defineProperty(_assertThisInitialized(_this), \"refPaths\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"refLabels\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"dragging_index\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"handleMove\", function (event) {\n      this.draggingEvent(event, this.dragging_index);\n    }.bind(_assertThisInitialized(_this)));\n\n    _defineProperty(_assertThisInitialized(_this), \"handleUp\", function (event) {\n      // Unregister handlers to avoid multiple event handlers for other links\n      this.setState({\n        canDrag: false,\n        selected: false\n      });\n      window.removeEventListener('mousemove', this.handleMove);\n      window.removeEventListener('mouseup', this.handleUp);\n    }.bind(_assertThisInitialized(_this)));\n\n    _this.refPaths = [];\n    _this.state = {\n      selected: false,\n      canDrag: false\n    };\n    _this.dragging_index = 0;\n    return _this;\n  }\n\n  _createClass(RightAngleLinkWidget, [{\n    key: \"componentDidUpdate\",\n    value: function componentDidUpdate() {\n      this.props.link.setRenderedPaths(this.refPaths.map(function (ref) {\n        return ref.current;\n      }));\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      this.props.link.setRenderedPaths(this.refPaths.map(function (ref) {\n        return ref.current;\n      }));\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      this.props.link.setRenderedPaths([]);\n    }\n  }, {\n    key: \"generateLink\",\n    value: function generateLink(path, extraProps, id) {\n      var _this2 = this;\n\n      var ref = /*#__PURE__*/React.createRef();\n      this.refPaths.push(ref);\n      return /*#__PURE__*/_jsxDEV(DefaultLinkSegmentWidget, {\n        path: path,\n        selected: this.state.selected,\n        diagramEngine: this.props.diagramEngine,\n        factory: this.props.diagramEngine.getFactoryForLink(this.props.link),\n        link: this.props.link,\n        forwardRef: ref,\n        onSelection: function onSelection(selected) {\n          _this2.setState({\n            selected: selected\n          });\n        },\n        extras: extraProps\n      }, \"link-\".concat(id), false, {\n        fileName: _jsxFileName,\n        lineNumber: 78,\n        columnNumber: 7\n      }, this);\n    }\n  }, {\n    key: \"calculatePositions\",\n    value: function calculatePositions(points, event, index, coordinate) {\n      var _points6;\n\n      // If path is first or last add another point to keep node port on its position\n      if (index === 0) {\n        var point = new PointModel({\n          link: this.props.link,\n          position: new Point(points[index].getX(), points[index].getY())\n        });\n        this.props.link.addPoint(point, index);\n        this.dragging_index++;\n        return;\n      } else if (index === points.length - 2) {\n        var _point = new PointModel({\n          link: this.props.link,\n          position: new Point(points[index + 1].getX(), points[index + 1].getY())\n        });\n\n        this.props.link.addPoint(_point, index + 1);\n        return;\n      } // Merge two points if it is not close to node port and close to each other\n\n\n      if (index - 2 > 0) {\n        var _points3;\n\n        var _points2 = (_points3 = {}, _defineProperty(_points3, index - 2, points[index - 2].getPosition()), _defineProperty(_points3, index + 1, points[index + 1].getPosition()), _defineProperty(_points3, index - 1, points[index - 1].getPosition()), _points3);\n\n        if (Math.abs(_points2[index - 1][coordinate] - _points2[index + 1][coordinate]) < 5) {\n          _points2[index - 2][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n          _points2[index + 1][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n          points[index - 2].setPosition(_points2[index - 2]);\n          points[index + 1].setPosition(_points2[index + 1]);\n          points[index - 1].remove();\n          points[index - 1].remove();\n          this.dragging_index--;\n          this.dragging_index--;\n          return;\n        }\n      } // Merge two points if it is not close to node port\n\n\n      if (index + 2 < points.length - 2) {\n        var _points5;\n\n        var _points4 = (_points5 = {}, _defineProperty(_points5, index + 3, points[index + 3].getPosition()), _defineProperty(_points5, index + 2, points[index + 2].getPosition()), _defineProperty(_points5, index + 1, points[index + 1].getPosition()), _defineProperty(_points5, index, points[index].getPosition()), _points5);\n\n        if (Math.abs(_points4[index + 1][coordinate] - _points4[index + 2][coordinate]) < 5) {\n          _points4[index][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n          _points4[index + 3][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n          points[index].setPosition(_points4[index]);\n          points[index + 3].setPosition(_points4[index + 3]);\n          points[index + 1].remove();\n          points[index + 1].remove();\n          return;\n        }\n      } // If no condition above handled then just update path points position\n\n\n      var _points = (_points6 = {}, _defineProperty(_points6, index, points[index].getPosition()), _defineProperty(_points6, index + 1, points[index + 1].getPosition()), _points6);\n\n      _points[index][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n      _points[index + 1][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n      points[index].setPosition(_points[index]);\n      points[index + 1].setPosition(_points[index + 1]);\n    }\n  }, {\n    key: \"draggingEvent\",\n    value: function draggingEvent(event, index) {\n      var points = this.props.link.getPoints(); // get moving difference. Index + 1 will work because links indexes has\n      // length = points.lenght - 1\n\n      var dx = Math.abs(points[index].getX() - points[index + 1].getX());\n      var dy = Math.abs(points[index].getY() - points[index + 1].getY()); // moving with y direction\n\n      if (dx === 0) {\n        this.calculatePositions(points, event, index, 'x');\n      } else if (dy === 0) {\n        this.calculatePositions(points, event, index, 'y');\n      }\n\n      this.props.link.setFirstAndLastPathsDirection();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this3 = this;\n\n      //ensure id is present for all points on the path\n      var points = this.props.link.getPoints();\n      var paths = []; // Get points based on link orientation\n\n      var pointLeft = points[0];\n      var pointRight = points[points.length - 1];\n      var hadToSwitch = false;\n\n      if (pointLeft.getX() > pointRight.getX()) {\n        pointLeft = points[points.length - 1];\n        pointRight = points[0];\n        hadToSwitch = true;\n      }\n\n      var dy = Math.abs(points[0].getY() - points[points.length - 1].getY()); // When new link add one middle point to get everywhere 90째 angle\n\n      if (this.props.link.getTargetPort() === null && points.length === 2) {\n        _toConsumableArray(Array(2)).forEach(function (item) {\n          _this3.props.link.addPoint(new PointModel({\n            link: _this3.props.link,\n            position: new Point(pointLeft.getX(), pointRight.getY())\n          }), 1);\n        });\n\n        this.props.link.setManuallyFirstAndLastPathsDirection(true, true);\n      } // When new link is moving and not connected to target port move with middle point\n      // TODO: @DanielLazarLDAPPS This will be better to update in DragNewLinkState\n      //  in function fireMouseMoved to avoid calling this unexpectedly e.g. after Deserialize\n      else if (this.props.link.getTargetPort() === null && this.props.link.getSourcePort() !== null) {\n          points[1].setPosition(pointRight.getX() + (pointLeft.getX() - pointRight.getX()) / 2, !hadToSwitch ? pointLeft.getY() : pointRight.getY());\n          points[2].setPosition(pointRight.getX() + (pointLeft.getX() - pointRight.getX()) / 2, !hadToSwitch ? pointRight.getY() : pointLeft.getY());\n        } // Render was called but link is not moved but user.\n        // Node is moved and in this case fix coordinates to get 90째 angle.\n        // For loop just for first and last path\n        else if (!this.state.canDrag && points.length > 2) {\n            // Those points and its position only will be moved\n            for (var i = 1; i < points.length; i += points.length - 2) {\n              if (i - 1 === 0) {\n                if (this.props.link.getFirstPathXdirection()) {\n                  points[i].setPosition(points[i].getX(), points[i - 1].getY());\n                } else {\n                  points[i].setPosition(points[i - 1].getX(), points[i].getY());\n                }\n              } else {\n                if (this.props.link.getLastPathXdirection()) {\n                  points[i - 1].setPosition(points[i - 1].getX(), points[i].getY());\n                } else {\n                  points[i - 1].setPosition(points[i].getX(), points[i - 1].getY());\n                }\n              }\n            }\n          } // If there is existing link which has two points add one\n      // NOTE: It doesn't matter if check is for dy or dx\n\n\n      if (points.length === 2 && dy !== 0 && !this.state.canDrag) {\n        this.props.link.addPoint(new PointModel({\n          link: this.props.link,\n          position: new Point(pointLeft.getX(), pointRight.getY())\n        }));\n      }\n\n      var _loop = function _loop(j) {\n        paths.push(_this3.generateLink(LinkWidget.generateLinePath(points[j], points[j + 1]), {\n          'data-linkid': _this3.props.link.getID(),\n          'data-point': j,\n          onMouseDown: function onMouseDown(event) {\n            if (event.button === 0) {\n              _this3.setState({\n                canDrag: true\n              });\n\n              _this3.dragging_index = j; // Register mouse move event to track mouse position\n              // On mouse up these events are unregistered check \"this.handleUp\"\n\n              window.addEventListener('mousemove', _this3.handleMove);\n              window.addEventListener('mouseup', _this3.handleUp);\n            }\n          },\n          onMouseEnter: function onMouseEnter(event) {\n            _this3.setState({\n              selected: true\n            });\n\n            _this3.props.link.lastHoverIndexOfPath = j;\n          }\n        }, j));\n      };\n\n      for (var j = 0; j < points.length - 1; j++) {\n        _loop(j);\n      }\n\n      this.refPaths = [];\n      return /*#__PURE__*/_jsxDEV(\"g\", {\n        \"data-default-link-test\": this.props.link.getOptions().testName,\n        children: paths\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 303,\n        columnNumber: 12\n      }, this);\n    }\n  }]);\n\n  return RightAngleLinkWidget;\n}(React.Component);\n\n_defineProperty(RightAngleLinkWidget, \"defaultProps\", {\n  color: 'red',\n  width: 3,\n  link: null,\n  smooth: false,\n  diagramEngine: null,\n  factory: null\n});","map":{"version":3,"sources":["/home/tuanquang/admin_ssr/src/components/Test/CustomLinkWidget.tsx"],"names":["React","LinkWidget","PointModel","DefaultLinkSegmentWidget","Point","RightAngleLinkWidget","props","event","draggingEvent","dragging_index","bind","setState","canDrag","selected","window","removeEventListener","handleMove","handleUp","refPaths","state","link","setRenderedPaths","map","ref","current","path","extraProps","id","createRef","push","diagramEngine","getFactoryForLink","points","index","coordinate","point","position","getX","getY","addPoint","length","_points","getPosition","Math","abs","getRelativeMousePoint","setPosition","remove","getPoints","dx","dy","calculatePositions","setFirstAndLastPathsDirection","paths","pointLeft","pointRight","hadToSwitch","getTargetPort","Array","forEach","item","setManuallyFirstAndLastPathsDirection","getSourcePort","i","getFirstPathXdirection","getLastPathXdirection","j","generateLink","generateLinePath","getID","onMouseDown","button","addEventListener","onMouseEnter","lastHoverIndexOfPath","getOptions","testName","Component","color","width","smooth","factory"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { DiagramEngine, LinkWidget, PointModel } from '@projectstorm/react-diagrams-core';\nimport { CustomLinkFactory } from './CustomLinkFactory';\nimport { DefaultLinkModel, DefaultLinkSegmentWidget } from '@projectstorm/react-diagrams-defaults';\nimport { Point } from '@projectstorm/geometry';\nimport { MouseEvent } from 'react';\nimport { CustomLinkModel } from './CustomLinkModel';\n\nexport interface RightAngleLinkProps {\n  color?: string;\n  width?: number;\n  smooth?: boolean;\n  link: CustomLinkModel;\n  diagramEngine: DiagramEngine;\n  factory: CustomLinkFactory;\n}\n\nexport interface RightAngleLinkState {\n  selected: boolean;\n  canDrag: boolean;\n}\n\nexport class RightAngleLinkWidget extends React.Component<\n  RightAngleLinkProps,\n  RightAngleLinkState\n> {\n  public static defaultProps: RightAngleLinkProps = {\n    color: 'red',\n    width: 3,\n    link: null,\n    smooth: false,\n    diagramEngine: null,\n    factory: null,\n  };\n\n  refPaths: React.RefObject<SVGPathElement>[];\n\n  // DOM references to the label and paths (if label is given), used to calculate dynamic positioning\n  refLabels: { [id: string]: HTMLElement };\n  dragging_index: number;\n\n  constructor(props: RightAngleLinkProps) {\n    super(props);\n\n    this.refPaths = [];\n    this.state = {\n      selected: false,\n      canDrag: false,\n    };\n\n    this.dragging_index = 0;\n  }\n\n  componentDidUpdate(): void {\n    this.props.link.setRenderedPaths(\n      this.refPaths.map(ref => {\n        return ref.current;\n      })\n    );\n  }\n\n  componentDidMount(): void {\n    this.props.link.setRenderedPaths(\n      this.refPaths.map(ref => {\n        return ref.current;\n      })\n    );\n  }\n\n  componentWillUnmount(): void {\n    this.props.link.setRenderedPaths([]);\n  }\n\n  generateLink(path: string, extraProps: any, id: string | number): JSX.Element {\n    const ref = React.createRef<SVGPathElement>();\n    this.refPaths.push(ref);\n    return (\n      <DefaultLinkSegmentWidget\n        key={`link-${id}`}\n        path={path}\n        selected={this.state.selected}\n        diagramEngine={this.props.diagramEngine}\n        factory={this.props.diagramEngine.getFactoryForLink(this.props.link)}\n        link={this.props.link}\n        forwardRef={ref}\n        onSelection={selected => {\n          this.setState({ selected: selected });\n        }}\n        extras={extraProps}\n      />\n    );\n  }\n\n  calculatePositions(points: PointModel[], event: MouseEvent, index: number, coordinate: string) {\n    // If path is first or last add another point to keep node port on its position\n    if (index === 0) {\n      let point = new PointModel({\n        link: this.props.link,\n        position: new Point(points[index].getX(), points[index].getY()),\n      });\n      this.props.link.addPoint(point, index);\n      this.dragging_index++;\n      return;\n    } else if (index === points.length - 2) {\n      let point = new PointModel({\n        link: this.props.link,\n        position: new Point(points[index + 1].getX(), points[index + 1].getY()),\n      });\n      this.props.link.addPoint(point, index + 1);\n      return;\n    }\n\n    // Merge two points if it is not close to node port and close to each other\n    if (index - 2 > 0) {\n      let _points = {\n        [index - 2]: points[index - 2].getPosition(),\n        [index + 1]: points[index + 1].getPosition(),\n        [index - 1]: points[index - 1].getPosition(),\n      };\n      if (Math.abs(_points[index - 1][coordinate] - _points[index + 1][coordinate]) < 5) {\n        _points[index - 2][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[\n          coordinate\n        ];\n        _points[index + 1][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[\n          coordinate\n        ];\n        points[index - 2].setPosition(_points[index - 2]);\n        points[index + 1].setPosition(_points[index + 1]);\n        points[index - 1].remove();\n        points[index - 1].remove();\n        this.dragging_index--;\n        this.dragging_index--;\n        return;\n      }\n    }\n\n    // Merge two points if it is not close to node port\n    if (index + 2 < points.length - 2) {\n      let _points = {\n        [index + 3]: points[index + 3].getPosition(),\n        [index + 2]: points[index + 2].getPosition(),\n        [index + 1]: points[index + 1].getPosition(),\n        [index]: points[index].getPosition(),\n      };\n      if (Math.abs(_points[index + 1][coordinate] - _points[index + 2][coordinate]) < 5) {\n        _points[index][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[\n          coordinate\n        ];\n        _points[index + 3][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[\n          coordinate\n        ];\n        points[index].setPosition(_points[index]);\n        points[index + 3].setPosition(_points[index + 3]);\n        points[index + 1].remove();\n        points[index + 1].remove();\n        return;\n      }\n    }\n\n    // If no condition above handled then just update path points position\n    let _points = {\n      [index]: points[index].getPosition(),\n      [index + 1]: points[index + 1].getPosition(),\n    };\n    _points[index][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[coordinate];\n    _points[index + 1][coordinate] = this.props.diagramEngine.getRelativeMousePoint(event)[\n      coordinate\n    ];\n    points[index].setPosition(_points[index]);\n    points[index + 1].setPosition(_points[index + 1]);\n  }\n\n  draggingEvent(event: MouseEvent, index: number) {\n    let points = this.props.link.getPoints();\n    // get moving difference. Index + 1 will work because links indexes has\n    // length = points.lenght - 1\n    let dx = Math.abs(points[index].getX() - points[index + 1].getX());\n    let dy = Math.abs(points[index].getY() - points[index + 1].getY());\n\n    // moving with y direction\n    if (dx === 0) {\n      this.calculatePositions(points, event, index, 'x');\n    } else if (dy === 0) {\n      this.calculatePositions(points, event, index, 'y');\n    }\n    this.props.link.setFirstAndLastPathsDirection();\n  }\n\n  handleMove = function(event: MouseEvent) {\n    this.draggingEvent(event, this.dragging_index);\n  }.bind(this);\n\n  handleUp = function(event: MouseEvent) {\n    // Unregister handlers to avoid multiple event handlers for other links\n    this.setState({ canDrag: false, selected: false });\n    window.removeEventListener('mousemove', this.handleMove);\n    window.removeEventListener('mouseup', this.handleUp);\n  }.bind(this);\n\n  render() {\n    //ensure id is present for all points on the path\n    let points = this.props.link.getPoints();\n    let paths = [];\n\n    // Get points based on link orientation\n    let pointLeft = points[0];\n    let pointRight = points[points.length - 1];\n    let hadToSwitch = false;\n    if (pointLeft.getX() > pointRight.getX()) {\n      pointLeft = points[points.length - 1];\n      pointRight = points[0];\n      hadToSwitch = true;\n    }\n    let dy = Math.abs(points[0].getY() - points[points.length - 1].getY());\n\n    // When new link add one middle point to get everywhere 90째 angle\n    if (this.props.link.getTargetPort() === null && points.length === 2) {\n      [...Array(2)].forEach(item => {\n        this.props.link.addPoint(\n          new PointModel({\n            link: this.props.link,\n            position: new Point(pointLeft.getX(), pointRight.getY()),\n          }),\n          1\n        );\n      });\n      this.props.link.setManuallyFirstAndLastPathsDirection(true, true);\n    }\n    // When new link is moving and not connected to target port move with middle point\n    // TODO: @DanielLazarLDAPPS This will be better to update in DragNewLinkState\n    //  in function fireMouseMoved to avoid calling this unexpectedly e.g. after Deserialize\n    else if (this.props.link.getTargetPort() === null && this.props.link.getSourcePort() !== null) {\n      points[1].setPosition(\n        pointRight.getX() + (pointLeft.getX() - pointRight.getX()) / 2,\n        !hadToSwitch ? pointLeft.getY() : pointRight.getY()\n      );\n      points[2].setPosition(\n        pointRight.getX() + (pointLeft.getX() - pointRight.getX()) / 2,\n        !hadToSwitch ? pointRight.getY() : pointLeft.getY()\n      );\n    }\n    // Render was called but link is not moved but user.\n    // Node is moved and in this case fix coordinates to get 90째 angle.\n    // For loop just for first and last path\n    else if (!this.state.canDrag && points.length > 2) {\n      // Those points and its position only will be moved\n      for (let i = 1; i < points.length; i += points.length - 2) {\n        if (i - 1 === 0) {\n          if (this.props.link.getFirstPathXdirection()) {\n            points[i].setPosition(points[i].getX(), points[i - 1].getY());\n          } else {\n            points[i].setPosition(points[i - 1].getX(), points[i].getY());\n          }\n        } else {\n          if (this.props.link.getLastPathXdirection()) {\n            points[i - 1].setPosition(points[i - 1].getX(), points[i].getY());\n          } else {\n            points[i - 1].setPosition(points[i].getX(), points[i - 1].getY());\n          }\n        }\n      }\n    }\n\n    // If there is existing link which has two points add one\n    // NOTE: It doesn't matter if check is for dy or dx\n    if (points.length === 2 && dy !== 0 && !this.state.canDrag) {\n      this.props.link.addPoint(\n        new PointModel({\n          link: this.props.link,\n          position: new Point(pointLeft.getX(), pointRight.getY()),\n        })\n      );\n    }\n\n    for (let j = 0; j < points.length - 1; j++) {\n      paths.push(\n        this.generateLink(\n          LinkWidget.generateLinePath(points[j], points[j + 1]),\n          {\n            'data-linkid': this.props.link.getID(),\n            'data-point': j,\n            onMouseDown: (event: MouseEvent) => {\n              if (event.button === 0) {\n                this.setState({ canDrag: true });\n                this.dragging_index = j;\n                // Register mouse move event to track mouse position\n                // On mouse up these events are unregistered check \"this.handleUp\"\n                window.addEventListener('mousemove', this.handleMove);\n                window.addEventListener('mouseup', this.handleUp);\n              }\n            },\n            onMouseEnter: (event: MouseEvent) => {\n              this.setState({ selected: true });\n              this.props.link.lastHoverIndexOfPath = j;\n            },\n          },\n          j\n        )\n      );\n    }\n\n    this.refPaths = [];\n    return <g data-default-link-test={this.props.link.getOptions().testName}>{paths}</g>;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}