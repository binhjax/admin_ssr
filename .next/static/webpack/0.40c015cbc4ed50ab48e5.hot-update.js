webpackHotUpdate_N_E(0,{

/***/ "./node_modules/ace-builds/src-noconflict/ext-language_tools.js":
/*!**********************************************************************!*\
  !*** ./node_modules/ace-builds/src-noconflict/ext-language_tools.js ***!
  \**********************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

eval("/* WEBPACK VAR INJECTION */(function(module) {ace.define(\"ace/snippets\",[\"require\",\"exports\",\"module\",\"ace/lib/oop\",\"ace/lib/event_emitter\",\"ace/lib/lang\",\"ace/range\",\"ace/range_list\",\"ace/keyboard/hash_handler\",\"ace/tokenizer\",\"ace/clipboard\",\"ace/lib/dom\",\"ace/editor\"], function(require, exports, module) {\n\"use strict\";\nvar oop = require(\"./lib/oop\");\nvar EventEmitter = require(\"./lib/event_emitter\").EventEmitter;\nvar lang = require(\"./lib/lang\");\nvar Range = require(\"./range\").Range;\nvar RangeList = require(\"./range_list\").RangeList;\nvar HashHandler = require(\"./keyboard/hash_handler\").HashHandler;\nvar Tokenizer = require(\"./tokenizer\").Tokenizer;\nvar clipboard = require(\"./clipboard\");\n\nvar VARIABLES = {\n    CURRENT_WORD: function(editor) {\n        return editor.session.getTextRange(editor.session.getWordRange());\n    },\n    SELECTION: function(editor, name, indentation) {\n        var text = editor.session.getTextRange();\n        if (indentation)\n            return text.replace(/\\n\\r?([ \\t]*\\S)/g, \"\\n\" + indentation + \"$1\");\n        return text;\n    },\n    CURRENT_LINE: function(editor) {\n        return editor.session.getLine(editor.getCursorPosition().row);\n    },\n    PREV_LINE: function(editor) {\n        return editor.session.getLine(editor.getCursorPosition().row - 1);\n    },\n    LINE_INDEX: function(editor) {\n        return editor.getCursorPosition().row;\n    },\n    LINE_NUMBER: function(editor) {\n        return editor.getCursorPosition().row + 1;\n    },\n    SOFT_TABS: function(editor) {\n        return editor.session.getUseSoftTabs() ? \"YES\" : \"NO\";\n    },\n    TAB_SIZE: function(editor) {\n        return editor.session.getTabSize();\n    },\n    CLIPBOARD: function(editor) {\n        return clipboard.getText && clipboard.getText();\n    },\n    FILENAME: function(editor) {\n        return /[^/\\\\]*$/.exec(this.FILEPATH(editor))[0];\n    },\n    FILENAME_BASE: function(editor) {\n        return /[^/\\\\]*$/.exec(this.FILEPATH(editor))[0].replace(/\\.[^.]*$/, \"\");\n    },\n    DIRECTORY: function(editor) {\n        return this.FILEPATH(editor).replace(/[^/\\\\]*$/, \"\");\n    },\n    FILEPATH: function(editor) { return \"/not implemented.txt\"; },\n    WORKSPACE_NAME: function() { return \"Unknown\"; },\n    FULLNAME: function() { return \"Unknown\"; },\n    BLOCK_COMMENT_START: function(editor) {\n        var mode = editor.session.$mode || {};\n        return mode.blockComment && mode.blockComment.start || \"\";\n    },\n    BLOCK_COMMENT_END: function(editor) {\n        var mode = editor.session.$mode || {};\n        return mode.blockComment && mode.blockComment.end || \"\";\n    },\n    LINE_COMMENT: function(editor) {\n        var mode = editor.session.$mode || {};\n        return mode.lineCommentStart || \"\";\n    },\n    CURRENT_YEAR: date.bind(null, {year: \"numeric\"}),\n    CURRENT_YEAR_SHORT: date.bind(null, {year: \"2-digit\"}),\n    CURRENT_MONTH: date.bind(null, {month: \"numeric\"}),\n    CURRENT_MONTH_NAME: date.bind(null, {month: \"long\"}),\n    CURRENT_MONTH_NAME_SHORT: date.bind(null, {month: \"short\"}),\n    CURRENT_DATE: date.bind(null, {day: \"2-digit\"}),\n    CURRENT_DAY_NAME: date.bind(null, {weekday: \"long\"}),\n    CURRENT_DAY_NAME_SHORT: date.bind(null, {weekday: \"short\"}),\n    CURRENT_HOUR: date.bind(null, {hour: \"2-digit\", hour12: false}),\n    CURRENT_MINUTE: date.bind(null, {minute: \"2-digit\"}),\n    CURRENT_SECOND: date.bind(null, {second: \"2-digit\"})\n};\n\nVARIABLES.SELECTED_TEXT = VARIABLES.SELECTION;\n\nfunction date(dateFormat) {\n    var str = new Date().toLocaleString(\"en-us\", dateFormat);\n    return str.length == 1 ? \"0\" + str : str;\n}\n\nvar SnippetManager = function() {\n    this.snippetMap = {};\n    this.snippetNameMap = {};\n};\n\n(function() {\n    oop.implement(this, EventEmitter);\n    \n    this.getTokenizer = function() {\n        return SnippetManager.$tokenizer || this.createTokenizer();\n    };\n    \n    this.createTokenizer = function() {\n        function TabstopToken(str) {\n            str = str.substr(1);\n            if (/^\\d+$/.test(str))\n                return [{tabstopId: parseInt(str, 10)}];\n            return [{text: str}];\n        }\n        function escape(ch) {\n            return \"(?:[^\\\\\\\\\" + ch + \"]|\\\\\\\\.)\";\n        }\n        var formatMatcher = {\n            regex: \"/(\" + escape(\"/\") + \"+)/\", \n            onMatch: function(val, state, stack) {\n                var ts = stack[0];\n                ts.fmtString = true;\n                ts.guard = val.slice(1, -1);\n                ts.flag = \"\";\n                return \"\";\n            },\n            next: \"formatString\"\n        };\n        \n        SnippetManager.$tokenizer = new Tokenizer({\n            start: [\n                {regex: /\\\\./, onMatch: function(val, state, stack) {\n                    var ch = val[1];\n                    if (ch == \"}\" && stack.length) {\n                        val = ch;\n                    } else if (\"`$\\\\\".indexOf(ch) != -1) {\n                        val = ch;\n                    }\n                    return [val];\n                }},\n                {regex: /}/, onMatch: function(val, state, stack) {\n                    return [stack.length ? stack.shift() : val];\n                }},\n                {regex: /\\$(?:\\d+|\\w+)/, onMatch: TabstopToken},\n                {regex: /\\$\\{[\\dA-Z_a-z]+/, onMatch: function(str, state, stack) {\n                    var t = TabstopToken(str.substr(1));\n                    stack.unshift(t[0]);\n                    return t;\n                }, next: \"snippetVar\"},\n                {regex: /\\n/, token: \"newline\", merge: false}\n            ],\n            snippetVar: [\n                {regex: \"\\\\|\" + escape(\"\\\\|\") + \"*\\\\|\", onMatch: function(val, state, stack) {\n                    var choices = val.slice(1, -1).replace(/\\\\[,|\\\\]|,/g, function(operator) {\n                        return operator.length == 2 ? operator[1] : \"\\x00\";\n                    }).split(\"\\x00\").map(function(value){\n                        return {value: value};\n                    });\n                    stack[0].choices = choices;\n                    return [choices[0]];\n                }, next: \"start\"},\n                formatMatcher,\n                {regex: \"([^:}\\\\\\\\]|\\\\\\\\.)*:?\", token: \"\", next: \"start\"}\n            ],\n            formatString: [\n                {regex: /:/, onMatch: function(val, state, stack) {\n                    if (stack.length && stack[0].expectElse) {\n                        stack[0].expectElse = false;\n                        stack[0].ifEnd = {elseEnd: stack[0]};\n                        return [stack[0].ifEnd];\n                    }\n                    return \":\";\n                }},\n                {regex: /\\\\./, onMatch: function(val, state, stack) {\n                    var ch = val[1];\n                    if (ch == \"}\" && stack.length)\n                        val = ch;\n                    else if (\"`$\\\\\".indexOf(ch) != -1)\n                        val = ch;\n                    else if (ch == \"n\")\n                        val = \"\\n\";\n                    else if (ch == \"t\")\n                        val = \"\\t\";\n                    else if (\"ulULE\".indexOf(ch) != -1)\n                        val = {changeCase: ch, local: ch > \"a\"};\n                    return [val];\n                }},\n                {regex: \"/\\\\w*}\", onMatch: function(val, state, stack) {\n                    var next = stack.shift();\n                    if (next)\n                        next.flag = val.slice(1, -1);\n                    this.next = next && next.tabstopId ? \"start\" : \"\";\n                    return [next || val];\n                }, next: \"start\"},\n                {regex: /\\$(?:\\d+|\\w+)/, onMatch: function(val, state, stack) {\n                    return [{text: val.slice(1)}];\n                }},\n                {regex: /\\${\\w+/, onMatch: function(val, state, stack) {\n                    var token = {text: val.slice(2)};\n                    stack.unshift(token);\n                    return [token];\n                }, next: \"formatStringVar\"},\n                {regex: /\\n/, token: \"newline\", merge: false},\n                {regex: /}/, onMatch: function(val, state, stack) {\n                    var next = stack.shift();\n                    this.next = next && next.tabstopId ? \"start\" : \"\";\n                    return [next || val];\n                }, next: \"start\"}\n            ],\n            formatStringVar: [\n                {regex: /:\\/\\w+}/, onMatch: function(val, state, stack) {\n                    var ts = stack[0];\n                    ts.formatFunction = val.slice(2, -1);\n                    return [stack.shift()];\n                }, next: \"formatString\"},\n                formatMatcher,\n                {regex: /:[\\?\\-+]?/, onMatch: function(val, state, stack) {\n                    if (val[1] == \"+\")\n                        stack[0].ifEnd = stack[0];\n                    if (val[1] == \"?\")\n                        stack[0].expectElse = true;\n                }, next: \"formatString\"},\n                {regex: \"([^:}\\\\\\\\]|\\\\\\\\.)*:?\", token: \"\", next: \"formatString\"}\n            ]\n        });\n        return SnippetManager.$tokenizer;\n    };\n\n    this.tokenizeTmSnippet = function(str, startState) {\n        return this.getTokenizer().getLineTokens(str, startState).tokens.map(function(x) {\n            return x.value || x;\n        });\n    };\n    \n    this.getVariableValue = function(editor, name, indentation) {\n        if (/^\\d+$/.test(name))\n            return (this.variables.__ || {})[name] || \"\";\n        if (/^[A-Z]\\d+$/.test(name))\n            return (this.variables[name[0] + \"__\"] || {})[name.substr(1)] || \"\";\n        \n        name = name.replace(/^TM_/, \"\");\n        if (!this.variables.hasOwnProperty(name))\n            return \"\";\n        var value = this.variables[name];\n        if (typeof value == \"function\")\n            value = this.variables[name](editor, name, indentation);\n        return value == null ? \"\" : value;\n    };\n    \n    this.variables = VARIABLES;\n    this.tmStrFormat = function(str, ch, editor) {\n        if (!ch.fmt) return str;\n        var flag = ch.flag || \"\";\n        var re = ch.guard;\n        re = new RegExp(re, flag.replace(/[^gim]/g, \"\"));\n        var fmtTokens = typeof ch.fmt == \"string\" ? this.tokenizeTmSnippet(ch.fmt, \"formatString\") : ch.fmt;\n        var _self = this;\n        var formatted = str.replace(re, function() {\n            var oldArgs = _self.variables.__;\n            _self.variables.__ = [].slice.call(arguments);\n            var fmtParts = _self.resolveVariables(fmtTokens, editor);\n            var gChangeCase = \"E\";\n            for (var i  = 0; i < fmtParts.length; i++) {\n                var ch = fmtParts[i];\n                if (typeof ch == \"object\") {\n                    fmtParts[i] = \"\";\n                    if (ch.changeCase && ch.local) {\n                        var next = fmtParts[i + 1];\n                        if (next && typeof next == \"string\") {\n                            if (ch.changeCase == \"u\")\n                                fmtParts[i] = next[0].toUpperCase();\n                            else\n                                fmtParts[i] = next[0].toLowerCase();\n                            fmtParts[i + 1] = next.substr(1);\n                        }\n                    } else if (ch.changeCase) {\n                        gChangeCase = ch.changeCase;\n                    }\n                } else if (gChangeCase == \"U\") {\n                    fmtParts[i] = ch.toUpperCase();\n                } else if (gChangeCase == \"L\") {\n                    fmtParts[i] = ch.toLowerCase();\n                }\n            }\n            _self.variables.__ = oldArgs;\n            return fmtParts.join(\"\");\n        });\n        return formatted;\n    };\n    \n    this.tmFormatFunction = function(str, ch, editor) {\n        if (ch.formatFunction == \"upcase\")\n            return str.toUpperCase();\n        if (ch.formatFunction == \"downcase\")\n            return str.toLowerCase();\n        return str;\n    };\n\n    this.resolveVariables = function(snippet, editor) {\n        var result = [];\n        var indentation = \"\";\n        var afterNewLine = true;\n        for (var i = 0; i < snippet.length; i++) {\n            var ch = snippet[i];\n            if (typeof ch == \"string\") {\n                result.push(ch);\n                if (ch == \"\\n\") {\n                    afterNewLine = true;\n                    indentation = \"\";\n                }\n                else if (afterNewLine) {\n                    indentation = /^\\t*/.exec(ch)[0];\n                    afterNewLine = /\\S/.test(ch);\n                }\n                continue;\n            }\n            if (!ch)  continue;\n            afterNewLine = false;\n            \n            if (ch.fmtString) {\n                var j = snippet.indexOf(ch, i + 1);\n                if (j == -1) j = snippet.length;\n                ch.fmt = snippet.slice(i + 1, j);\n                i = j;\n            }\n            \n            if (ch.text) {\n                var value = this.getVariableValue(editor, ch.text, indentation) + \"\";\n                if (ch.fmtString)\n                    value = this.tmStrFormat(value, ch, editor);\n                if (ch.formatFunction)\n                    value = this.tmFormatFunction(value, ch, editor);\n                \n                if (value && !ch.ifEnd) {\n                    result.push(value);\n                    gotoNext(ch);\n                } else if (!value && ch.ifEnd) {\n                    gotoNext(ch.ifEnd);\n                }\n            } else if (ch.elseEnd) {\n                gotoNext(ch.elseEnd);\n            } else if (ch.tabstopId != null) {\n                result.push(ch);\n            } else if (ch.changeCase != null) {\n                result.push(ch);\n            }\n        }\n        function gotoNext(ch) {\n            var i1 = snippet.indexOf(ch, i + 1);\n            if (i1 != -1)\n                i = i1;\n        }\n        return result;\n    };\n\n    this.insertSnippetForSelection = function(editor, snippetText) {\n        var cursor = editor.getCursorPosition();\n        var line = editor.session.getLine(cursor.row);\n        var tabString = editor.session.getTabString();\n        var indentString = line.match(/^\\s*/)[0];\n        \n        if (cursor.column < indentString.length)\n            indentString = indentString.slice(0, cursor.column);\n\n        snippetText = snippetText.replace(/\\r/g, \"\");\n        var tokens = this.tokenizeTmSnippet(snippetText);\n        tokens = this.resolveVariables(tokens, editor);\n        tokens = tokens.map(function(x) {\n            if (x == \"\\n\")\n                return x + indentString;\n            if (typeof x == \"string\")\n                return x.replace(/\\t/g, tabString);\n            return x;\n        });\n        var tabstops = [];\n        tokens.forEach(function(p, i) {\n            if (typeof p != \"object\")\n                return;\n            var id = p.tabstopId;\n            var ts = tabstops[id];\n            if (!ts) {\n                ts = tabstops[id] = [];\n                ts.index = id;\n                ts.value = \"\";\n                ts.parents = {};\n            }\n            if (ts.indexOf(p) !== -1)\n                return;\n            if (p.choices && !ts.choices)\n                ts.choices = p.choices;\n            ts.push(p);\n            var i1 = tokens.indexOf(p, i + 1);\n            if (i1 === -1)\n                return;\n\n            var value = tokens.slice(i + 1, i1);\n            var isNested = value.some(function(t) {return typeof t === \"object\";});\n            if (isNested && !ts.value) {\n                ts.value = value;\n            } else if (value.length && (!ts.value || typeof ts.value !== \"string\")) {\n                ts.value = value.join(\"\");\n            }\n        });\n        tabstops.forEach(function(ts) {ts.length = 0;});\n        var expanding = {};\n        function copyValue(val) {\n            var copy = [];\n            for (var i = 0; i < val.length; i++) {\n                var p = val[i];\n                if (typeof p == \"object\") {\n                    if (expanding[p.tabstopId])\n                        continue;\n                    var j = val.lastIndexOf(p, i - 1);\n                    p = copy[j] || {tabstopId: p.tabstopId};\n                }\n                copy[i] = p;\n            }\n            return copy;\n        }\n        for (var i = 0; i < tokens.length; i++) {\n            var p = tokens[i];\n            if (typeof p != \"object\")\n                continue;\n            var id = p.tabstopId;\n            var ts = tabstops[id];\n            var i1 = tokens.indexOf(p, i + 1);\n            if (expanding[id]) {\n                if (expanding[id] === p) {\n                    delete expanding[id];\n                    Object.keys(expanding).forEach(function(parentId) {\n                        ts.parents[parentId] = true;\n                    });\n                }\n                continue;\n            }\n            expanding[id] = p;\n            var value = ts.value;\n            if (typeof value !== \"string\")\n                value = copyValue(value);\n            else if (p.fmt)\n                value = this.tmStrFormat(value, p, editor);\n            tokens.splice.apply(tokens, [i + 1, Math.max(0, i1 - i)].concat(value, p));\n\n            if (ts.indexOf(p) === -1)\n                ts.push(p);\n        }\n        var row = 0, column = 0;\n        var text = \"\";\n        tokens.forEach(function(t) {\n            if (typeof t === \"string\") {\n                var lines = t.split(\"\\n\");\n                if (lines.length > 1){\n                    column = lines[lines.length - 1].length;\n                    row += lines.length - 1;\n                } else\n                    column += t.length;\n                text += t;\n            } else if (t) {\n                if (!t.start)\n                    t.start = {row: row, column: column};\n                else\n                    t.end = {row: row, column: column};\n            }\n        });\n        var range = editor.getSelectionRange();\n        var end = editor.session.replace(range, text);\n\n        var tabstopManager = new TabstopManager(editor);\n        var selectionId = editor.inVirtualSelectionMode && editor.selection.index;\n        tabstopManager.addTabstops(tabstops, range.start, end, selectionId);\n    };\n    \n    this.insertSnippet = function(editor, snippetText) {\n        var self = this;\n        if (editor.inVirtualSelectionMode)\n            return self.insertSnippetForSelection(editor, snippetText);\n        \n        editor.forEachSelection(function() {\n            self.insertSnippetForSelection(editor, snippetText);\n        }, null, {keepOrder: true});\n        \n        if (editor.tabstopManager)\n            editor.tabstopManager.tabNext();\n    };\n\n    this.$getScope = function(editor) {\n        var scope = editor.session.$mode.$id || \"\";\n        scope = scope.split(\"/\").pop();\n        if (scope === \"html\" || scope === \"php\") {\n            if (scope === \"php\" && !editor.session.$mode.inlinePhp) \n                scope = \"html\";\n            var c = editor.getCursorPosition();\n            var state = editor.session.getState(c.row);\n            if (typeof state === \"object\") {\n                state = state[0];\n            }\n            if (state.substring) {\n                if (state.substring(0, 3) == \"js-\")\n                    scope = \"javascript\";\n                else if (state.substring(0, 4) == \"css-\")\n                    scope = \"css\";\n                else if (state.substring(0, 4) == \"php-\")\n                    scope = \"php\";\n            }\n        }\n        \n        return scope;\n    };\n\n    this.getActiveScopes = function(editor) {\n        var scope = this.$getScope(editor);\n        var scopes = [scope];\n        var snippetMap = this.snippetMap;\n        if (snippetMap[scope] && snippetMap[scope].includeScopes) {\n            scopes.push.apply(scopes, snippetMap[scope].includeScopes);\n        }\n        scopes.push(\"_\");\n        return scopes;\n    };\n\n    this.expandWithTab = function(editor, options) {\n        var self = this;\n        var result = editor.forEachSelection(function() {\n            return self.expandSnippetForSelection(editor, options);\n        }, null, {keepOrder: true});\n        if (result && editor.tabstopManager)\n            editor.tabstopManager.tabNext();\n        return result;\n    };\n    \n    this.expandSnippetForSelection = function(editor, options) {\n        var cursor = editor.getCursorPosition();\n        var line = editor.session.getLine(cursor.row);\n        var before = line.substring(0, cursor.column);\n        var after = line.substr(cursor.column);\n\n        var snippetMap = this.snippetMap;\n        var snippet;\n        this.getActiveScopes(editor).some(function(scope) {\n            var snippets = snippetMap[scope];\n            if (snippets)\n                snippet = this.findMatchingSnippet(snippets, before, after);\n            return !!snippet;\n        }, this);\n        if (!snippet)\n            return false;\n        if (options && options.dryRun)\n            return true;\n        editor.session.doc.removeInLine(cursor.row,\n            cursor.column - snippet.replaceBefore.length,\n            cursor.column + snippet.replaceAfter.length\n        );\n\n        this.variables.M__ = snippet.matchBefore;\n        this.variables.T__ = snippet.matchAfter;\n        this.insertSnippetForSelection(editor, snippet.content);\n\n        this.variables.M__ = this.variables.T__ = null;\n        return true;\n    };\n\n    this.findMatchingSnippet = function(snippetList, before, after) {\n        for (var i = snippetList.length; i--;) {\n            var s = snippetList[i];\n            if (s.startRe && !s.startRe.test(before))\n                continue;\n            if (s.endRe && !s.endRe.test(after))\n                continue;\n            if (!s.startRe && !s.endRe)\n                continue;\n\n            s.matchBefore = s.startRe ? s.startRe.exec(before) : [\"\"];\n            s.matchAfter = s.endRe ? s.endRe.exec(after) : [\"\"];\n            s.replaceBefore = s.triggerRe ? s.triggerRe.exec(before)[0] : \"\";\n            s.replaceAfter = s.endTriggerRe ? s.endTriggerRe.exec(after)[0] : \"\";\n            return s;\n        }\n    };\n\n    this.snippetMap = {};\n    this.snippetNameMap = {};\n    this.register = function(snippets, scope) {\n        var snippetMap = this.snippetMap;\n        var snippetNameMap = this.snippetNameMap;\n        var self = this;\n        \n        if (!snippets) \n            snippets = [];\n        \n        function wrapRegexp(src) {\n            if (src && !/^\\^?\\(.*\\)\\$?$|^\\\\b$/.test(src))\n                src = \"(?:\" + src + \")\";\n\n            return src || \"\";\n        }\n        function guardedRegexp(re, guard, opening) {\n            re = wrapRegexp(re);\n            guard = wrapRegexp(guard);\n            if (opening) {\n                re = guard + re;\n                if (re && re[re.length - 1] != \"$\")\n                    re = re + \"$\";\n            } else {\n                re = re + guard;\n                if (re && re[0] != \"^\")\n                    re = \"^\" + re;\n            }\n            return new RegExp(re);\n        }\n\n        function addSnippet(s) {\n            if (!s.scope)\n                s.scope = scope || \"_\";\n            scope = s.scope;\n            if (!snippetMap[scope]) {\n                snippetMap[scope] = [];\n                snippetNameMap[scope] = {};\n            }\n\n            var map = snippetNameMap[scope];\n            if (s.name) {\n                var old = map[s.name];\n                if (old)\n                    self.unregister(old);\n                map[s.name] = s;\n            }\n            snippetMap[scope].push(s);\n\n            if (s.prefix)\n                s.tabTrigger = s.prefix;\n\n            if (!s.content && s.body)\n                s.content = Array.isArray(s.body) ? s.body.join(\"\\n\") : s.body;\n\n            if (s.tabTrigger && !s.trigger) {\n                if (!s.guard && /^\\w/.test(s.tabTrigger))\n                    s.guard = \"\\\\b\";\n                s.trigger = lang.escapeRegExp(s.tabTrigger);\n            }\n            \n            if (!s.trigger && !s.guard && !s.endTrigger && !s.endGuard)\n                return;\n            \n            s.startRe = guardedRegexp(s.trigger, s.guard, true);\n            s.triggerRe = new RegExp(s.trigger);\n\n            s.endRe = guardedRegexp(s.endTrigger, s.endGuard, true);\n            s.endTriggerRe = new RegExp(s.endTrigger);\n        }\n\n        if (Array.isArray(snippets)) {\n            snippets.forEach(addSnippet);\n        } else {\n            Object.keys(snippets).forEach(function(key) {\n                addSnippet(snippets[key]);\n            });\n        }\n        \n        this._signal(\"registerSnippets\", {scope: scope});\n    };\n    this.unregister = function(snippets, scope) {\n        var snippetMap = this.snippetMap;\n        var snippetNameMap = this.snippetNameMap;\n\n        function removeSnippet(s) {\n            var nameMap = snippetNameMap[s.scope||scope];\n            if (nameMap && nameMap[s.name]) {\n                delete nameMap[s.name];\n                var map = snippetMap[s.scope||scope];\n                var i = map && map.indexOf(s);\n                if (i >= 0)\n                    map.splice(i, 1);\n            }\n        }\n        if (snippets.content)\n            removeSnippet(snippets);\n        else if (Array.isArray(snippets))\n            snippets.forEach(removeSnippet);\n    };\n    this.parseSnippetFile = function(str) {\n        str = str.replace(/\\r/g, \"\");\n        var list = [], snippet = {};\n        var re = /^#.*|^({[\\s\\S]*})\\s*$|^(\\S+) (.*)$|^((?:\\n*\\t.*)+)/gm;\n        var m;\n        while (m = re.exec(str)) {\n            if (m[1]) {\n                try {\n                    snippet = JSON.parse(m[1]);\n                    list.push(snippet);\n                } catch (e) {}\n            } if (m[4]) {\n                snippet.content = m[4].replace(/^\\t/gm, \"\");\n                list.push(snippet);\n                snippet = {};\n            } else {\n                var key = m[2], val = m[3];\n                if (key == \"regex\") {\n                    var guardRe = /\\/((?:[^\\/\\\\]|\\\\.)*)|$/g;\n                    snippet.guard = guardRe.exec(val)[1];\n                    snippet.trigger = guardRe.exec(val)[1];\n                    snippet.endTrigger = guardRe.exec(val)[1];\n                    snippet.endGuard = guardRe.exec(val)[1];\n                } else if (key == \"snippet\") {\n                    snippet.tabTrigger = val.match(/^\\S*/)[0];\n                    if (!snippet.name)\n                        snippet.name = val;\n                } else if (key) {\n                    snippet[key] = val;\n                }\n            }\n        }\n        return list;\n    };\n    this.getSnippetByName = function(name, editor) {\n        var snippetMap = this.snippetNameMap;\n        var snippet;\n        this.getActiveScopes(editor).some(function(scope) {\n            var snippets = snippetMap[scope];\n            if (snippets)\n                snippet = snippets[name];\n            return !!snippet;\n        }, this);\n        return snippet;\n    };\n\n}).call(SnippetManager.prototype);\n\n\nvar TabstopManager = function(editor) {\n    if (editor.tabstopManager)\n        return editor.tabstopManager;\n    editor.tabstopManager = this;\n    this.$onChange = this.onChange.bind(this);\n    this.$onChangeSelection = lang.delayedCall(this.onChangeSelection.bind(this)).schedule;\n    this.$onChangeSession = this.onChangeSession.bind(this);\n    this.$onAfterExec = this.onAfterExec.bind(this);\n    this.attach(editor);\n};\n(function() {\n    this.attach = function(editor) {\n        this.index = 0;\n        this.ranges = [];\n        this.tabstops = [];\n        this.$openTabstops = null;\n        this.selectedTabstop = null;\n\n        this.editor = editor;\n        this.editor.on(\"change\", this.$onChange);\n        this.editor.on(\"changeSelection\", this.$onChangeSelection);\n        this.editor.on(\"changeSession\", this.$onChangeSession);\n        this.editor.commands.on(\"afterExec\", this.$onAfterExec);\n        this.editor.keyBinding.addKeyboardHandler(this.keyboardHandler);\n    };\n    this.detach = function() {\n        this.tabstops.forEach(this.removeTabstopMarkers, this);\n        this.ranges = null;\n        this.tabstops = null;\n        this.selectedTabstop = null;\n        this.editor.removeListener(\"change\", this.$onChange);\n        this.editor.removeListener(\"changeSelection\", this.$onChangeSelection);\n        this.editor.removeListener(\"changeSession\", this.$onChangeSession);\n        this.editor.commands.removeListener(\"afterExec\", this.$onAfterExec);\n        this.editor.keyBinding.removeKeyboardHandler(this.keyboardHandler);\n        this.editor.tabstopManager = null;\n        this.editor = null;\n    };\n\n    this.onChange = function(delta) {\n        var isRemove = delta.action[0] == \"r\";\n        var selectedTabstop = this.selectedTabstop || {};\n        var parents = selectedTabstop.parents || {};\n        var tabstops = (this.tabstops || []).slice();\n        for (var i = 0; i < tabstops.length; i++) {\n            var ts = tabstops[i];\n            var active = ts == selectedTabstop || parents[ts.index];\n            ts.rangeList.$bias = active ? 0 : 1;\n            \n            if (delta.action == \"remove\" && ts !== selectedTabstop) {\n                var parentActive = ts.parents && ts.parents[selectedTabstop.index];\n                var startIndex = ts.rangeList.pointIndex(delta.start, parentActive);\n                startIndex = startIndex < 0 ? -startIndex - 1 : startIndex + 1;\n                var endIndex = ts.rangeList.pointIndex(delta.end, parentActive);\n                endIndex = endIndex < 0 ? -endIndex - 1 : endIndex - 1;\n                var toRemove = ts.rangeList.ranges.slice(startIndex, endIndex);\n                for (var j = 0; j < toRemove.length; j++)\n                    this.removeRange(toRemove[j]);\n            }\n            ts.rangeList.$onChange(delta);\n        }\n        var session = this.editor.session;\n        if (!this.$inChange && isRemove && session.getLength() == 1 && !session.getValue())\n            this.detach();\n    };\n    this.updateLinkedFields = function() {\n        var ts = this.selectedTabstop;\n        if (!ts || !ts.hasLinkedRanges || !ts.firstNonLinked)\n            return;\n        this.$inChange = true;\n        var session = this.editor.session;\n        var text = session.getTextRange(ts.firstNonLinked);\n        for (var i = 0; i < ts.length; i++) {\n            var range = ts[i];\n            if (!range.linked)\n                continue;\n            var original = range.original;\n            var fmt = exports.snippetManager.tmStrFormat(text, original, this.editor);\n            session.replace(range, fmt);\n        }\n        this.$inChange = false;\n    };\n    this.onAfterExec = function(e) {\n        if (e.command && !e.command.readOnly)\n            this.updateLinkedFields();\n    };\n    this.onChangeSelection = function() {\n        if (!this.editor)\n            return;\n        var lead = this.editor.selection.lead;\n        var anchor = this.editor.selection.anchor;\n        var isEmpty = this.editor.selection.isEmpty();\n        for (var i = 0; i < this.ranges.length; i++) {\n            if (this.ranges[i].linked)\n                continue;\n            var containsLead = this.ranges[i].contains(lead.row, lead.column);\n            var containsAnchor = isEmpty || this.ranges[i].contains(anchor.row, anchor.column);\n            if (containsLead && containsAnchor)\n                return;\n        }\n        this.detach();\n    };\n    this.onChangeSession = function() {\n        this.detach();\n    };\n    this.tabNext = function(dir) {\n        var max = this.tabstops.length;\n        var index = this.index + (dir || 1);\n        index = Math.min(Math.max(index, 1), max);\n        if (index == max)\n            index = 0;\n        this.selectTabstop(index);\n        if (index === 0)\n            this.detach();\n    };\n    this.selectTabstop = function(index) {\n        this.$openTabstops = null;\n        var ts = this.tabstops[this.index];\n        if (ts)\n            this.addTabstopMarkers(ts);\n        this.index = index;\n        ts = this.tabstops[this.index];\n        if (!ts || !ts.length)\n            return;\n        \n        this.selectedTabstop = ts;\n        var range = ts.firstNonLinked || ts;\n        if (ts.choices) range.cursor = range.start;\n        if (!this.editor.inVirtualSelectionMode) {\n            var sel = this.editor.multiSelect;\n            sel.toSingleRange(range);\n            for (var i = 0; i < ts.length; i++) {\n                if (ts.hasLinkedRanges && ts[i].linked)\n                    continue;\n                sel.addRange(ts[i].clone(), true);\n            }\n        } else {\n            this.editor.selection.fromOrientedRange(range);\n        }\n        \n        this.editor.keyBinding.addKeyboardHandler(this.keyboardHandler);\n        if (this.selectedTabstop && this.selectedTabstop.choices)\n            this.editor.execCommand(\"startAutocomplete\", {matches: this.selectedTabstop.choices});\n    };\n    this.addTabstops = function(tabstops, start, end) {\n        var useLink = this.useLink || !this.editor.getOption(\"enableMultiselect\");\n        \n        if (!this.$openTabstops)\n            this.$openTabstops = [];\n        if (!tabstops[0]) {\n            var p = Range.fromPoints(end, end);\n            moveRelative(p.start, start);\n            moveRelative(p.end, start);\n            tabstops[0] = [p];\n            tabstops[0].index = 0;\n        }\n\n        var i = this.index;\n        var arg = [i + 1, 0];\n        var ranges = this.ranges;\n        tabstops.forEach(function(ts, index) {\n            var dest = this.$openTabstops[index] || ts;\n            \n            for (var i = 0; i < ts.length; i++) {\n                var p = ts[i];\n                var range = Range.fromPoints(p.start, p.end || p.start);\n                movePoint(range.start, start);\n                movePoint(range.end, start);\n                range.original = p;\n                range.tabstop = dest;\n                ranges.push(range);\n                if (dest != ts)\n                    dest.unshift(range);\n                else\n                    dest[i] = range;\n                if (p.fmtString || (dest.firstNonLinked && useLink)) {\n                    range.linked = true;\n                    dest.hasLinkedRanges = true;\n                } else if (!dest.firstNonLinked)\n                    dest.firstNonLinked = range;\n            }\n            if (!dest.firstNonLinked)\n                dest.hasLinkedRanges = false;\n            if (dest === ts) {\n                arg.push(dest);\n                this.$openTabstops[index] = dest;\n            }\n            this.addTabstopMarkers(dest);\n            dest.rangeList = dest.rangeList || new RangeList();\n            dest.rangeList.$bias = 0;\n            dest.rangeList.addList(dest);\n        }, this);\n        \n        if (arg.length > 2) {\n            if (this.tabstops.length)\n                arg.push(arg.splice(2, 1)[0]);\n            this.tabstops.splice.apply(this.tabstops, arg);\n        }\n    };\n\n    this.addTabstopMarkers = function(ts) {\n        var session = this.editor.session;\n        ts.forEach(function(range) {\n            if  (!range.markerId)\n                range.markerId = session.addMarker(range, \"ace_snippet-marker\", \"text\");\n        });\n    };\n    this.removeTabstopMarkers = function(ts) {\n        var session = this.editor.session;\n        ts.forEach(function(range) {\n            session.removeMarker(range.markerId);\n            range.markerId = null;\n        });\n    };\n    this.removeRange = function(range) {\n        var i = range.tabstop.indexOf(range);\n        if (i != -1) range.tabstop.splice(i, 1);\n        i = this.ranges.indexOf(range);\n        if (i != -1) this.ranges.splice(i, 1);\n        i = range.tabstop.rangeList.ranges.indexOf(range);\n        if (i != -1) range.tabstop.splice(i, 1);\n        this.editor.session.removeMarker(range.markerId);\n        if (!range.tabstop.length) {\n            i = this.tabstops.indexOf(range.tabstop);\n            if (i != -1)\n                this.tabstops.splice(i, 1);\n            if (!this.tabstops.length)\n                this.detach();\n        }\n    };\n\n    this.keyboardHandler = new HashHandler();\n    this.keyboardHandler.bindKeys({\n        \"Tab\": function(editor) {\n            if (exports.snippetManager && exports.snippetManager.expandWithTab(editor))\n                return;\n            editor.tabstopManager.tabNext(1);\n            editor.renderer.scrollCursorIntoView();\n        },\n        \"Shift-Tab\": function(editor) {\n            editor.tabstopManager.tabNext(-1);\n            editor.renderer.scrollCursorIntoView();\n        },\n        \"Esc\": function(editor) {\n            editor.tabstopManager.detach();\n        }\n    });\n}).call(TabstopManager.prototype);\n\n\n\nvar movePoint = function(point, diff) {\n    if (point.row == 0)\n        point.column += diff.column;\n    point.row += diff.row;\n};\n\nvar moveRelative = function(point, start) {\n    if (point.row == start.row)\n        point.column -= start.column;\n    point.row -= start.row;\n};\n\n\nrequire(\"./lib/dom\").importCssString(\"\\\n.ace_snippet-marker {\\\n    -moz-box-sizing: border-box;\\\n    box-sizing: border-box;\\\n    background: rgba(194, 193, 208, 0.09);\\\n    border: 1px dotted rgba(211, 208, 235, 0.62);\\\n    position: absolute;\\\n}\");\n\nexports.snippetManager = new SnippetManager();\n\n\nvar Editor = require(\"./editor\").Editor;\n(function() {\n    this.insertSnippet = function(content, options) {\n        return exports.snippetManager.insertSnippet(this, content, options);\n    };\n    this.expandSnippet = function(options) {\n        return exports.snippetManager.expandWithTab(this, options);\n    };\n}).call(Editor.prototype);\n\n});\n\nace.define(\"ace/autocomplete/popup\",[\"require\",\"exports\",\"module\",\"ace/virtual_renderer\",\"ace/editor\",\"ace/range\",\"ace/lib/event\",\"ace/lib/lang\",\"ace/lib/dom\"], function(require, exports, module) {\n\"use strict\";\n\nvar Renderer = require(\"../virtual_renderer\").VirtualRenderer;\nvar Editor = require(\"../editor\").Editor;\nvar Range = require(\"../range\").Range;\nvar event = require(\"../lib/event\");\nvar lang = require(\"../lib/lang\");\nvar dom = require(\"../lib/dom\");\n\nvar $singleLineEditor = function(el) {\n    var renderer = new Renderer(el);\n\n    renderer.$maxLines = 4;\n\n    var editor = new Editor(renderer);\n\n    editor.setHighlightActiveLine(false);\n    editor.setShowPrintMargin(false);\n    editor.renderer.setShowGutter(false);\n    editor.renderer.setHighlightGutterLine(false);\n\n    editor.$mouseHandler.$focusTimeout = 0;\n    editor.$highlightTagPending = true;\n\n    return editor;\n};\n\nvar AcePopup = function(parentNode) {\n    var el = dom.createElement(\"div\");\n    var popup = new $singleLineEditor(el);\n\n    if (parentNode)\n        parentNode.appendChild(el);\n    el.style.display = \"none\";\n    popup.renderer.content.style.cursor = \"default\";\n    popup.renderer.setStyle(\"ace_autocomplete\");\n\n    popup.setOption(\"displayIndentGuides\", false);\n    popup.setOption(\"dragDelay\", 150);\n\n    var noop = function(){};\n\n    popup.focus = noop;\n    popup.$isFocused = true;\n\n    popup.renderer.$cursorLayer.restartTimer = noop;\n    popup.renderer.$cursorLayer.element.style.opacity = 0;\n\n    popup.renderer.$maxLines = 8;\n    popup.renderer.$keepTextAreaAtCursor = false;\n\n    popup.setHighlightActiveLine(false);\n    popup.session.highlight(\"\");\n    popup.session.$searchHighlight.clazz = \"ace_highlight-marker\";\n\n    popup.on(\"mousedown\", function(e) {\n        var pos = e.getDocumentPosition();\n        popup.selection.moveToPosition(pos);\n        selectionMarker.start.row = selectionMarker.end.row = pos.row;\n        e.stop();\n    });\n\n    var lastMouseEvent;\n    var hoverMarker = new Range(-1,0,-1,Infinity);\n    var selectionMarker = new Range(-1,0,-1,Infinity);\n    selectionMarker.id = popup.session.addMarker(selectionMarker, \"ace_active-line\", \"fullLine\");\n    popup.setSelectOnHover = function(val) {\n        if (!val) {\n            hoverMarker.id = popup.session.addMarker(hoverMarker, \"ace_line-hover\", \"fullLine\");\n        } else if (hoverMarker.id) {\n            popup.session.removeMarker(hoverMarker.id);\n            hoverMarker.id = null;\n        }\n    };\n    popup.setSelectOnHover(false);\n    popup.on(\"mousemove\", function(e) {\n        if (!lastMouseEvent) {\n            lastMouseEvent = e;\n            return;\n        }\n        if (lastMouseEvent.x == e.x && lastMouseEvent.y == e.y) {\n            return;\n        }\n        lastMouseEvent = e;\n        lastMouseEvent.scrollTop = popup.renderer.scrollTop;\n        var row = lastMouseEvent.getDocumentPosition().row;\n        if (hoverMarker.start.row != row) {\n            if (!hoverMarker.id)\n                popup.setRow(row);\n            setHoverMarker(row);\n        }\n    });\n    popup.renderer.on(\"beforeRender\", function() {\n        if (lastMouseEvent && hoverMarker.start.row != -1) {\n            lastMouseEvent.$pos = null;\n            var row = lastMouseEvent.getDocumentPosition().row;\n            if (!hoverMarker.id)\n                popup.setRow(row);\n            setHoverMarker(row, true);\n        }\n    });\n    popup.renderer.on(\"afterRender\", function() {\n        var row = popup.getRow();\n        var t = popup.renderer.$textLayer;\n        var selected = t.element.childNodes[row - t.config.firstRow];\n        if (selected !== t.selectedNode && t.selectedNode)\n            dom.removeCssClass(t.selectedNode, \"ace_selected\");\n        t.selectedNode = selected;\n        if (selected)\n            dom.addCssClass(selected, \"ace_selected\");\n    });\n    var hideHoverMarker = function() { setHoverMarker(-1); };\n    var setHoverMarker = function(row, suppressRedraw) {\n        if (row !== hoverMarker.start.row) {\n            hoverMarker.start.row = hoverMarker.end.row = row;\n            if (!suppressRedraw)\n                popup.session._emit(\"changeBackMarker\");\n            popup._emit(\"changeHoverMarker\");\n        }\n    };\n    popup.getHoveredRow = function() {\n        return hoverMarker.start.row;\n    };\n\n    event.addListener(popup.container, \"mouseout\", hideHoverMarker);\n    popup.on(\"hide\", hideHoverMarker);\n    popup.on(\"changeSelection\", hideHoverMarker);\n\n    popup.session.doc.getLength = function() {\n        return popup.data.length;\n    };\n    popup.session.doc.getLine = function(i) {\n        var data = popup.data[i];\n        if (typeof data == \"string\")\n            return data;\n        return (data && data.value) || \"\";\n    };\n\n    var bgTokenizer = popup.session.bgTokenizer;\n    bgTokenizer.$tokenizeRow = function(row) {\n        var data = popup.data[row];\n        var tokens = [];\n        if (!data)\n            return tokens;\n        if (typeof data == \"string\")\n            data = {value: data};\n        var caption = data.caption || data.value || data.name;\n\n        function addToken(value, className) {\n            value && tokens.push({\n                type: (data.className || \"\") + (className || \"\"), \n                value: value\n            });\n        }\n        \n        var lower = caption.toLowerCase();\n        var filterText = (popup.filterText || \"\").toLowerCase();\n        var lastIndex = 0;\n        var lastI = 0;\n        for (var i = 0; i <= filterText.length; i++) {\n            if (i != lastI && (data.matchMask & (1 << i) || i == filterText.length)) {\n                var sub = filterText.slice(lastI, i);\n                lastI = i;\n                var index = lower.indexOf(sub, lastIndex);\n                if (index == -1) continue;\n                addToken(caption.slice(lastIndex, index), \"\");\n                lastIndex = index + sub.length;\n                addToken(caption.slice(index, lastIndex), \"completion-highlight\");\n            }\n        }\n        addToken(caption.slice(lastIndex, caption.length), \"\");\n        \n        if (data.meta)\n            tokens.push({type: \"completion-meta\", value: data.meta});\n        if (data.message)\n            tokens.push({type: \"completion-message\", value: data.message});\n\n        return tokens;\n    };\n    bgTokenizer.$updateOnChange = noop;\n    bgTokenizer.start = noop;\n\n    popup.session.$computeWidth = function() {\n        return this.screenWidth = 0;\n    };\n    popup.isOpen = false;\n    popup.isTopdown = false;\n    popup.autoSelect = true;\n    popup.filterText = \"\";\n\n    popup.data = [];\n    popup.setData = function(list, filterText) {\n        popup.filterText = filterText || \"\";\n        popup.setValue(lang.stringRepeat(\"\\n\", list.length), -1);\n        popup.data = list || [];\n        popup.setRow(0);\n    };\n    popup.getData = function(row) {\n        return popup.data[row];\n    };\n\n    popup.getRow = function() {\n        return selectionMarker.start.row;\n    };\n    popup.setRow = function(line) {\n        line = Math.max(this.autoSelect ? 0 : -1, Math.min(this.data.length, line));\n        if (selectionMarker.start.row != line) {\n            popup.selection.clearSelection();\n            selectionMarker.start.row = selectionMarker.end.row = line || 0;\n            popup.session._emit(\"changeBackMarker\");\n            popup.moveCursorTo(line || 0, 0);\n            if (popup.isOpen)\n                popup._signal(\"select\");\n        }\n    };\n\n    popup.on(\"changeSelection\", function() {\n        if (popup.isOpen)\n            popup.setRow(popup.selection.lead.row);\n        popup.renderer.scrollCursorIntoView();\n    });\n\n    popup.hide = function() {\n        this.container.style.display = \"none\";\n        this._signal(\"hide\");\n        popup.isOpen = false;\n    };\n    popup.show = function(pos, lineHeight, topdownOnly) {\n        var el = this.container;\n        var screenHeight = window.innerHeight;\n        var screenWidth = window.innerWidth;\n        var renderer = this.renderer;\n        var maxH = renderer.$maxLines * lineHeight * 1.4;\n        var top = pos.top + this.$borderSize;\n        var allowTopdown = top > screenHeight / 2 && !topdownOnly;\n        if (allowTopdown && top + lineHeight + maxH > screenHeight) {\n            renderer.$maxPixelHeight = top - 2 * this.$borderSize;\n            el.style.top = \"\";\n            el.style.bottom = screenHeight - top + \"px\";\n            popup.isTopdown = false;\n        } else {\n            top += lineHeight;\n            renderer.$maxPixelHeight = screenHeight - top - 0.2 * lineHeight;\n            el.style.top = top + \"px\";\n            el.style.bottom = \"\";\n            popup.isTopdown = true;\n        }\n\n        el.style.display = \"\";\n\n        var left = pos.left;\n        if (left + el.offsetWidth > screenWidth)\n            left = screenWidth - el.offsetWidth;\n\n        el.style.left = left + \"px\";\n\n        this._signal(\"show\");\n        lastMouseEvent = null;\n        popup.isOpen = true;\n    };\n\n    popup.goTo = function(where) {\n        var row = this.getRow();\n        var max = this.session.getLength() - 1;\n\n        switch(where) {\n            case \"up\": row = row <= 0 ? max : row - 1; break;\n            case \"down\": row = row >= max ? -1 : row + 1; break;\n            case \"start\": row = 0; break;\n            case \"end\": row = max; break;\n        }\n\n        this.setRow(row);\n    };\n\n\n    popup.getTextLeftOffset = function() {\n        return this.$borderSize + this.renderer.$padding + this.$imageSize;\n    };\n\n    popup.$imageSize = 0;\n    popup.$borderSize = 1;\n\n    return popup;\n};\n\ndom.importCssString(\"\\\n.ace_editor.ace_autocomplete .ace_marker-layer .ace_active-line {\\\n    background-color: #CAD6FA;\\\n    z-index: 1;\\\n}\\\n.ace_dark.ace_editor.ace_autocomplete .ace_marker-layer .ace_active-line {\\\n    background-color: #3a674e;\\\n}\\\n.ace_editor.ace_autocomplete .ace_line-hover {\\\n    border: 1px solid #abbffe;\\\n    margin-top: -1px;\\\n    background: rgba(233,233,253,0.4);\\\n    position: absolute;\\\n    z-index: 2;\\\n}\\\n.ace_dark.ace_editor.ace_autocomplete .ace_line-hover {\\\n    border: 1px solid rgba(109, 150, 13, 0.8);\\\n    background: rgba(58, 103, 78, 0.62);\\\n}\\\n.ace_completion-meta {\\\n    opacity: 0.5;\\\n    margin: 0.9em;\\\n}\\\n.ace_completion-message {\\\n    color: blue;\\\n}\\\n.ace_editor.ace_autocomplete .ace_completion-highlight{\\\n    color: #2d69c7;\\\n}\\\n.ace_dark.ace_editor.ace_autocomplete .ace_completion-highlight{\\\n    color: #93ca12;\\\n}\\\n.ace_editor.ace_autocomplete {\\\n    width: 300px;\\\n    z-index: 200000;\\\n    border: 1px lightgray solid;\\\n    position: fixed;\\\n    box-shadow: 2px 3px 5px rgba(0,0,0,.2);\\\n    line-height: 1.4;\\\n    background: #fefefe;\\\n    color: #111;\\\n}\\\n.ace_dark.ace_editor.ace_autocomplete {\\\n    border: 1px #484747 solid;\\\n    box-shadow: 2px 3px 5px rgba(0, 0, 0, 0.51);\\\n    line-height: 1.4;\\\n    background: #25282c;\\\n    color: #c1c1c1;\\\n}\", \"autocompletion.css\");\n\nexports.AcePopup = AcePopup;\nexports.$singleLineEditor = $singleLineEditor;\n});\n\nace.define(\"ace/autocomplete/util\",[\"require\",\"exports\",\"module\"], function(require, exports, module) {\n\"use strict\";\n\nexports.parForEach = function(array, fn, callback) {\n    var completed = 0;\n    var arLength = array.length;\n    if (arLength === 0)\n        callback();\n    for (var i = 0; i < arLength; i++) {\n        fn(array[i], function(result, err) {\n            completed++;\n            if (completed === arLength)\n                callback(result, err);\n        });\n    }\n};\n\nvar ID_REGEX = /[a-zA-Z_0-9\\$\\-\\u00A2-\\u2000\\u2070-\\uFFFF]/;\n\nexports.retrievePrecedingIdentifier = function(text, pos, regex) {\n    regex = regex || ID_REGEX;\n    var buf = [];\n    for (var i = pos-1; i >= 0; i--) {\n        if (regex.test(text[i]))\n            buf.push(text[i]);\n        else\n            break;\n    }\n    return buf.reverse().join(\"\");\n};\n\nexports.retrieveFollowingIdentifier = function(text, pos, regex) {\n    regex = regex || ID_REGEX;\n    var buf = [];\n    for (var i = pos; i < text.length; i++) {\n        if (regex.test(text[i]))\n            buf.push(text[i]);\n        else\n            break;\n    }\n    return buf;\n};\n\nexports.getCompletionPrefix = function (editor) {\n    var pos = editor.getCursorPosition();\n    var line = editor.session.getLine(pos.row);\n    var prefix;\n    editor.completers.forEach(function(completer) {\n        if (completer.identifierRegexps) {\n            completer.identifierRegexps.forEach(function(identifierRegex) {\n                if (!prefix && identifierRegex)\n                    prefix = this.retrievePrecedingIdentifier(line, pos.column, identifierRegex);\n            }.bind(this));\n        }\n    }.bind(this));\n    return prefix || this.retrievePrecedingIdentifier(line, pos.column);\n};\n\n});\n\nace.define(\"ace/autocomplete\",[\"require\",\"exports\",\"module\",\"ace/keyboard/hash_handler\",\"ace/autocomplete/popup\",\"ace/autocomplete/util\",\"ace/lib/lang\",\"ace/lib/dom\",\"ace/snippets\",\"ace/config\"], function(require, exports, module) {\n\"use strict\";\n\nvar HashHandler = require(\"./keyboard/hash_handler\").HashHandler;\nvar AcePopup = require(\"./autocomplete/popup\").AcePopup;\nvar util = require(\"./autocomplete/util\");\nvar lang = require(\"./lib/lang\");\nvar dom = require(\"./lib/dom\");\nvar snippetManager = require(\"./snippets\").snippetManager;\nvar config = require(\"./config\");\n\nvar Autocomplete = function() {\n    this.autoInsert = false;\n    this.autoSelect = true;\n    this.exactMatch = false;\n    this.gatherCompletionsId = 0;\n    this.keyboardHandler = new HashHandler();\n    this.keyboardHandler.bindKeys(this.commands);\n\n    this.blurListener = this.blurListener.bind(this);\n    this.changeListener = this.changeListener.bind(this);\n    this.mousedownListener = this.mousedownListener.bind(this);\n    this.mousewheelListener = this.mousewheelListener.bind(this);\n\n    this.changeTimer = lang.delayedCall(function() {\n        this.updateCompletions(true);\n    }.bind(this));\n\n    this.tooltipTimer = lang.delayedCall(this.updateDocTooltip.bind(this), 50);\n};\n\n(function() {\n\n    this.$init = function() {\n        this.popup = new AcePopup(document.body || document.documentElement);\n        this.popup.on(\"click\", function(e) {\n            this.insertMatch();\n            e.stop();\n        }.bind(this));\n        this.popup.focus = this.editor.focus.bind(this.editor);\n        this.popup.on(\"show\", this.tooltipTimer.bind(null, null));\n        this.popup.on(\"select\", this.tooltipTimer.bind(null, null));\n        this.popup.on(\"changeHoverMarker\", this.tooltipTimer.bind(null, null));\n        return this.popup;\n    };\n\n    this.getPopup = function() {\n        return this.popup || this.$init();\n    };\n\n    this.openPopup = function(editor, prefix, keepPopupPosition) {\n        if (!this.popup)\n            this.$init();\n\n        this.popup.autoSelect = this.autoSelect;\n\n        this.popup.setData(this.completions.filtered, this.completions.filterText);\n\n        editor.keyBinding.addKeyboardHandler(this.keyboardHandler);\n        \n        var renderer = editor.renderer;\n        this.popup.setRow(this.autoSelect ? 0 : -1);\n        if (!keepPopupPosition) {\n            this.popup.setTheme(editor.getTheme());\n            this.popup.setFontSize(editor.getFontSize());\n\n            var lineHeight = renderer.layerConfig.lineHeight;\n\n            var pos = renderer.$cursorLayer.getPixelPosition(this.base, true);\n            pos.left -= this.popup.getTextLeftOffset();\n\n            var rect = editor.container.getBoundingClientRect();\n            pos.top += rect.top - renderer.layerConfig.offset;\n            pos.left += rect.left - editor.renderer.scrollLeft;\n            pos.left += renderer.gutterWidth;\n\n            this.popup.show(pos, lineHeight);\n        } else if (keepPopupPosition && !prefix) {\n            this.detach();\n        }\n        this.changeTimer.cancel();\n    };\n\n    this.detach = function() {\n        this.editor.keyBinding.removeKeyboardHandler(this.keyboardHandler);\n        this.editor.off(\"changeSelection\", this.changeListener);\n        this.editor.off(\"blur\", this.blurListener);\n        this.editor.off(\"mousedown\", this.mousedownListener);\n        this.editor.off(\"mousewheel\", this.mousewheelListener);\n        this.changeTimer.cancel();\n        this.hideDocTooltip();\n\n        this.gatherCompletionsId += 1;\n        if (this.popup && this.popup.isOpen)\n            this.popup.hide();\n\n        if (this.base)\n            this.base.detach();\n        this.activated = false;\n        this.completions = this.base = null;\n    };\n\n    this.changeListener = function(e) {\n        var cursor = this.editor.selection.lead;\n        if (cursor.row != this.base.row || cursor.column < this.base.column) {\n            this.detach();\n        }\n        if (this.activated)\n            this.changeTimer.schedule();\n        else\n            this.detach();\n    };\n\n    this.blurListener = function(e) {\n        var el = document.activeElement;\n        var text = this.editor.textInput.getElement();\n        var fromTooltip = e.relatedTarget && this.tooltipNode && this.tooltipNode.contains(e.relatedTarget);\n        var container = this.popup && this.popup.container;\n        if (el != text && el.parentNode != container && !fromTooltip\n            && el != this.tooltipNode && e.relatedTarget != text\n        ) {\n            this.detach();\n        }\n    };\n\n    this.mousedownListener = function(e) {\n        this.detach();\n    };\n\n    this.mousewheelListener = function(e) {\n        this.detach();\n    };\n\n    this.goTo = function(where) {\n        this.popup.goTo(where);\n    };\n\n    this.insertMatch = function(data, options) {\n        if (!data)\n            data = this.popup.getData(this.popup.getRow());\n        if (!data)\n            return false;\n\n        var completions = this.completions;\n        this.editor.startOperation({command: {name: \"insertMatch\"}});\n        if (data.completer && data.completer.insertMatch) {\n            data.completer.insertMatch(this.editor, data);\n        } else {\n            if (completions.filterText) {\n                var ranges = this.editor.selection.getAllRanges();\n                for (var i = 0, range; range = ranges[i]; i++) {\n                    range.start.column -= completions.filterText.length;\n                    this.editor.session.remove(range);\n                }\n            }\n            if (data.snippet)\n                snippetManager.insertSnippet(this.editor, data.snippet);\n            else\n                this.editor.execCommand(\"insertstring\", data.value || data);\n        }\n        if (this.completions == completions)\n            this.detach();\n        this.editor.endOperation();\n    };\n\n\n    this.commands = {\n        \"Up\": function(editor) { editor.completer.goTo(\"up\"); },\n        \"Down\": function(editor) { editor.completer.goTo(\"down\"); },\n        \"Ctrl-Up|Ctrl-Home\": function(editor) { editor.completer.goTo(\"start\"); },\n        \"Ctrl-Down|Ctrl-End\": function(editor) { editor.completer.goTo(\"end\"); },\n\n        \"Esc\": function(editor) { editor.completer.detach(); },\n        \"Return\": function(editor) { return editor.completer.insertMatch(); },\n        \"Shift-Return\": function(editor) { editor.completer.insertMatch(null, {deleteSuffix: true}); },\n        \"Tab\": function(editor) {\n            var result = editor.completer.insertMatch();\n            if (!result && !editor.tabstopManager)\n                editor.completer.goTo(\"down\");\n            else\n                return result;\n        },\n\n        \"PageUp\": function(editor) { editor.completer.popup.gotoPageUp(); },\n        \"PageDown\": function(editor) { editor.completer.popup.gotoPageDown(); }\n    };\n\n    this.gatherCompletions = function(editor, callback) {\n        var session = editor.getSession();\n        var pos = editor.getCursorPosition();\n\n        var prefix = util.getCompletionPrefix(editor);\n\n        this.base = session.doc.createAnchor(pos.row, pos.column - prefix.length);\n        this.base.$insertRight = true;\n\n        var matches = [];\n        var total = editor.completers.length;\n        editor.completers.forEach(function(completer, i) {\n            completer.getCompletions(editor, session, pos, prefix, function(err, results) {\n                if (!err && results)\n                    matches = matches.concat(results);\n                callback(null, {\n                    prefix: util.getCompletionPrefix(editor),\n                    matches: matches,\n                    finished: (--total === 0)\n                });\n            });\n        });\n        return true;\n    };\n\n    this.showPopup = function(editor, options) {\n        if (this.editor)\n            this.detach();\n\n        this.activated = true;\n\n        this.editor = editor;\n        if (editor.completer != this) {\n            if (editor.completer)\n                editor.completer.detach();\n            editor.completer = this;\n        }\n\n        editor.on(\"changeSelection\", this.changeListener);\n        editor.on(\"blur\", this.blurListener);\n        editor.on(\"mousedown\", this.mousedownListener);\n        editor.on(\"mousewheel\", this.mousewheelListener);\n\n        this.updateCompletions(false, options);\n    };\n\n    this.updateCompletions = function(keepPopupPosition, options) {\n        if (keepPopupPosition && this.base && this.completions) {\n            var pos = this.editor.getCursorPosition();\n            var prefix = this.editor.session.getTextRange({start: this.base, end: pos});\n            if (prefix == this.completions.filterText)\n                return;\n            this.completions.setFilter(prefix);\n            if (!this.completions.filtered.length)\n                return this.detach();\n            if (this.completions.filtered.length == 1\n            && this.completions.filtered[0].value == prefix\n            && !this.completions.filtered[0].snippet)\n                return this.detach();\n            this.openPopup(this.editor, prefix, keepPopupPosition);\n            return;\n        }\n        \n        if (options && options.matches) {\n            var pos = this.editor.getSelectionRange().start;\n            this.base = this.editor.session.doc.createAnchor(pos.row, pos.column);\n            this.base.$insertRight = true;\n            this.completions = new FilteredList(options.matches);\n            return this.openPopup(this.editor, \"\", keepPopupPosition);\n        }\n        var _id = this.gatherCompletionsId;\n        this.gatherCompletions(this.editor, function(err, results) {\n            var detachIfFinished = function() {\n                if (!results.finished) return;\n                return this.detach();\n            }.bind(this);\n\n            var prefix = results.prefix;\n            var matches = results && results.matches;\n\n            if (!matches || !matches.length)\n                return detachIfFinished();\n            if (prefix.indexOf(results.prefix) !== 0 || _id != this.gatherCompletionsId)\n                return;\n\n            this.completions = new FilteredList(matches);\n\n            if (this.exactMatch)\n                this.completions.exactMatch = true;\n\n            this.completions.setFilter(prefix);\n            var filtered = this.completions.filtered;\n            if (!filtered.length)\n                return detachIfFinished();\n            if (filtered.length == 1 && filtered[0].value == prefix && !filtered[0].snippet)\n                return detachIfFinished();\n            if (this.autoInsert && filtered.length == 1 && results.finished)\n                return this.insertMatch(filtered[0]);\n\n            this.openPopup(this.editor, prefix, keepPopupPosition);\n        }.bind(this));\n    };\n\n    this.cancelContextMenu = function() {\n        this.editor.$mouseHandler.cancelContextMenu();\n    };\n\n    this.updateDocTooltip = function() {\n        var popup = this.popup;\n        var all = popup.data;\n        var selected = all && (all[popup.getHoveredRow()] || all[popup.getRow()]);\n        var doc = null;\n        if (!selected || !this.editor || !this.popup.isOpen)\n            return this.hideDocTooltip();\n        this.editor.completers.some(function(completer) {\n            if (completer.getDocTooltip)\n                doc = completer.getDocTooltip(selected);\n            return doc;\n        });\n        if (!doc && typeof selected != \"string\")\n            doc = selected;\n\n        if (typeof doc == \"string\")\n            doc = {docText: doc};\n        if (!doc || !(doc.docHTML || doc.docText))\n            return this.hideDocTooltip();\n        this.showDocTooltip(doc);\n    };\n\n    this.showDocTooltip = function(item) {\n        if (!this.tooltipNode) {\n            this.tooltipNode = dom.createElement(\"div\");\n            this.tooltipNode.className = \"ace_tooltip ace_doc-tooltip\";\n            this.tooltipNode.style.margin = 0;\n            this.tooltipNode.style.pointerEvents = \"auto\";\n            this.tooltipNode.tabIndex = -1;\n            this.tooltipNode.onblur = this.blurListener.bind(this);\n            this.tooltipNode.onclick = this.onTooltipClick.bind(this);\n        }\n\n        var tooltipNode = this.tooltipNode;\n        if (item.docHTML) {\n            tooltipNode.innerHTML = item.docHTML;\n        } else if (item.docText) {\n            tooltipNode.textContent = item.docText;\n        }\n\n        if (!tooltipNode.parentNode)\n            document.body.appendChild(tooltipNode);\n        var popup = this.popup;\n        var rect = popup.container.getBoundingClientRect();\n        tooltipNode.style.top = popup.container.style.top;\n        tooltipNode.style.bottom = popup.container.style.bottom;\n\n        tooltipNode.style.display = \"block\";\n        if (window.innerWidth - rect.right < 320) {\n            if (rect.left < 320) {\n                if(popup.isTopdown) {\n                    tooltipNode.style.top = rect.bottom + \"px\";\n                    tooltipNode.style.left = rect.left + \"px\";\n                    tooltipNode.style.right = \"\";\n                    tooltipNode.style.bottom = \"\";\n                } else {\n                    tooltipNode.style.top = popup.container.offsetTop - tooltipNode.offsetHeight + \"px\";\n                    tooltipNode.style.left = rect.left + \"px\";\n                    tooltipNode.style.right = \"\";\n                    tooltipNode.style.bottom = \"\";\n                }\n            } else {\n                tooltipNode.style.right = window.innerWidth - rect.left + \"px\";\n                tooltipNode.style.left = \"\";\n            }\n        } else {\n            tooltipNode.style.left = (rect.right + 1) + \"px\";\n            tooltipNode.style.right = \"\";\n        }\n    };\n\n    this.hideDocTooltip = function() {\n        this.tooltipTimer.cancel();\n        if (!this.tooltipNode) return;\n        var el = this.tooltipNode;\n        if (!this.editor.isFocused() && document.activeElement == el)\n            this.editor.focus();\n        this.tooltipNode = null;\n        if (el.parentNode)\n            el.parentNode.removeChild(el);\n    };\n    \n    this.onTooltipClick = function(e) {\n        var a = e.target;\n        while (a && a != this.tooltipNode) {\n            if (a.nodeName == \"A\" && a.href) {\n                a.rel = \"noreferrer\";\n                a.target = \"_blank\";\n                break;\n            }\n            a = a.parentNode;\n        }\n    };\n\n    this.destroy = function() {\n        this.detach();\n        if (this.popup) {\n            this.popup.destroy();\n            var el = this.popup.container;\n            if (el && el.parentNode)\n                el.parentNode.removeChild(el);\n        }\n        if (this.editor && this.editor.completer == this)\n            this.editor.completer == null;\n        this.popup = null;\n    };\n\n}).call(Autocomplete.prototype);\n\n\nAutocomplete.for = function(editor) {\n    if (editor.completer) {\n        return editor.completer;\n    }\n    if (config.get(\"sharedPopups\")) {\n        if (!Autocomplete.$shared)\n            Autocomplete.$sharedInstance = new Autocomplete();\n        editor.completer = Autocomplete.$sharedInstance;\n    } else {\n        editor.completer = new Autocomplete();\n        editor.once(\"destroy\", function(e, editor) {\n            editor.completer.destroy();\n        });\n    }\n    return editor.completer;\n};\n\nAutocomplete.startCommand = {\n    name: \"startAutocomplete\",\n    exec: function(editor, options) {\n        var completer = Autocomplete.for(editor);\n        completer.autoInsert = false;\n        completer.autoSelect = true;\n        completer.showPopup(editor, options);\n        completer.cancelContextMenu();\n    },\n    bindKey: \"Ctrl-Space|Ctrl-Shift-Space|Alt-Space\"\n};\n\nvar FilteredList = function(array, filterText) {\n    this.all = array;\n    this.filtered = array;\n    this.filterText = filterText || \"\";\n    this.exactMatch = false;\n};\n(function(){\n    this.setFilter = function(str) {\n        if (str.length > this.filterText && str.lastIndexOf(this.filterText, 0) === 0)\n            var matches = this.filtered;\n        else\n            var matches = this.all;\n\n        this.filterText = str;\n        matches = this.filterCompletions(matches, this.filterText);\n        matches = matches.sort(function(a, b) {\n            return b.exactMatch - a.exactMatch || b.$score - a.$score \n                || (a.caption || a.value).localeCompare(b.caption || b.value);\n        });\n        var prev = null;\n        matches = matches.filter(function(item){\n            var caption = item.snippet || item.caption || item.value;\n            if (caption === prev) return false;\n            prev = caption;\n            return true;\n        });\n\n        this.filtered = matches;\n    };\n    this.filterCompletions = function(items, needle) {\n        var results = [];\n        var upper = needle.toUpperCase();\n        var lower = needle.toLowerCase();\n        loop: for (var i = 0, item; item = items[i]; i++) {\n            var caption = item.caption || item.value || item.snippet;\n            if (!caption) continue;\n            var lastIndex = -1;\n            var matchMask = 0;\n            var penalty = 0;\n            var index, distance;\n\n            if (this.exactMatch) {\n                if (needle !== caption.substr(0, needle.length))\n                    continue loop;\n            } else {\n                var fullMatchIndex = caption.toLowerCase().indexOf(lower);\n                if (fullMatchIndex > -1) {\n                    penalty = fullMatchIndex;\n                } else {\n                    for (var j = 0; j < needle.length; j++) {\n                        var i1 = caption.indexOf(lower[j], lastIndex + 1);\n                        var i2 = caption.indexOf(upper[j], lastIndex + 1);\n                        index = (i1 >= 0) ? ((i2 < 0 || i1 < i2) ? i1 : i2) : i2;\n                        if (index < 0)\n                            continue loop;\n                        distance = index - lastIndex - 1;\n                        if (distance > 0) {\n                            if (lastIndex === -1)\n                                penalty += 10;\n                            penalty += distance;\n                            matchMask = matchMask | (1 << j);\n                        }\n                        lastIndex = index;\n                    }\n                }\n            }\n            item.matchMask = matchMask;\n            item.exactMatch = penalty ? 0 : 1;\n            item.$score = (item.score || 0) - penalty;\n            results.push(item);\n        }\n        return results;\n    };\n}).call(FilteredList.prototype);\n\nexports.Autocomplete = Autocomplete;\nexports.FilteredList = FilteredList;\n\n});\n\nace.define(\"ace/autocomplete/text_completer\",[\"require\",\"exports\",\"module\",\"ace/range\"], function(require, exports, module) {\n    var Range = require(\"../range\").Range;\n    \n    var splitRegex = /[^a-zA-Z_0-9\\$\\-\\u00C0-\\u1FFF\\u2C00-\\uD7FF\\w]+/;\n\n    function getWordIndex(doc, pos) {\n        var textBefore = doc.getTextRange(Range.fromPoints({row: 0, column:0}, pos));\n        return textBefore.split(splitRegex).length - 1;\n    }\n    function wordDistance(doc, pos) {\n        var prefixPos = getWordIndex(doc, pos);\n        var words = doc.getValue().split(splitRegex);\n        var wordScores = Object.create(null);\n        \n        var currentWord = words[prefixPos];\n\n        words.forEach(function(word, idx) {\n            if (!word || word === currentWord) return;\n\n            var distance = Math.abs(prefixPos - idx);\n            var score = words.length - distance;\n            if (wordScores[word]) {\n                wordScores[word] = Math.max(score, wordScores[word]);\n            } else {\n                wordScores[word] = score;\n            }\n        });\n        return wordScores;\n    }\n\n    exports.getCompletions = function(editor, session, pos, prefix, callback) {\n        var wordScore = wordDistance(session, pos);\n        var wordList = Object.keys(wordScore);\n        callback(null, wordList.map(function(word) {\n            return {\n                caption: word,\n                value: word,\n                score: wordScore[word],\n                meta: \"local\"\n            };\n        }));\n    };\n});\n\nace.define(\"ace/ext/language_tools\",[\"require\",\"exports\",\"module\",\"ace/snippets\",\"ace/autocomplete\",\"ace/config\",\"ace/lib/lang\",\"ace/autocomplete/util\",\"ace/autocomplete/text_completer\",\"ace/editor\",\"ace/config\"], function(require, exports, module) {\n\"use strict\";\n\nvar snippetManager = require(\"../snippets\").snippetManager;\nvar Autocomplete = require(\"../autocomplete\").Autocomplete;\nvar config = require(\"../config\");\nvar lang = require(\"../lib/lang\");\nvar util = require(\"../autocomplete/util\");\n\nvar textCompleter = require(\"../autocomplete/text_completer\");\nvar keyWordCompleter = {\n    getCompletions: function(editor, session, pos, prefix, callback) {\n        if (session.$mode.completer) {\n            return session.$mode.completer.getCompletions(editor, session, pos, prefix, callback);\n        }\n        var state = editor.session.getState(pos.row);\n        var completions = session.$mode.getCompletions(state, session, pos, prefix);\n        callback(null, completions);\n    }\n};\n\nvar snippetCompleter = {\n    getCompletions: function(editor, session, pos, prefix, callback) {\n        var scopes = [];\n        var token = session.getTokenAt(pos.row, pos.column);\n        if (token && token.type.match(/(tag-name|tag-open|tag-whitespace|attribute-name|attribute-value)\\.xml$/))\n            scopes.push('html-tag');\n        else\n            scopes = snippetManager.getActiveScopes(editor);\n\n        var snippetMap = snippetManager.snippetMap;\n        var completions = [];\n        scopes.forEach(function(scope) {\n            var snippets = snippetMap[scope] || [];\n            for (var i = snippets.length; i--;) {\n                var s = snippets[i];\n                var caption = s.name || s.tabTrigger;\n                if (!caption)\n                    continue;\n                completions.push({\n                    caption: caption,\n                    snippet: s.content,\n                    meta: s.tabTrigger && !s.name ? s.tabTrigger + \"\\u21E5 \" : \"snippet\",\n                    type: \"snippet\"\n                });\n            }\n        }, this);\n        callback(null, completions);\n    },\n    getDocTooltip: function(item) {\n        if (item.type == \"snippet\" && !item.docHTML) {\n            item.docHTML = [\n                \"<b>\", lang.escapeHTML(item.caption), \"</b>\", \"<hr></hr>\",\n                lang.escapeHTML(item.snippet)\n            ].join(\"\");\n        }\n    }\n};\n\nvar completers = [snippetCompleter, textCompleter, keyWordCompleter];\nexports.setCompleters = function(val) {\n    completers.length = 0;\n    if (val) completers.push.apply(completers, val);\n};\nexports.addCompleter = function(completer) {\n    completers.push(completer);\n};\nexports.textCompleter = textCompleter;\nexports.keyWordCompleter = keyWordCompleter;\nexports.snippetCompleter = snippetCompleter;\n\nvar expandSnippet = {\n    name: \"expandSnippet\",\n    exec: function(editor) {\n        return snippetManager.expandWithTab(editor);\n    },\n    bindKey: \"Tab\"\n};\n\nvar onChangeMode = function(e, editor) {\n    loadSnippetsForMode(editor.session.$mode);\n};\n\nvar loadSnippetsForMode = function(mode) {\n    if (typeof mode == \"string\")\n        mode = config.$modes[mode];\n    if (!mode)\n        return;\n    if (!snippetManager.files)\n        snippetManager.files = {};\n    \n    loadSnippetFile(mode.$id, mode.snippetFileId);\n    if (mode.modes)\n        mode.modes.forEach(loadSnippetsForMode);\n};\n\nvar loadSnippetFile = function(id, snippetFilePath) {\n    if (!snippetFilePath || !id || snippetManager.files[id])\n        return;\n    snippetManager.files[id] = {};\n    config.loadModule(snippetFilePath, function(m) {\n        if (!m) return;\n        snippetManager.files[id] = m;\n        if (!m.snippets && m.snippetText)\n            m.snippets = snippetManager.parseSnippetFile(m.snippetText);\n        snippetManager.register(m.snippets || [], m.scope);\n        if (m.includeScopes) {\n            snippetManager.snippetMap[m.scope].includeScopes = m.includeScopes;\n            m.includeScopes.forEach(function(x) {\n                loadSnippetsForMode(\"ace/mode/\" + x);\n            });\n        }\n    });\n};\n\nvar doLiveAutocomplete = function(e) {\n    var editor = e.editor;\n    var hasCompleter = editor.completer && editor.completer.activated;\n    if (e.command.name === \"backspace\") {\n        if (hasCompleter && !util.getCompletionPrefix(editor))\n            editor.completer.detach();\n    }\n    else if (e.command.name === \"insertstring\") {\n        var prefix = util.getCompletionPrefix(editor);\n        if (prefix && !hasCompleter) {\n            var completer = Autocomplete.for(editor);\n            completer.autoInsert = false;\n            completer.showPopup(editor);\n        }\n    }\n};\n\nvar Editor = require(\"../editor\").Editor;\nrequire(\"../config\").defineOptions(Editor.prototype, \"editor\", {\n    enableBasicAutocompletion: {\n        set: function(val) {\n            if (val) {\n                if (!this.completers)\n                    this.completers = Array.isArray(val)? val: completers;\n                this.commands.addCommand(Autocomplete.startCommand);\n            } else {\n                this.commands.removeCommand(Autocomplete.startCommand);\n            }\n        },\n        value: false\n    },\n    enableLiveAutocompletion: {\n        set: function(val) {\n            if (val) {\n                if (!this.completers)\n                    this.completers = Array.isArray(val)? val: completers;\n                this.commands.on('afterExec', doLiveAutocomplete);\n            } else {\n                this.commands.removeListener('afterExec', doLiveAutocomplete);\n            }\n        },\n        value: false\n    },\n    enableSnippets: {\n        set: function(val) {\n            if (val) {\n                this.commands.addCommand(expandSnippet);\n                this.on(\"changeMode\", onChangeMode);\n                onChangeMode(null, this);\n            } else {\n                this.commands.removeCommand(expandSnippet);\n                this.off(\"changeMode\", onChangeMode);\n            }\n        },\n        value: false\n    }\n});\n});                (function() {\n                    ace.require([\"ace/ext/language_tools\"], function(m) {\n                        if ( true && module) {\n                            module.exports = m;\n                        }\n                    });\n                })();\n            \n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../next/dist/compiled/webpack/module.js */ \"./node_modules/next/dist/compiled/webpack/module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2FjZS1idWlsZHMvc3JjLW5vY29uZmxpY3QvZXh0LWxhbmd1YWdlX3Rvb2xzLmpzP2RhNzkiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTCxnQ0FBZ0MsK0JBQStCLEVBQUU7QUFDakUsZ0NBQWdDLGtCQUFrQixFQUFFO0FBQ3BELDBCQUEwQixrQkFBa0IsRUFBRTtBQUM5QztBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxtQ0FBbUMsZ0JBQWdCO0FBQ25ELHlDQUF5QyxnQkFBZ0I7QUFDekQsb0NBQW9DLGlCQUFpQjtBQUNyRCx5Q0FBeUMsY0FBYztBQUN2RCwrQ0FBK0MsZUFBZTtBQUM5RCxtQ0FBbUMsZUFBZTtBQUNsRCx1Q0FBdUMsZ0JBQWdCO0FBQ3ZELDZDQUE2QyxpQkFBaUI7QUFDOUQsbUNBQW1DLCtCQUErQjtBQUNsRSxxQ0FBcUMsa0JBQWtCO0FBQ3ZELHFDQUFxQyxrQkFBa0I7QUFDdkQ7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtB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Q0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUEsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIscUJBQXFCO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixxQkFBcUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGVBQWU7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsd0JBQXdCO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixlQUFlO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBEQUEwRCxzQ0FBc0M7QUFDaEc7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQixlQUFlO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLENBQUM7Ozs7QUFJRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0EscUJBQXFCO0FBQ3JCLGdDQUFnQztBQUNoQywyQkFBMkI7QUFDM0IsMENBQTBDO0FBQzFDLGlEQUFpRDtBQUNqRCx1QkFBdUI7QUFDdkIsQ0FBQzs7QUFFRDs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtB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O0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTs7QUFFYjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsaUJBQWlCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLG1DQUFtQyxtQkFBbUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSw0REFBNEQsaUJBQWlCO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxLQUFLO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDO0FBQ0QsQ0FBQyxFQUFFO0FBQ0g7QUFDQSw0QkFBNEIsS0FBdUQ7QUFDbkY7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUIiLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvYWNlLWJ1aWxkcy9zcmMtbm9jb25mbGljdC9leHQtbGFuZ3VhZ2VfdG9vbHMuanMuanMiLCJzb3VyY2VzQ29udGVudCI6WyJhY2UuZGVmaW5lKFwiYWNlL3NuaXBwZXRzXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvbGliL29vcFwiLFwiYWNlL2xpYi9ldmVudF9lbWl0dGVyXCIsXCJhY2UvbGliL2xhbmdcIixcImFjZS9yYW5nZVwiLFwiYWNlL3JhbmdlX2xpc3RcIixcImFjZS9rZXlib2FyZC9oYXNoX2hhbmRsZXJcIixcImFjZS90b2tlbml6ZXJcIixcImFjZS9jbGlwYm9hcmRcIixcImFjZS9saWIvZG9tXCIsXCJhY2UvZWRpdG9yXCJdLCBmdW5jdGlvbihyZXF1aXJlLCBleHBvcnRzLCBtb2R1bGUpIHtcblwidXNlIHN0cmljdFwiO1xudmFyIG9vcCA9IHJlcXVpcmUoXCIuL2xpYi9vb3BcIik7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZShcIi4vbGliL2V2ZW50X2VtaXR0ZXJcIikuRXZlbnRFbWl0dGVyO1xudmFyIGxhbmcgPSByZXF1aXJlKFwiLi9saWIvbGFuZ1wiKTtcbnZhciBSYW5nZSA9IHJlcXVpcmUoXCIuL3JhbmdlXCIpLlJhbmdlO1xudmFyIFJhbmdlTGlzdCA9IHJlcXVpcmUoXCIuL3JhbmdlX2xpc3RcIikuUmFuZ2VMaXN0O1xudmFyIEhhc2hIYW5kbGVyID0gcmVxdWlyZShcIi4va2V5Ym9hcmQvaGFzaF9oYW5kbGVyXCIpLkhhc2hIYW5kbGVyO1xudmFyIFRva2VuaXplciA9IHJlcXVpcmUoXCIuL3Rva2VuaXplclwiKS5Ub2tlbml6ZXI7XG52YXIgY2xpcGJvYXJkID0gcmVxdWlyZShcIi4vY2xpcGJvYXJkXCIpO1xuXG52YXIgVkFSSUFCTEVTID0ge1xuICAgIENVUlJFTlRfV09SRDogZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgICAgIHJldHVybiBlZGl0b3Iuc2Vzc2lvbi5nZXRUZXh0UmFuZ2UoZWRpdG9yLnNlc3Npb24uZ2V0V29yZFJhbmdlKCkpO1xuICAgIH0sXG4gICAgU0VMRUNUSU9OOiBmdW5jdGlvbihlZGl0b3IsIG5hbWUsIGluZGVudGF0aW9uKSB7XG4gICAgICAgIHZhciB0ZXh0ID0gZWRpdG9yLnNlc3Npb24uZ2V0VGV4dFJhbmdlKCk7XG4gICAgICAgIGlmIChpbmRlbnRhdGlvbilcbiAgICAgICAgICAgIHJldHVybiB0ZXh0LnJlcGxhY2UoL1xcblxccj8oWyBcXHRdKlxcUykvZywgXCJcXG5cIiArIGluZGVudGF0aW9uICsgXCIkMVwiKTtcbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfSxcbiAgICBDVVJSRU5UX0xJTkU6IGZ1bmN0aW9uKGVkaXRvcikge1xuICAgICAgICByZXR1cm4gZWRpdG9yLnNlc3Npb24uZ2V0TGluZShlZGl0b3IuZ2V0Q3Vyc29yUG9zaXRpb24oKS5yb3cpO1xuICAgIH0sXG4gICAgUFJFVl9MSU5FOiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICAgICAgcmV0dXJuIGVkaXRvci5zZXNzaW9uLmdldExpbmUoZWRpdG9yLmdldEN1cnNvclBvc2l0aW9uKCkucm93IC0gMSk7XG4gICAgfSxcbiAgICBMSU5FX0lOREVYOiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICAgICAgcmV0dXJuIGVkaXRvci5nZXRDdXJzb3JQb3NpdGlvbigpLnJvdztcbiAgICB9LFxuICAgIExJTkVfTlVNQkVSOiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICAgICAgcmV0dXJuIGVkaXRvci5nZXRDdXJzb3JQb3NpdGlvbigpLnJvdyArIDE7XG4gICAgfSxcbiAgICBTT0ZUX1RBQlM6IGZ1bmN0aW9uKGVkaXRvcikge1xuICAgICAgICByZXR1cm4gZWRpdG9yLnNlc3Npb24uZ2V0VXNlU29mdFRhYnMoKSA/IFwiWUVTXCIgOiBcIk5PXCI7XG4gICAgfSxcbiAgICBUQUJfU0laRTogZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgICAgIHJldHVybiBlZGl0b3Iuc2Vzc2lvbi5nZXRUYWJTaXplKCk7XG4gICAgfSxcbiAgICBDTElQQk9BUkQ6IGZ1bmN0aW9uKGVkaXRvcikge1xuICAgICAgICByZXR1cm4gY2xpcGJvYXJkLmdldFRleHQgJiYgY2xpcGJvYXJkLmdldFRleHQoKTtcbiAgICB9LFxuICAgIEZJTEVOQU1FOiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICAgICAgcmV0dXJuIC9bXi9cXFxcXSokLy5leGVjKHRoaXMuRklMRVBBVEgoZWRpdG9yKSlbMF07XG4gICAgfSxcbiAgICBGSUxFTkFNRV9CQVNFOiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICAgICAgcmV0dXJuIC9bXi9cXFxcXSokLy5leGVjKHRoaXMuRklMRVBBVEgoZWRpdG9yKSlbMF0ucmVwbGFjZSgvXFwuW14uXSokLywgXCJcIik7XG4gICAgfSxcbiAgICBESVJFQ1RPUlk6IGZ1bmN0aW9uKGVkaXRvcikge1xuICAgICAgICByZXR1cm4gdGhpcy5GSUxFUEFUSChlZGl0b3IpLnJlcGxhY2UoL1teL1xcXFxdKiQvLCBcIlwiKTtcbiAgICB9LFxuICAgIEZJTEVQQVRIOiBmdW5jdGlvbihlZGl0b3IpIHsgcmV0dXJuIFwiL25vdCBpbXBsZW1lbnRlZC50eHRcIjsgfSxcbiAgICBXT1JLU1BBQ0VfTkFNRTogZnVuY3Rpb24oKSB7IHJldHVybiBcIlVua25vd25cIjsgfSxcbiAgICBGVUxMTkFNRTogZnVuY3Rpb24oKSB7IHJldHVybiBcIlVua25vd25cIjsgfSxcbiAgICBCTE9DS19DT01NRU5UX1NUQVJUOiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICAgICAgdmFyIG1vZGUgPSBlZGl0b3Iuc2Vzc2lvbi4kbW9kZSB8fCB7fTtcbiAgICAgICAgcmV0dXJuIG1vZGUuYmxvY2tDb21tZW50ICYmIG1vZGUuYmxvY2tDb21tZW50LnN0YXJ0IHx8IFwiXCI7XG4gICAgfSxcbiAgICBCTE9DS19DT01NRU5UX0VORDogZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgICAgIHZhciBtb2RlID0gZWRpdG9yLnNlc3Npb24uJG1vZGUgfHwge307XG4gICAgICAgIHJldHVybiBtb2RlLmJsb2NrQ29tbWVudCAmJiBtb2RlLmJsb2NrQ29tbWVudC5lbmQgfHwgXCJcIjtcbiAgICB9LFxuICAgIExJTkVfQ09NTUVOVDogZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgICAgIHZhciBtb2RlID0gZWRpdG9yLnNlc3Npb24uJG1vZGUgfHwge307XG4gICAgICAgIHJldHVybiBtb2RlLmxpbmVDb21tZW50U3RhcnQgfHwgXCJcIjtcbiAgICB9LFxuICAgIENVUlJFTlRfWUVBUjogZGF0ZS5iaW5kKG51bGwsIHt5ZWFyOiBcIm51bWVyaWNcIn0pLFxuICAgIENVUlJFTlRfWUVBUl9TSE9SVDogZGF0ZS5iaW5kKG51bGwsIHt5ZWFyOiBcIjItZGlnaXRcIn0pLFxuICAgIENVUlJFTlRfTU9OVEg6IGRhdGUuYmluZChudWxsLCB7bW9udGg6IFwibnVtZXJpY1wifSksXG4gICAgQ1VSUkVOVF9NT05USF9OQU1FOiBkYXRlLmJpbmQobnVsbCwge21vbnRoOiBcImxvbmdcIn0pLFxuICAgIENVUlJFTlRfTU9OVEhfTkFNRV9TSE9SVDogZGF0ZS5iaW5kKG51bGwsIHttb250aDogXCJzaG9ydFwifSksXG4gICAgQ1VSUkVOVF9EQVRFOiBkYXRlLmJpbmQobnVsbCwge2RheTogXCIyLWRpZ2l0XCJ9KSxcbiAgICBDVVJSRU5UX0RBWV9OQU1FOiBkYXRlLmJpbmQobnVsbCwge3dlZWtkYXk6IFwibG9uZ1wifSksXG4gICAgQ1VSUkVOVF9EQVlfTkFNRV9TSE9SVDogZGF0ZS5iaW5kKG51bGwsIHt3ZWVrZGF5OiBcInNob3J0XCJ9KSxcbiAgICBDVVJSRU5UX0hPVVI6IGRhdGUuYmluZChudWxsLCB7aG91cjogXCIyLWRpZ2l0XCIsIGhvdXIxMjogZmFsc2V9KSxcbiAgICBDVVJSRU5UX01JTlVURTogZGF0ZS5iaW5kKG51bGwsIHttaW51dGU6IFwiMi1kaWdpdFwifSksXG4gICAgQ1VSUkVOVF9TRUNPTkQ6IGRhdGUuYmluZChudWxsLCB7c2Vjb25kOiBcIjItZGlnaXRcIn0pXG59O1xuXG5WQVJJQUJMRVMuU0VMRUNURURfVEVYVCA9IFZBUklBQkxFUy5TRUxFQ1RJT047XG5cbmZ1bmN0aW9uIGRhdGUoZGF0ZUZvcm1hdCkge1xuICAgIHZhciBzdHIgPSBuZXcgRGF0ZSgpLnRvTG9jYWxlU3RyaW5nKFwiZW4tdXNcIiwgZGF0ZUZvcm1hdCk7XG4gICAgcmV0dXJuIHN0ci5sZW5ndGggPT0gMSA/IFwiMFwiICsgc3RyIDogc3RyO1xufVxuXG52YXIgU25pcHBldE1hbmFnZXIgPSBmdW5jdGlvbigpIHtcbiAgICB0aGlzLnNuaXBwZXRNYXAgPSB7fTtcbiAgICB0aGlzLnNuaXBwZXROYW1lTWFwID0ge307XG59O1xuXG4oZnVuY3Rpb24oKSB7XG4gICAgb29wLmltcGxlbWVudCh0aGlzLCBFdmVudEVtaXR0ZXIpO1xuICAgIFxuICAgIHRoaXMuZ2V0VG9rZW5pemVyID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiBTbmlwcGV0TWFuYWdlci4kdG9rZW5pemVyIHx8IHRoaXMuY3JlYXRlVG9rZW5pemVyKCk7XG4gICAgfTtcbiAgICBcbiAgICB0aGlzLmNyZWF0ZVRva2VuaXplciA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiBUYWJzdG9wVG9rZW4oc3RyKSB7XG4gICAgICAgICAgICBzdHIgPSBzdHIuc3Vic3RyKDEpO1xuICAgICAgICAgICAgaWYgKC9eXFxkKyQvLnRlc3Qoc3RyKSlcbiAgICAgICAgICAgICAgICByZXR1cm4gW3t0YWJzdG9wSWQ6IHBhcnNlSW50KHN0ciwgMTApfV07XG4gICAgICAgICAgICByZXR1cm4gW3t0ZXh0OiBzdHJ9XTtcbiAgICAgICAgfVxuICAgICAgICBmdW5jdGlvbiBlc2NhcGUoY2gpIHtcbiAgICAgICAgICAgIHJldHVybiBcIig/OlteXFxcXFxcXFxcIiArIGNoICsgXCJdfFxcXFxcXFxcLilcIjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZm9ybWF0TWF0Y2hlciA9IHtcbiAgICAgICAgICAgIHJlZ2V4OiBcIi8oXCIgKyBlc2NhcGUoXCIvXCIpICsgXCIrKS9cIiwgXG4gICAgICAgICAgICBvbk1hdGNoOiBmdW5jdGlvbih2YWwsIHN0YXRlLCBzdGFjaykge1xuICAgICAgICAgICAgICAgIHZhciB0cyA9IHN0YWNrWzBdO1xuICAgICAgICAgICAgICAgIHRzLmZtdFN0cmluZyA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHMuZ3VhcmQgPSB2YWwuc2xpY2UoMSwgLTEpO1xuICAgICAgICAgICAgICAgIHRzLmZsYWcgPSBcIlwiO1xuICAgICAgICAgICAgICAgIHJldHVybiBcIlwiO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5leHQ6IFwiZm9ybWF0U3RyaW5nXCJcbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIFNuaXBwZXRNYW5hZ2VyLiR0b2tlbml6ZXIgPSBuZXcgVG9rZW5pemVyKHtcbiAgICAgICAgICAgIHN0YXJ0OiBbXG4gICAgICAgICAgICAgICAge3JlZ2V4OiAvXFxcXC4vLCBvbk1hdGNoOiBmdW5jdGlvbih2YWwsIHN0YXRlLCBzdGFjaykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY2ggPSB2YWxbMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PSBcIn1cIiAmJiBzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IGNoO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFwiYCRcXFxcXCIuaW5kZXhPZihjaCkgIT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IGNoO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbdmFsXTtcbiAgICAgICAgICAgICAgICB9fSxcbiAgICAgICAgICAgICAgICB7cmVnZXg6IC99Lywgb25NYXRjaDogZnVuY3Rpb24odmFsLCBzdGF0ZSwgc3RhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFtzdGFjay5sZW5ndGggPyBzdGFjay5zaGlmdCgpIDogdmFsXTtcbiAgICAgICAgICAgICAgICB9fSxcbiAgICAgICAgICAgICAgICB7cmVnZXg6IC9cXCQoPzpcXGQrfFxcdyspLywgb25NYXRjaDogVGFic3RvcFRva2VufSxcbiAgICAgICAgICAgICAgICB7cmVnZXg6IC9cXCRcXHtbXFxkQS1aX2Etel0rLywgb25NYXRjaDogZnVuY3Rpb24oc3RyLCBzdGF0ZSwgc3RhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBUYWJzdG9wVG9rZW4oc3RyLnN1YnN0cigxKSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnVuc2hpZnQodFswXSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0O1xuICAgICAgICAgICAgICAgIH0sIG5leHQ6IFwic25pcHBldFZhclwifSxcbiAgICAgICAgICAgICAgICB7cmVnZXg6IC9cXG4vLCB0b2tlbjogXCJuZXdsaW5lXCIsIG1lcmdlOiBmYWxzZX1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBzbmlwcGV0VmFyOiBbXG4gICAgICAgICAgICAgICAge3JlZ2V4OiBcIlxcXFx8XCIgKyBlc2NhcGUoXCJcXFxcfFwiKSArIFwiKlxcXFx8XCIsIG9uTWF0Y2g6IGZ1bmN0aW9uKHZhbCwgc3RhdGUsIHN0YWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaG9pY2VzID0gdmFsLnNsaWNlKDEsIC0xKS5yZXBsYWNlKC9cXFxcWyx8XFxcXF18LC9nLCBmdW5jdGlvbihvcGVyYXRvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9wZXJhdG9yLmxlbmd0aCA9PSAyID8gb3BlcmF0b3JbMV0gOiBcIlxceDAwXCI7XG4gICAgICAgICAgICAgICAgICAgIH0pLnNwbGl0KFwiXFx4MDBcIikubWFwKGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7dmFsdWU6IHZhbHVlfTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrWzBdLmNob2ljZXMgPSBjaG9pY2VzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW2Nob2ljZXNbMF1dO1xuICAgICAgICAgICAgICAgIH0sIG5leHQ6IFwic3RhcnRcIn0sXG4gICAgICAgICAgICAgICAgZm9ybWF0TWF0Y2hlcixcbiAgICAgICAgICAgICAgICB7cmVnZXg6IFwiKFteOn1cXFxcXFxcXF18XFxcXFxcXFwuKSo6P1wiLCB0b2tlbjogXCJcIiwgbmV4dDogXCJzdGFydFwifVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIGZvcm1hdFN0cmluZzogW1xuICAgICAgICAgICAgICAgIHtyZWdleDogLzovLCBvbk1hdGNoOiBmdW5jdGlvbih2YWwsIHN0YXRlLCBzdGFjaykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RhY2subGVuZ3RoICYmIHN0YWNrWzBdLmV4cGVjdEVsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrWzBdLmV4cGVjdEVsc2UgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrWzBdLmlmRW5kID0ge2Vsc2VFbmQ6IHN0YWNrWzBdfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbc3RhY2tbMF0uaWZFbmRdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcIjpcIjtcbiAgICAgICAgICAgICAgICB9fSxcbiAgICAgICAgICAgICAgICB7cmVnZXg6IC9cXFxcLi8sIG9uTWF0Y2g6IGZ1bmN0aW9uKHZhbCwgc3RhdGUsIHN0YWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBjaCA9IHZhbFsxXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09IFwifVwiICYmIHN0YWNrLmxlbmd0aClcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IGNoO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChcImAkXFxcXFwiLmluZGV4T2YoY2gpICE9IC0xKVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gY2g7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoID09IFwiblwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gXCJcXG5cIjtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2ggPT0gXCJ0XCIpXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBcIlxcdFwiO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChcInVsVUxFXCIuaW5kZXhPZihjaCkgIT0gLTEpXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSB7Y2hhbmdlQ2FzZTogY2gsIGxvY2FsOiBjaCA+IFwiYVwifTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFt2YWxdO1xuICAgICAgICAgICAgICAgIH19LFxuICAgICAgICAgICAgICAgIHtyZWdleDogXCIvXFxcXHcqfVwiLCBvbk1hdGNoOiBmdW5jdGlvbih2YWwsIHN0YXRlLCBzdGFjaykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbmV4dCA9IHN0YWNrLnNoaWZ0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXh0KVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV4dC5mbGFnID0gdmFsLnNsaWNlKDEsIC0xKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0ID0gbmV4dCAmJiBuZXh0LnRhYnN0b3BJZCA/IFwic3RhcnRcIiA6IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbbmV4dCB8fCB2YWxdO1xuICAgICAgICAgICAgICAgIH0sIG5leHQ6IFwic3RhcnRcIn0sXG4gICAgICAgICAgICAgICAge3JlZ2V4OiAvXFwkKD86XFxkK3xcXHcrKS8sIG9uTWF0Y2g6IGZ1bmN0aW9uKHZhbCwgc3RhdGUsIHN0YWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbe3RleHQ6IHZhbC5zbGljZSgxKX1dO1xuICAgICAgICAgICAgICAgIH19LFxuICAgICAgICAgICAgICAgIHtyZWdleDogL1xcJHtcXHcrLywgb25NYXRjaDogZnVuY3Rpb24odmFsLCBzdGF0ZSwgc3RhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRva2VuID0ge3RleHQ6IHZhbC5zbGljZSgyKX07XG4gICAgICAgICAgICAgICAgICAgIHN0YWNrLnVuc2hpZnQodG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3Rva2VuXTtcbiAgICAgICAgICAgICAgICB9LCBuZXh0OiBcImZvcm1hdFN0cmluZ1ZhclwifSxcbiAgICAgICAgICAgICAgICB7cmVnZXg6IC9cXG4vLCB0b2tlbjogXCJuZXdsaW5lXCIsIG1lcmdlOiBmYWxzZX0sXG4gICAgICAgICAgICAgICAge3JlZ2V4OiAvfS8sIG9uTWF0Y2g6IGZ1bmN0aW9uKHZhbCwgc3RhdGUsIHN0YWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gc3RhY2suc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uZXh0ID0gbmV4dCAmJiBuZXh0LnRhYnN0b3BJZCA/IFwic3RhcnRcIiA6IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbbmV4dCB8fCB2YWxdO1xuICAgICAgICAgICAgICAgIH0sIG5leHQ6IFwic3RhcnRcIn1cbiAgICAgICAgICAgIF0sXG4gICAgICAgICAgICBmb3JtYXRTdHJpbmdWYXI6IFtcbiAgICAgICAgICAgICAgICB7cmVnZXg6IC86XFwvXFx3K30vLCBvbk1hdGNoOiBmdW5jdGlvbih2YWwsIHN0YXRlLCBzdGFjaykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHMgPSBzdGFja1swXTtcbiAgICAgICAgICAgICAgICAgICAgdHMuZm9ybWF0RnVuY3Rpb24gPSB2YWwuc2xpY2UoMiwgLTEpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW3N0YWNrLnNoaWZ0KCldO1xuICAgICAgICAgICAgICAgIH0sIG5leHQ6IFwiZm9ybWF0U3RyaW5nXCJ9LFxuICAgICAgICAgICAgICAgIGZvcm1hdE1hdGNoZXIsXG4gICAgICAgICAgICAgICAge3JlZ2V4OiAvOltcXD9cXC0rXT8vLCBvbk1hdGNoOiBmdW5jdGlvbih2YWwsIHN0YXRlLCBzdGFjaykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodmFsWzFdID09IFwiK1wiKVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2tbMF0uaWZFbmQgPSBzdGFja1swXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbFsxXSA9PSBcIj9cIilcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YWNrWzBdLmV4cGVjdEVsc2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0sIG5leHQ6IFwiZm9ybWF0U3RyaW5nXCJ9LFxuICAgICAgICAgICAgICAgIHtyZWdleDogXCIoW146fVxcXFxcXFxcXXxcXFxcXFxcXC4pKjo/XCIsIHRva2VuOiBcIlwiLCBuZXh0OiBcImZvcm1hdFN0cmluZ1wifVxuICAgICAgICAgICAgXVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFNuaXBwZXRNYW5hZ2VyLiR0b2tlbml6ZXI7XG4gICAgfTtcblxuICAgIHRoaXMudG9rZW5pemVUbVNuaXBwZXQgPSBmdW5jdGlvbihzdHIsIHN0YXJ0U3RhdGUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VG9rZW5pemVyKCkuZ2V0TGluZVRva2VucyhzdHIsIHN0YXJ0U3RhdGUpLnRva2Vucy5tYXAoZnVuY3Rpb24oeCkge1xuICAgICAgICAgICAgcmV0dXJuIHgudmFsdWUgfHwgeDtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBcbiAgICB0aGlzLmdldFZhcmlhYmxlVmFsdWUgPSBmdW5jdGlvbihlZGl0b3IsIG5hbWUsIGluZGVudGF0aW9uKSB7XG4gICAgICAgIGlmICgvXlxcZCskLy50ZXN0KG5hbWUpKVxuICAgICAgICAgICAgcmV0dXJuICh0aGlzLnZhcmlhYmxlcy5fXyB8fCB7fSlbbmFtZV0gfHwgXCJcIjtcbiAgICAgICAgaWYgKC9eW0EtWl1cXGQrJC8udGVzdChuYW1lKSlcbiAgICAgICAgICAgIHJldHVybiAodGhpcy52YXJpYWJsZXNbbmFtZVswXSArIFwiX19cIl0gfHwge30pW25hbWUuc3Vic3RyKDEpXSB8fCBcIlwiO1xuICAgICAgICBcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZSgvXlRNXy8sIFwiXCIpO1xuICAgICAgICBpZiAoIXRoaXMudmFyaWFibGVzLmhhc093blByb3BlcnR5KG5hbWUpKVxuICAgICAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFyaWFibGVzW25hbWVdO1xuICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09IFwiZnVuY3Rpb25cIilcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy52YXJpYWJsZXNbbmFtZV0oZWRpdG9yLCBuYW1lLCBpbmRlbnRhdGlvbik7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlO1xuICAgIH07XG4gICAgXG4gICAgdGhpcy52YXJpYWJsZXMgPSBWQVJJQUJMRVM7XG4gICAgdGhpcy50bVN0ckZvcm1hdCA9IGZ1bmN0aW9uKHN0ciwgY2gsIGVkaXRvcikge1xuICAgICAgICBpZiAoIWNoLmZtdCkgcmV0dXJuIHN0cjtcbiAgICAgICAgdmFyIGZsYWcgPSBjaC5mbGFnIHx8IFwiXCI7XG4gICAgICAgIHZhciByZSA9IGNoLmd1YXJkO1xuICAgICAgICByZSA9IG5ldyBSZWdFeHAocmUsIGZsYWcucmVwbGFjZSgvW15naW1dL2csIFwiXCIpKTtcbiAgICAgICAgdmFyIGZtdFRva2VucyA9IHR5cGVvZiBjaC5mbXQgPT0gXCJzdHJpbmdcIiA/IHRoaXMudG9rZW5pemVUbVNuaXBwZXQoY2guZm10LCBcImZvcm1hdFN0cmluZ1wiKSA6IGNoLmZtdDtcbiAgICAgICAgdmFyIF9zZWxmID0gdGhpcztcbiAgICAgICAgdmFyIGZvcm1hdHRlZCA9IHN0ci5yZXBsYWNlKHJlLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHZhciBvbGRBcmdzID0gX3NlbGYudmFyaWFibGVzLl9fO1xuICAgICAgICAgICAgX3NlbGYudmFyaWFibGVzLl9fID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICAgICAgdmFyIGZtdFBhcnRzID0gX3NlbGYucmVzb2x2ZVZhcmlhYmxlcyhmbXRUb2tlbnMsIGVkaXRvcik7XG4gICAgICAgICAgICB2YXIgZ0NoYW5nZUNhc2UgPSBcIkVcIjtcbiAgICAgICAgICAgIGZvciAodmFyIGkgID0gMDsgaSA8IGZtdFBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoID0gZm10UGFydHNbaV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjaCA9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGZtdFBhcnRzW2ldID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoLmNoYW5nZUNhc2UgJiYgY2gubG9jYWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXh0ID0gZm10UGFydHNbaSArIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5leHQgJiYgdHlwZW9mIG5leHQgPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaC5jaGFuZ2VDYXNlID09IFwidVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbXRQYXJ0c1tpXSA9IG5leHRbMF0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZtdFBhcnRzW2ldID0gbmV4dFswXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZtdFBhcnRzW2kgKyAxXSA9IG5leHQuc3Vic3RyKDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNoLmNoYW5nZUNhc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGdDaGFuZ2VDYXNlID0gY2guY2hhbmdlQ2FzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZ0NoYW5nZUNhc2UgPT0gXCJVXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZm10UGFydHNbaV0gPSBjaC50b1VwcGVyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZ0NoYW5nZUNhc2UgPT0gXCJMXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgZm10UGFydHNbaV0gPSBjaC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9zZWxmLnZhcmlhYmxlcy5fXyA9IG9sZEFyZ3M7XG4gICAgICAgICAgICByZXR1cm4gZm10UGFydHMuam9pbihcIlwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmb3JtYXR0ZWQ7XG4gICAgfTtcbiAgICBcbiAgICB0aGlzLnRtRm9ybWF0RnVuY3Rpb24gPSBmdW5jdGlvbihzdHIsIGNoLCBlZGl0b3IpIHtcbiAgICAgICAgaWYgKGNoLmZvcm1hdEZ1bmN0aW9uID09IFwidXBjYXNlXCIpXG4gICAgICAgICAgICByZXR1cm4gc3RyLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIGlmIChjaC5mb3JtYXRGdW5jdGlvbiA9PSBcImRvd25jYXNlXCIpXG4gICAgICAgICAgICByZXR1cm4gc3RyLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgfTtcblxuICAgIHRoaXMucmVzb2x2ZVZhcmlhYmxlcyA9IGZ1bmN0aW9uKHNuaXBwZXQsIGVkaXRvcikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIHZhciBpbmRlbnRhdGlvbiA9IFwiXCI7XG4gICAgICAgIHZhciBhZnRlck5ld0xpbmUgPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNuaXBwZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjaCA9IHNuaXBwZXRbaV07XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNoID09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjaCk7XG4gICAgICAgICAgICAgICAgaWYgKGNoID09IFwiXFxuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgYWZ0ZXJOZXdMaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50YXRpb24gPSBcIlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChhZnRlck5ld0xpbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5kZW50YXRpb24gPSAvXlxcdCovLmV4ZWMoY2gpWzBdO1xuICAgICAgICAgICAgICAgICAgICBhZnRlck5ld0xpbmUgPSAvXFxTLy50ZXN0KGNoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIWNoKSAgY29udGludWU7XG4gICAgICAgICAgICBhZnRlck5ld0xpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGNoLmZtdFN0cmluZykge1xuICAgICAgICAgICAgICAgIHZhciBqID0gc25pcHBldC5pbmRleE9mKGNoLCBpICsgMSk7XG4gICAgICAgICAgICAgICAgaWYgKGogPT0gLTEpIGogPSBzbmlwcGV0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICBjaC5mbXQgPSBzbmlwcGV0LnNsaWNlKGkgKyAxLCBqKTtcbiAgICAgICAgICAgICAgICBpID0gajtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKGNoLnRleHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSB0aGlzLmdldFZhcmlhYmxlVmFsdWUoZWRpdG9yLCBjaC50ZXh0LCBpbmRlbnRhdGlvbikgKyBcIlwiO1xuICAgICAgICAgICAgICAgIGlmIChjaC5mbXRTdHJpbmcpXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdGhpcy50bVN0ckZvcm1hdCh2YWx1ZSwgY2gsIGVkaXRvcik7XG4gICAgICAgICAgICAgICAgaWYgKGNoLmZvcm1hdEZ1bmN0aW9uKVxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMudG1Gb3JtYXRGdW5jdGlvbih2YWx1ZSwgY2gsIGVkaXRvcik7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlICYmICFjaC5pZkVuZCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgIGdvdG9OZXh0KGNoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCF2YWx1ZSAmJiBjaC5pZkVuZCkge1xuICAgICAgICAgICAgICAgICAgICBnb3RvTmV4dChjaC5pZkVuZCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChjaC5lbHNlRW5kKSB7XG4gICAgICAgICAgICAgICAgZ290b05leHQoY2guZWxzZUVuZCk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNoLnRhYnN0b3BJZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goY2gpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjaC5jaGFuZ2VDYXNlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjaCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ290b05leHQoY2gpIHtcbiAgICAgICAgICAgIHZhciBpMSA9IHNuaXBwZXQuaW5kZXhPZihjaCwgaSArIDEpO1xuICAgICAgICAgICAgaWYgKGkxICE9IC0xKVxuICAgICAgICAgICAgICAgIGkgPSBpMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG5cbiAgICB0aGlzLmluc2VydFNuaXBwZXRGb3JTZWxlY3Rpb24gPSBmdW5jdGlvbihlZGl0b3IsIHNuaXBwZXRUZXh0KSB7XG4gICAgICAgIHZhciBjdXJzb3IgPSBlZGl0b3IuZ2V0Q3Vyc29yUG9zaXRpb24oKTtcbiAgICAgICAgdmFyIGxpbmUgPSBlZGl0b3Iuc2Vzc2lvbi5nZXRMaW5lKGN1cnNvci5yb3cpO1xuICAgICAgICB2YXIgdGFiU3RyaW5nID0gZWRpdG9yLnNlc3Npb24uZ2V0VGFiU3RyaW5nKCk7XG4gICAgICAgIHZhciBpbmRlbnRTdHJpbmcgPSBsaW5lLm1hdGNoKC9eXFxzKi8pWzBdO1xuICAgICAgICBcbiAgICAgICAgaWYgKGN1cnNvci5jb2x1bW4gPCBpbmRlbnRTdHJpbmcubGVuZ3RoKVxuICAgICAgICAgICAgaW5kZW50U3RyaW5nID0gaW5kZW50U3RyaW5nLnNsaWNlKDAsIGN1cnNvci5jb2x1bW4pO1xuXG4gICAgICAgIHNuaXBwZXRUZXh0ID0gc25pcHBldFRleHQucmVwbGFjZSgvXFxyL2csIFwiXCIpO1xuICAgICAgICB2YXIgdG9rZW5zID0gdGhpcy50b2tlbml6ZVRtU25pcHBldChzbmlwcGV0VGV4dCk7XG4gICAgICAgIHRva2VucyA9IHRoaXMucmVzb2x2ZVZhcmlhYmxlcyh0b2tlbnMsIGVkaXRvcik7XG4gICAgICAgIHRva2VucyA9IHRva2Vucy5tYXAoZnVuY3Rpb24oeCkge1xuICAgICAgICAgICAgaWYgKHggPT0gXCJcXG5cIilcbiAgICAgICAgICAgICAgICByZXR1cm4geCArIGluZGVudFN0cmluZztcbiAgICAgICAgICAgIGlmICh0eXBlb2YgeCA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgICAgIHJldHVybiB4LnJlcGxhY2UoL1xcdC9nLCB0YWJTdHJpbmcpO1xuICAgICAgICAgICAgcmV0dXJuIHg7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgdGFic3RvcHMgPSBbXTtcbiAgICAgICAgdG9rZW5zLmZvckVhY2goZnVuY3Rpb24ocCwgaSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwICE9IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdmFyIGlkID0gcC50YWJzdG9wSWQ7XG4gICAgICAgICAgICB2YXIgdHMgPSB0YWJzdG9wc1tpZF07XG4gICAgICAgICAgICBpZiAoIXRzKSB7XG4gICAgICAgICAgICAgICAgdHMgPSB0YWJzdG9wc1tpZF0gPSBbXTtcbiAgICAgICAgICAgICAgICB0cy5pbmRleCA9IGlkO1xuICAgICAgICAgICAgICAgIHRzLnZhbHVlID0gXCJcIjtcbiAgICAgICAgICAgICAgICB0cy5wYXJlbnRzID0ge307XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHMuaW5kZXhPZihwKSAhPT0gLTEpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgaWYgKHAuY2hvaWNlcyAmJiAhdHMuY2hvaWNlcylcbiAgICAgICAgICAgICAgICB0cy5jaG9pY2VzID0gcC5jaG9pY2VzO1xuICAgICAgICAgICAgdHMucHVzaChwKTtcbiAgICAgICAgICAgIHZhciBpMSA9IHRva2Vucy5pbmRleE9mKHAsIGkgKyAxKTtcbiAgICAgICAgICAgIGlmIChpMSA9PT0gLTEpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuXG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB0b2tlbnMuc2xpY2UoaSArIDEsIGkxKTtcbiAgICAgICAgICAgIHZhciBpc05lc3RlZCA9IHZhbHVlLnNvbWUoZnVuY3Rpb24odCkge3JldHVybiB0eXBlb2YgdCA9PT0gXCJvYmplY3RcIjt9KTtcbiAgICAgICAgICAgIGlmIChpc05lc3RlZCAmJiAhdHMudmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0cy52YWx1ZSA9IHZhbHVlO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh2YWx1ZS5sZW5ndGggJiYgKCF0cy52YWx1ZSB8fCB0eXBlb2YgdHMudmFsdWUgIT09IFwic3RyaW5nXCIpKSB7XG4gICAgICAgICAgICAgICAgdHMudmFsdWUgPSB2YWx1ZS5qb2luKFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGFic3RvcHMuZm9yRWFjaChmdW5jdGlvbih0cykge3RzLmxlbmd0aCA9IDA7fSk7XG4gICAgICAgIHZhciBleHBhbmRpbmcgPSB7fTtcbiAgICAgICAgZnVuY3Rpb24gY29weVZhbHVlKHZhbCkge1xuICAgICAgICAgICAgdmFyIGNvcHkgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIHAgPSB2YWxbaV07XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBwID09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4cGFuZGluZ1twLnRhYnN0b3BJZF0pXG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGogPSB2YWwubGFzdEluZGV4T2YocCwgaSAtIDEpO1xuICAgICAgICAgICAgICAgICAgICBwID0gY29weVtqXSB8fCB7dGFic3RvcElkOiBwLnRhYnN0b3BJZH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvcHlbaV0gPSBwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvcHk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0b2tlbnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwID0gdG9rZW5zW2ldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwICE9IFwib2JqZWN0XCIpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB2YXIgaWQgPSBwLnRhYnN0b3BJZDtcbiAgICAgICAgICAgIHZhciB0cyA9IHRhYnN0b3BzW2lkXTtcbiAgICAgICAgICAgIHZhciBpMSA9IHRva2Vucy5pbmRleE9mKHAsIGkgKyAxKTtcbiAgICAgICAgICAgIGlmIChleHBhbmRpbmdbaWRdKSB7XG4gICAgICAgICAgICAgICAgaWYgKGV4cGFuZGluZ1tpZF0gPT09IHApIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGV4cGFuZGluZ1tpZF07XG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGV4cGFuZGluZykuZm9yRWFjaChmdW5jdGlvbihwYXJlbnRJZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHMucGFyZW50c1twYXJlbnRJZF0gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBleHBhbmRpbmdbaWRdID0gcDtcbiAgICAgICAgICAgIHZhciB2YWx1ZSA9IHRzLnZhbHVlO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGNvcHlWYWx1ZSh2YWx1ZSk7XG4gICAgICAgICAgICBlbHNlIGlmIChwLmZtdClcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IHRoaXMudG1TdHJGb3JtYXQodmFsdWUsIHAsIGVkaXRvcik7XG4gICAgICAgICAgICB0b2tlbnMuc3BsaWNlLmFwcGx5KHRva2VucywgW2kgKyAxLCBNYXRoLm1heCgwLCBpMSAtIGkpXS5jb25jYXQodmFsdWUsIHApKTtcblxuICAgICAgICAgICAgaWYgKHRzLmluZGV4T2YocCkgPT09IC0xKVxuICAgICAgICAgICAgICAgIHRzLnB1c2gocCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJvdyA9IDAsIGNvbHVtbiA9IDA7XG4gICAgICAgIHZhciB0ZXh0ID0gXCJcIjtcbiAgICAgICAgdG9rZW5zLmZvckVhY2goZnVuY3Rpb24odCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGxpbmVzID0gdC5zcGxpdChcIlxcblwiKTtcbiAgICAgICAgICAgICAgICBpZiAobGluZXMubGVuZ3RoID4gMSl7XG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbiA9IGxpbmVzW2xpbmVzLmxlbmd0aCAtIDFdLmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgcm93ICs9IGxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgfSBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGNvbHVtbiArPSB0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICB0ZXh0ICs9IHQ7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXQuc3RhcnQpXG4gICAgICAgICAgICAgICAgICAgIHQuc3RhcnQgPSB7cm93OiByb3csIGNvbHVtbjogY29sdW1ufTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHQuZW5kID0ge3Jvdzogcm93LCBjb2x1bW46IGNvbHVtbn07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgcmFuZ2UgPSBlZGl0b3IuZ2V0U2VsZWN0aW9uUmFuZ2UoKTtcbiAgICAgICAgdmFyIGVuZCA9IGVkaXRvci5zZXNzaW9uLnJlcGxhY2UocmFuZ2UsIHRleHQpO1xuXG4gICAgICAgIHZhciB0YWJzdG9wTWFuYWdlciA9IG5ldyBUYWJzdG9wTWFuYWdlcihlZGl0b3IpO1xuICAgICAgICB2YXIgc2VsZWN0aW9uSWQgPSBlZGl0b3IuaW5WaXJ0dWFsU2VsZWN0aW9uTW9kZSAmJiBlZGl0b3Iuc2VsZWN0aW9uLmluZGV4O1xuICAgICAgICB0YWJzdG9wTWFuYWdlci5hZGRUYWJzdG9wcyh0YWJzdG9wcywgcmFuZ2Uuc3RhcnQsIGVuZCwgc2VsZWN0aW9uSWQpO1xuICAgIH07XG4gICAgXG4gICAgdGhpcy5pbnNlcnRTbmlwcGV0ID0gZnVuY3Rpb24oZWRpdG9yLCBzbmlwcGV0VGV4dCkge1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIGlmIChlZGl0b3IuaW5WaXJ0dWFsU2VsZWN0aW9uTW9kZSlcbiAgICAgICAgICAgIHJldHVybiBzZWxmLmluc2VydFNuaXBwZXRGb3JTZWxlY3Rpb24oZWRpdG9yLCBzbmlwcGV0VGV4dCk7XG4gICAgICAgIFxuICAgICAgICBlZGl0b3IuZm9yRWFjaFNlbGVjdGlvbihmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHNlbGYuaW5zZXJ0U25pcHBldEZvclNlbGVjdGlvbihlZGl0b3IsIHNuaXBwZXRUZXh0KTtcbiAgICAgICAgfSwgbnVsbCwge2tlZXBPcmRlcjogdHJ1ZX0pO1xuICAgICAgICBcbiAgICAgICAgaWYgKGVkaXRvci50YWJzdG9wTWFuYWdlcilcbiAgICAgICAgICAgIGVkaXRvci50YWJzdG9wTWFuYWdlci50YWJOZXh0KCk7XG4gICAgfTtcblxuICAgIHRoaXMuJGdldFNjb3BlID0gZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgICAgIHZhciBzY29wZSA9IGVkaXRvci5zZXNzaW9uLiRtb2RlLiRpZCB8fCBcIlwiO1xuICAgICAgICBzY29wZSA9IHNjb3BlLnNwbGl0KFwiL1wiKS5wb3AoKTtcbiAgICAgICAgaWYgKHNjb3BlID09PSBcImh0bWxcIiB8fCBzY29wZSA9PT0gXCJwaHBcIikge1xuICAgICAgICAgICAgaWYgKHNjb3BlID09PSBcInBocFwiICYmICFlZGl0b3Iuc2Vzc2lvbi4kbW9kZS5pbmxpbmVQaHApIFxuICAgICAgICAgICAgICAgIHNjb3BlID0gXCJodG1sXCI7XG4gICAgICAgICAgICB2YXIgYyA9IGVkaXRvci5nZXRDdXJzb3JQb3NpdGlvbigpO1xuICAgICAgICAgICAgdmFyIHN0YXRlID0gZWRpdG9yLnNlc3Npb24uZ2V0U3RhdGUoYy5yb3cpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIHN0YXRlID0gc3RhdGVbMF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhdGUuc3Vic3RyaW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN0YXRlLnN1YnN0cmluZygwLCAzKSA9PSBcImpzLVwiKVxuICAgICAgICAgICAgICAgICAgICBzY29wZSA9IFwiamF2YXNjcmlwdFwiO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0YXRlLnN1YnN0cmluZygwLCA0KSA9PSBcImNzcy1cIilcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUgPSBcImNzc1wiO1xuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0YXRlLnN1YnN0cmluZygwLCA0KSA9PSBcInBocC1cIilcbiAgICAgICAgICAgICAgICAgICAgc2NvcGUgPSBcInBocFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gc2NvcGU7XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0QWN0aXZlU2NvcGVzID0gZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgICAgIHZhciBzY29wZSA9IHRoaXMuJGdldFNjb3BlKGVkaXRvcik7XG4gICAgICAgIHZhciBzY29wZXMgPSBbc2NvcGVdO1xuICAgICAgICB2YXIgc25pcHBldE1hcCA9IHRoaXMuc25pcHBldE1hcDtcbiAgICAgICAgaWYgKHNuaXBwZXRNYXBbc2NvcGVdICYmIHNuaXBwZXRNYXBbc2NvcGVdLmluY2x1ZGVTY29wZXMpIHtcbiAgICAgICAgICAgIHNjb3Blcy5wdXNoLmFwcGx5KHNjb3Blcywgc25pcHBldE1hcFtzY29wZV0uaW5jbHVkZVNjb3Blcyk7XG4gICAgICAgIH1cbiAgICAgICAgc2NvcGVzLnB1c2goXCJfXCIpO1xuICAgICAgICByZXR1cm4gc2NvcGVzO1xuICAgIH07XG5cbiAgICB0aGlzLmV4cGFuZFdpdGhUYWIgPSBmdW5jdGlvbihlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgICAgICB2YXIgcmVzdWx0ID0gZWRpdG9yLmZvckVhY2hTZWxlY3Rpb24oZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gc2VsZi5leHBhbmRTbmlwcGV0Rm9yU2VsZWN0aW9uKGVkaXRvciwgb3B0aW9ucyk7XG4gICAgICAgIH0sIG51bGwsIHtrZWVwT3JkZXI6IHRydWV9KTtcbiAgICAgICAgaWYgKHJlc3VsdCAmJiBlZGl0b3IudGFic3RvcE1hbmFnZXIpXG4gICAgICAgICAgICBlZGl0b3IudGFic3RvcE1hbmFnZXIudGFiTmV4dCgpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgXG4gICAgdGhpcy5leHBhbmRTbmlwcGV0Rm9yU2VsZWN0aW9uID0gZnVuY3Rpb24oZWRpdG9yLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBjdXJzb3IgPSBlZGl0b3IuZ2V0Q3Vyc29yUG9zaXRpb24oKTtcbiAgICAgICAgdmFyIGxpbmUgPSBlZGl0b3Iuc2Vzc2lvbi5nZXRMaW5lKGN1cnNvci5yb3cpO1xuICAgICAgICB2YXIgYmVmb3JlID0gbGluZS5zdWJzdHJpbmcoMCwgY3Vyc29yLmNvbHVtbik7XG4gICAgICAgIHZhciBhZnRlciA9IGxpbmUuc3Vic3RyKGN1cnNvci5jb2x1bW4pO1xuXG4gICAgICAgIHZhciBzbmlwcGV0TWFwID0gdGhpcy5zbmlwcGV0TWFwO1xuICAgICAgICB2YXIgc25pcHBldDtcbiAgICAgICAgdGhpcy5nZXRBY3RpdmVTY29wZXMoZWRpdG9yKS5zb21lKGZ1bmN0aW9uKHNjb3BlKSB7XG4gICAgICAgICAgICB2YXIgc25pcHBldHMgPSBzbmlwcGV0TWFwW3Njb3BlXTtcbiAgICAgICAgICAgIGlmIChzbmlwcGV0cylcbiAgICAgICAgICAgICAgICBzbmlwcGV0ID0gdGhpcy5maW5kTWF0Y2hpbmdTbmlwcGV0KHNuaXBwZXRzLCBiZWZvcmUsIGFmdGVyKTtcbiAgICAgICAgICAgIHJldHVybiAhIXNuaXBwZXQ7XG4gICAgICAgIH0sIHRoaXMpO1xuICAgICAgICBpZiAoIXNuaXBwZXQpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZHJ5UnVuKVxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGVkaXRvci5zZXNzaW9uLmRvYy5yZW1vdmVJbkxpbmUoY3Vyc29yLnJvdyxcbiAgICAgICAgICAgIGN1cnNvci5jb2x1bW4gLSBzbmlwcGV0LnJlcGxhY2VCZWZvcmUubGVuZ3RoLFxuICAgICAgICAgICAgY3Vyc29yLmNvbHVtbiArIHNuaXBwZXQucmVwbGFjZUFmdGVyLmxlbmd0aFxuICAgICAgICApO1xuXG4gICAgICAgIHRoaXMudmFyaWFibGVzLk1fXyA9IHNuaXBwZXQubWF0Y2hCZWZvcmU7XG4gICAgICAgIHRoaXMudmFyaWFibGVzLlRfXyA9IHNuaXBwZXQubWF0Y2hBZnRlcjtcbiAgICAgICAgdGhpcy5pbnNlcnRTbmlwcGV0Rm9yU2VsZWN0aW9uKGVkaXRvciwgc25pcHBldC5jb250ZW50KTtcblxuICAgICAgICB0aGlzLnZhcmlhYmxlcy5NX18gPSB0aGlzLnZhcmlhYmxlcy5UX18gPSBudWxsO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuXG4gICAgdGhpcy5maW5kTWF0Y2hpbmdTbmlwcGV0ID0gZnVuY3Rpb24oc25pcHBldExpc3QsIGJlZm9yZSwgYWZ0ZXIpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IHNuaXBwZXRMaXN0Lmxlbmd0aDsgaS0tOykge1xuICAgICAgICAgICAgdmFyIHMgPSBzbmlwcGV0TGlzdFtpXTtcbiAgICAgICAgICAgIGlmIChzLnN0YXJ0UmUgJiYgIXMuc3RhcnRSZS50ZXN0KGJlZm9yZSkpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAocy5lbmRSZSAmJiAhcy5lbmRSZS50ZXN0KGFmdGVyKSlcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmICghcy5zdGFydFJlICYmICFzLmVuZFJlKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuXG4gICAgICAgICAgICBzLm1hdGNoQmVmb3JlID0gcy5zdGFydFJlID8gcy5zdGFydFJlLmV4ZWMoYmVmb3JlKSA6IFtcIlwiXTtcbiAgICAgICAgICAgIHMubWF0Y2hBZnRlciA9IHMuZW5kUmUgPyBzLmVuZFJlLmV4ZWMoYWZ0ZXIpIDogW1wiXCJdO1xuICAgICAgICAgICAgcy5yZXBsYWNlQmVmb3JlID0gcy50cmlnZ2VyUmUgPyBzLnRyaWdnZXJSZS5leGVjKGJlZm9yZSlbMF0gOiBcIlwiO1xuICAgICAgICAgICAgcy5yZXBsYWNlQWZ0ZXIgPSBzLmVuZFRyaWdnZXJSZSA/IHMuZW5kVHJpZ2dlclJlLmV4ZWMoYWZ0ZXIpWzBdIDogXCJcIjtcbiAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuc25pcHBldE1hcCA9IHt9O1xuICAgIHRoaXMuc25pcHBldE5hbWVNYXAgPSB7fTtcbiAgICB0aGlzLnJlZ2lzdGVyID0gZnVuY3Rpb24oc25pcHBldHMsIHNjb3BlKSB7XG4gICAgICAgIHZhciBzbmlwcGV0TWFwID0gdGhpcy5zbmlwcGV0TWFwO1xuICAgICAgICB2YXIgc25pcHBldE5hbWVNYXAgPSB0aGlzLnNuaXBwZXROYW1lTWFwO1xuICAgICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICAgIFxuICAgICAgICBpZiAoIXNuaXBwZXRzKSBcbiAgICAgICAgICAgIHNuaXBwZXRzID0gW107XG4gICAgICAgIFxuICAgICAgICBmdW5jdGlvbiB3cmFwUmVnZXhwKHNyYykge1xuICAgICAgICAgICAgaWYgKHNyYyAmJiAhL15cXF4/XFwoLipcXClcXCQ/JHxeXFxcXGIkLy50ZXN0KHNyYykpXG4gICAgICAgICAgICAgICAgc3JjID0gXCIoPzpcIiArIHNyYyArIFwiKVwiO1xuXG4gICAgICAgICAgICByZXR1cm4gc3JjIHx8IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZ3VhcmRlZFJlZ2V4cChyZSwgZ3VhcmQsIG9wZW5pbmcpIHtcbiAgICAgICAgICAgIHJlID0gd3JhcFJlZ2V4cChyZSk7XG4gICAgICAgICAgICBndWFyZCA9IHdyYXBSZWdleHAoZ3VhcmQpO1xuICAgICAgICAgICAgaWYgKG9wZW5pbmcpIHtcbiAgICAgICAgICAgICAgICByZSA9IGd1YXJkICsgcmU7XG4gICAgICAgICAgICAgICAgaWYgKHJlICYmIHJlW3JlLmxlbmd0aCAtIDFdICE9IFwiJFwiKVxuICAgICAgICAgICAgICAgICAgICByZSA9IHJlICsgXCIkXCI7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlID0gcmUgKyBndWFyZDtcbiAgICAgICAgICAgICAgICBpZiAocmUgJiYgcmVbMF0gIT0gXCJeXCIpXG4gICAgICAgICAgICAgICAgICAgIHJlID0gXCJeXCIgKyByZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUmVnRXhwKHJlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGFkZFNuaXBwZXQocykge1xuICAgICAgICAgICAgaWYgKCFzLnNjb3BlKVxuICAgICAgICAgICAgICAgIHMuc2NvcGUgPSBzY29wZSB8fCBcIl9cIjtcbiAgICAgICAgICAgIHNjb3BlID0gcy5zY29wZTtcbiAgICAgICAgICAgIGlmICghc25pcHBldE1hcFtzY29wZV0pIHtcbiAgICAgICAgICAgICAgICBzbmlwcGV0TWFwW3Njb3BlXSA9IFtdO1xuICAgICAgICAgICAgICAgIHNuaXBwZXROYW1lTWFwW3Njb3BlXSA9IHt9O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgbWFwID0gc25pcHBldE5hbWVNYXBbc2NvcGVdO1xuICAgICAgICAgICAgaWYgKHMubmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBvbGQgPSBtYXBbcy5uYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAob2xkKVxuICAgICAgICAgICAgICAgICAgICBzZWxmLnVucmVnaXN0ZXIob2xkKTtcbiAgICAgICAgICAgICAgICBtYXBbcy5uYW1lXSA9IHM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzbmlwcGV0TWFwW3Njb3BlXS5wdXNoKHMpO1xuXG4gICAgICAgICAgICBpZiAocy5wcmVmaXgpXG4gICAgICAgICAgICAgICAgcy50YWJUcmlnZ2VyID0gcy5wcmVmaXg7XG5cbiAgICAgICAgICAgIGlmICghcy5jb250ZW50ICYmIHMuYm9keSlcbiAgICAgICAgICAgICAgICBzLmNvbnRlbnQgPSBBcnJheS5pc0FycmF5KHMuYm9keSkgPyBzLmJvZHkuam9pbihcIlxcblwiKSA6IHMuYm9keTtcblxuICAgICAgICAgICAgaWYgKHMudGFiVHJpZ2dlciAmJiAhcy50cmlnZ2VyKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzLmd1YXJkICYmIC9eXFx3Ly50ZXN0KHMudGFiVHJpZ2dlcikpXG4gICAgICAgICAgICAgICAgICAgIHMuZ3VhcmQgPSBcIlxcXFxiXCI7XG4gICAgICAgICAgICAgICAgcy50cmlnZ2VyID0gbGFuZy5lc2NhcGVSZWdFeHAocy50YWJUcmlnZ2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgaWYgKCFzLnRyaWdnZXIgJiYgIXMuZ3VhcmQgJiYgIXMuZW5kVHJpZ2dlciAmJiAhcy5lbmRHdWFyZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHMuc3RhcnRSZSA9IGd1YXJkZWRSZWdleHAocy50cmlnZ2VyLCBzLmd1YXJkLCB0cnVlKTtcbiAgICAgICAgICAgIHMudHJpZ2dlclJlID0gbmV3IFJlZ0V4cChzLnRyaWdnZXIpO1xuXG4gICAgICAgICAgICBzLmVuZFJlID0gZ3VhcmRlZFJlZ2V4cChzLmVuZFRyaWdnZXIsIHMuZW5kR3VhcmQsIHRydWUpO1xuICAgICAgICAgICAgcy5lbmRUcmlnZ2VyUmUgPSBuZXcgUmVnRXhwKHMuZW5kVHJpZ2dlcik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzbmlwcGV0cykpIHtcbiAgICAgICAgICAgIHNuaXBwZXRzLmZvckVhY2goYWRkU25pcHBldCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhzbmlwcGV0cykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgICAgICBhZGRTbmlwcGV0KHNuaXBwZXRzW2tleV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHRoaXMuX3NpZ25hbChcInJlZ2lzdGVyU25pcHBldHNcIiwge3Njb3BlOiBzY29wZX0pO1xuICAgIH07XG4gICAgdGhpcy51bnJlZ2lzdGVyID0gZnVuY3Rpb24oc25pcHBldHMsIHNjb3BlKSB7XG4gICAgICAgIHZhciBzbmlwcGV0TWFwID0gdGhpcy5zbmlwcGV0TWFwO1xuICAgICAgICB2YXIgc25pcHBldE5hbWVNYXAgPSB0aGlzLnNuaXBwZXROYW1lTWFwO1xuXG4gICAgICAgIGZ1bmN0aW9uIHJlbW92ZVNuaXBwZXQocykge1xuICAgICAgICAgICAgdmFyIG5hbWVNYXAgPSBzbmlwcGV0TmFtZU1hcFtzLnNjb3BlfHxzY29wZV07XG4gICAgICAgICAgICBpZiAobmFtZU1hcCAmJiBuYW1lTWFwW3MubmFtZV0pIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgbmFtZU1hcFtzLm5hbWVdO1xuICAgICAgICAgICAgICAgIHZhciBtYXAgPSBzbmlwcGV0TWFwW3Muc2NvcGV8fHNjb3BlXTtcbiAgICAgICAgICAgICAgICB2YXIgaSA9IG1hcCAmJiBtYXAuaW5kZXhPZihzKTtcbiAgICAgICAgICAgICAgICBpZiAoaSA+PSAwKVxuICAgICAgICAgICAgICAgICAgICBtYXAuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzbmlwcGV0cy5jb250ZW50KVxuICAgICAgICAgICAgcmVtb3ZlU25pcHBldChzbmlwcGV0cyk7XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc25pcHBldHMpKVxuICAgICAgICAgICAgc25pcHBldHMuZm9yRWFjaChyZW1vdmVTbmlwcGV0KTtcbiAgICB9O1xuICAgIHRoaXMucGFyc2VTbmlwcGV0RmlsZSA9IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgvXFxyL2csIFwiXCIpO1xuICAgICAgICB2YXIgbGlzdCA9IFtdLCBzbmlwcGV0ID0ge307XG4gICAgICAgIHZhciByZSA9IC9eIy4qfF4oe1tcXHNcXFNdKn0pXFxzKiR8XihcXFMrKSAoLiopJHxeKCg/OlxcbipcXHQuKikrKS9nbTtcbiAgICAgICAgdmFyIG07XG4gICAgICAgIHdoaWxlIChtID0gcmUuZXhlYyhzdHIpKSB7XG4gICAgICAgICAgICBpZiAobVsxXSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHNuaXBwZXQgPSBKU09OLnBhcnNlKG1bMV0pO1xuICAgICAgICAgICAgICAgICAgICBsaXN0LnB1c2goc25pcHBldCk7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgICAgICAgIH0gaWYgKG1bNF0pIHtcbiAgICAgICAgICAgICAgICBzbmlwcGV0LmNvbnRlbnQgPSBtWzRdLnJlcGxhY2UoL15cXHQvZ20sIFwiXCIpO1xuICAgICAgICAgICAgICAgIGxpc3QucHVzaChzbmlwcGV0KTtcbiAgICAgICAgICAgICAgICBzbmlwcGV0ID0ge307XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBtWzJdLCB2YWwgPSBtWzNdO1xuICAgICAgICAgICAgICAgIGlmIChrZXkgPT0gXCJyZWdleFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBndWFyZFJlID0gL1xcLygoPzpbXlxcL1xcXFxdfFxcXFwuKSopfCQvZztcbiAgICAgICAgICAgICAgICAgICAgc25pcHBldC5ndWFyZCA9IGd1YXJkUmUuZXhlYyh2YWwpWzFdO1xuICAgICAgICAgICAgICAgICAgICBzbmlwcGV0LnRyaWdnZXIgPSBndWFyZFJlLmV4ZWModmFsKVsxXTtcbiAgICAgICAgICAgICAgICAgICAgc25pcHBldC5lbmRUcmlnZ2VyID0gZ3VhcmRSZS5leGVjKHZhbClbMV07XG4gICAgICAgICAgICAgICAgICAgIHNuaXBwZXQuZW5kR3VhcmQgPSBndWFyZFJlLmV4ZWModmFsKVsxXTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtleSA9PSBcInNuaXBwZXRcIikge1xuICAgICAgICAgICAgICAgICAgICBzbmlwcGV0LnRhYlRyaWdnZXIgPSB2YWwubWF0Y2goL15cXFMqLylbMF07XG4gICAgICAgICAgICAgICAgICAgIGlmICghc25pcHBldC5uYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgc25pcHBldC5uYW1lID0gdmFsO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgIHNuaXBwZXRba2V5XSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgfTtcbiAgICB0aGlzLmdldFNuaXBwZXRCeU5hbWUgPSBmdW5jdGlvbihuYW1lLCBlZGl0b3IpIHtcbiAgICAgICAgdmFyIHNuaXBwZXRNYXAgPSB0aGlzLnNuaXBwZXROYW1lTWFwO1xuICAgICAgICB2YXIgc25pcHBldDtcbiAgICAgICAgdGhpcy5nZXRBY3RpdmVTY29wZXMoZWRpdG9yKS5zb21lKGZ1bmN0aW9uKHNjb3BlKSB7XG4gICAgICAgICAgICB2YXIgc25pcHBldHMgPSBzbmlwcGV0TWFwW3Njb3BlXTtcbiAgICAgICAgICAgIGlmIChzbmlwcGV0cylcbiAgICAgICAgICAgICAgICBzbmlwcGV0ID0gc25pcHBldHNbbmFtZV07XG4gICAgICAgICAgICByZXR1cm4gISFzbmlwcGV0O1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgcmV0dXJuIHNuaXBwZXQ7XG4gICAgfTtcblxufSkuY2FsbChTbmlwcGV0TWFuYWdlci5wcm90b3R5cGUpO1xuXG5cbnZhciBUYWJzdG9wTWFuYWdlciA9IGZ1bmN0aW9uKGVkaXRvcikge1xuICAgIGlmIChlZGl0b3IudGFic3RvcE1hbmFnZXIpXG4gICAgICAgIHJldHVybiBlZGl0b3IudGFic3RvcE1hbmFnZXI7XG4gICAgZWRpdG9yLnRhYnN0b3BNYW5hZ2VyID0gdGhpcztcbiAgICB0aGlzLiRvbkNoYW5nZSA9IHRoaXMub25DaGFuZ2UuYmluZCh0aGlzKTtcbiAgICB0aGlzLiRvbkNoYW5nZVNlbGVjdGlvbiA9IGxhbmcuZGVsYXllZENhbGwodGhpcy5vbkNoYW5nZVNlbGVjdGlvbi5iaW5kKHRoaXMpKS5zY2hlZHVsZTtcbiAgICB0aGlzLiRvbkNoYW5nZVNlc3Npb24gPSB0aGlzLm9uQ2hhbmdlU2Vzc2lvbi5iaW5kKHRoaXMpO1xuICAgIHRoaXMuJG9uQWZ0ZXJFeGVjID0gdGhpcy5vbkFmdGVyRXhlYy5iaW5kKHRoaXMpO1xuICAgIHRoaXMuYXR0YWNoKGVkaXRvcik7XG59O1xuKGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuYXR0YWNoID0gZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgICAgIHRoaXMuaW5kZXggPSAwO1xuICAgICAgICB0aGlzLnJhbmdlcyA9IFtdO1xuICAgICAgICB0aGlzLnRhYnN0b3BzID0gW107XG4gICAgICAgIHRoaXMuJG9wZW5UYWJzdG9wcyA9IG51bGw7XG4gICAgICAgIHRoaXMuc2VsZWN0ZWRUYWJzdG9wID0gbnVsbDtcblxuICAgICAgICB0aGlzLmVkaXRvciA9IGVkaXRvcjtcbiAgICAgICAgdGhpcy5lZGl0b3Iub24oXCJjaGFuZ2VcIiwgdGhpcy4kb25DaGFuZ2UpO1xuICAgICAgICB0aGlzLmVkaXRvci5vbihcImNoYW5nZVNlbGVjdGlvblwiLCB0aGlzLiRvbkNoYW5nZVNlbGVjdGlvbik7XG4gICAgICAgIHRoaXMuZWRpdG9yLm9uKFwiY2hhbmdlU2Vzc2lvblwiLCB0aGlzLiRvbkNoYW5nZVNlc3Npb24pO1xuICAgICAgICB0aGlzLmVkaXRvci5jb21tYW5kcy5vbihcImFmdGVyRXhlY1wiLCB0aGlzLiRvbkFmdGVyRXhlYyk7XG4gICAgICAgIHRoaXMuZWRpdG9yLmtleUJpbmRpbmcuYWRkS2V5Ym9hcmRIYW5kbGVyKHRoaXMua2V5Ym9hcmRIYW5kbGVyKTtcbiAgICB9O1xuICAgIHRoaXMuZGV0YWNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMudGFic3RvcHMuZm9yRWFjaCh0aGlzLnJlbW92ZVRhYnN0b3BNYXJrZXJzLCB0aGlzKTtcbiAgICAgICAgdGhpcy5yYW5nZXMgPSBudWxsO1xuICAgICAgICB0aGlzLnRhYnN0b3BzID0gbnVsbDtcbiAgICAgICAgdGhpcy5zZWxlY3RlZFRhYnN0b3AgPSBudWxsO1xuICAgICAgICB0aGlzLmVkaXRvci5yZW1vdmVMaXN0ZW5lcihcImNoYW5nZVwiLCB0aGlzLiRvbkNoYW5nZSk7XG4gICAgICAgIHRoaXMuZWRpdG9yLnJlbW92ZUxpc3RlbmVyKFwiY2hhbmdlU2VsZWN0aW9uXCIsIHRoaXMuJG9uQ2hhbmdlU2VsZWN0aW9uKTtcbiAgICAgICAgdGhpcy5lZGl0b3IucmVtb3ZlTGlzdGVuZXIoXCJjaGFuZ2VTZXNzaW9uXCIsIHRoaXMuJG9uQ2hhbmdlU2Vzc2lvbik7XG4gICAgICAgIHRoaXMuZWRpdG9yLmNvbW1hbmRzLnJlbW92ZUxpc3RlbmVyKFwiYWZ0ZXJFeGVjXCIsIHRoaXMuJG9uQWZ0ZXJFeGVjKTtcbiAgICAgICAgdGhpcy5lZGl0b3Iua2V5QmluZGluZy5yZW1vdmVLZXlib2FyZEhhbmRsZXIodGhpcy5rZXlib2FyZEhhbmRsZXIpO1xuICAgICAgICB0aGlzLmVkaXRvci50YWJzdG9wTWFuYWdlciA9IG51bGw7XG4gICAgICAgIHRoaXMuZWRpdG9yID0gbnVsbDtcbiAgICB9O1xuXG4gICAgdGhpcy5vbkNoYW5nZSA9IGZ1bmN0aW9uKGRlbHRhKSB7XG4gICAgICAgIHZhciBpc1JlbW92ZSA9IGRlbHRhLmFjdGlvblswXSA9PSBcInJcIjtcbiAgICAgICAgdmFyIHNlbGVjdGVkVGFic3RvcCA9IHRoaXMuc2VsZWN0ZWRUYWJzdG9wIHx8IHt9O1xuICAgICAgICB2YXIgcGFyZW50cyA9IHNlbGVjdGVkVGFic3RvcC5wYXJlbnRzIHx8IHt9O1xuICAgICAgICB2YXIgdGFic3RvcHMgPSAodGhpcy50YWJzdG9wcyB8fCBbXSkuc2xpY2UoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YWJzdG9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIHRzID0gdGFic3RvcHNbaV07XG4gICAgICAgICAgICB2YXIgYWN0aXZlID0gdHMgPT0gc2VsZWN0ZWRUYWJzdG9wIHx8IHBhcmVudHNbdHMuaW5kZXhdO1xuICAgICAgICAgICAgdHMucmFuZ2VMaXN0LiRiaWFzID0gYWN0aXZlID8gMCA6IDE7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIGlmIChkZWx0YS5hY3Rpb24gPT0gXCJyZW1vdmVcIiAmJiB0cyAhPT0gc2VsZWN0ZWRUYWJzdG9wKSB7XG4gICAgICAgICAgICAgICAgdmFyIHBhcmVudEFjdGl2ZSA9IHRzLnBhcmVudHMgJiYgdHMucGFyZW50c1tzZWxlY3RlZFRhYnN0b3AuaW5kZXhdO1xuICAgICAgICAgICAgICAgIHZhciBzdGFydEluZGV4ID0gdHMucmFuZ2VMaXN0LnBvaW50SW5kZXgoZGVsdGEuc3RhcnQsIHBhcmVudEFjdGl2ZSk7XG4gICAgICAgICAgICAgICAgc3RhcnRJbmRleCA9IHN0YXJ0SW5kZXggPCAwID8gLXN0YXJ0SW5kZXggLSAxIDogc3RhcnRJbmRleCArIDE7XG4gICAgICAgICAgICAgICAgdmFyIGVuZEluZGV4ID0gdHMucmFuZ2VMaXN0LnBvaW50SW5kZXgoZGVsdGEuZW5kLCBwYXJlbnRBY3RpdmUpO1xuICAgICAgICAgICAgICAgIGVuZEluZGV4ID0gZW5kSW5kZXggPCAwID8gLWVuZEluZGV4IC0gMSA6IGVuZEluZGV4IC0gMTtcbiAgICAgICAgICAgICAgICB2YXIgdG9SZW1vdmUgPSB0cy5yYW5nZUxpc3QucmFuZ2VzLnNsaWNlKHN0YXJ0SW5kZXgsIGVuZEluZGV4KTtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRvUmVtb3ZlLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZVJhbmdlKHRvUmVtb3ZlW2pdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRzLnJhbmdlTGlzdC4kb25DaGFuZ2UoZGVsdGEpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzZXNzaW9uID0gdGhpcy5lZGl0b3Iuc2Vzc2lvbjtcbiAgICAgICAgaWYgKCF0aGlzLiRpbkNoYW5nZSAmJiBpc1JlbW92ZSAmJiBzZXNzaW9uLmdldExlbmd0aCgpID09IDEgJiYgIXNlc3Npb24uZ2V0VmFsdWUoKSlcbiAgICAgICAgICAgIHRoaXMuZGV0YWNoKCk7XG4gICAgfTtcbiAgICB0aGlzLnVwZGF0ZUxpbmtlZEZpZWxkcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgdHMgPSB0aGlzLnNlbGVjdGVkVGFic3RvcDtcbiAgICAgICAgaWYgKCF0cyB8fCAhdHMuaGFzTGlua2VkUmFuZ2VzIHx8ICF0cy5maXJzdE5vbkxpbmtlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdGhpcy4kaW5DaGFuZ2UgPSB0cnVlO1xuICAgICAgICB2YXIgc2Vzc2lvbiA9IHRoaXMuZWRpdG9yLnNlc3Npb247XG4gICAgICAgIHZhciB0ZXh0ID0gc2Vzc2lvbi5nZXRUZXh0UmFuZ2UodHMuZmlyc3ROb25MaW5rZWQpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcmFuZ2UgPSB0c1tpXTtcbiAgICAgICAgICAgIGlmICghcmFuZ2UubGlua2VkKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgdmFyIG9yaWdpbmFsID0gcmFuZ2Uub3JpZ2luYWw7XG4gICAgICAgICAgICB2YXIgZm10ID0gZXhwb3J0cy5zbmlwcGV0TWFuYWdlci50bVN0ckZvcm1hdCh0ZXh0LCBvcmlnaW5hbCwgdGhpcy5lZGl0b3IpO1xuICAgICAgICAgICAgc2Vzc2lvbi5yZXBsYWNlKHJhbmdlLCBmbXQpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuJGluQ2hhbmdlID0gZmFsc2U7XG4gICAgfTtcbiAgICB0aGlzLm9uQWZ0ZXJFeGVjID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoZS5jb21tYW5kICYmICFlLmNvbW1hbmQucmVhZE9ubHkpXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUxpbmtlZEZpZWxkcygpO1xuICAgIH07XG4gICAgdGhpcy5vbkNoYW5nZVNlbGVjdGlvbiA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoIXRoaXMuZWRpdG9yKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgbGVhZCA9IHRoaXMuZWRpdG9yLnNlbGVjdGlvbi5sZWFkO1xuICAgICAgICB2YXIgYW5jaG9yID0gdGhpcy5lZGl0b3Iuc2VsZWN0aW9uLmFuY2hvcjtcbiAgICAgICAgdmFyIGlzRW1wdHkgPSB0aGlzLmVkaXRvci5zZWxlY3Rpb24uaXNFbXB0eSgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMucmFuZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yYW5nZXNbaV0ubGlua2VkKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgdmFyIGNvbnRhaW5zTGVhZCA9IHRoaXMucmFuZ2VzW2ldLmNvbnRhaW5zKGxlYWQucm93LCBsZWFkLmNvbHVtbik7XG4gICAgICAgICAgICB2YXIgY29udGFpbnNBbmNob3IgPSBpc0VtcHR5IHx8IHRoaXMucmFuZ2VzW2ldLmNvbnRhaW5zKGFuY2hvci5yb3csIGFuY2hvci5jb2x1bW4pO1xuICAgICAgICAgICAgaWYgKGNvbnRhaW5zTGVhZCAmJiBjb250YWluc0FuY2hvcilcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5kZXRhY2goKTtcbiAgICB9O1xuICAgIHRoaXMub25DaGFuZ2VTZXNzaW9uID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZGV0YWNoKCk7XG4gICAgfTtcbiAgICB0aGlzLnRhYk5leHQgPSBmdW5jdGlvbihkaXIpIHtcbiAgICAgICAgdmFyIG1heCA9IHRoaXMudGFic3RvcHMubGVuZ3RoO1xuICAgICAgICB2YXIgaW5kZXggPSB0aGlzLmluZGV4ICsgKGRpciB8fCAxKTtcbiAgICAgICAgaW5kZXggPSBNYXRoLm1pbihNYXRoLm1heChpbmRleCwgMSksIG1heCk7XG4gICAgICAgIGlmIChpbmRleCA9PSBtYXgpXG4gICAgICAgICAgICBpbmRleCA9IDA7XG4gICAgICAgIHRoaXMuc2VsZWN0VGFic3RvcChpbmRleCk7XG4gICAgICAgIGlmIChpbmRleCA9PT0gMClcbiAgICAgICAgICAgIHRoaXMuZGV0YWNoKCk7XG4gICAgfTtcbiAgICB0aGlzLnNlbGVjdFRhYnN0b3AgPSBmdW5jdGlvbihpbmRleCkge1xuICAgICAgICB0aGlzLiRvcGVuVGFic3RvcHMgPSBudWxsO1xuICAgICAgICB2YXIgdHMgPSB0aGlzLnRhYnN0b3BzW3RoaXMuaW5kZXhdO1xuICAgICAgICBpZiAodHMpXG4gICAgICAgICAgICB0aGlzLmFkZFRhYnN0b3BNYXJrZXJzKHRzKTtcbiAgICAgICAgdGhpcy5pbmRleCA9IGluZGV4O1xuICAgICAgICB0cyA9IHRoaXMudGFic3RvcHNbdGhpcy5pbmRleF07XG4gICAgICAgIGlmICghdHMgfHwgIXRzLmxlbmd0aClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgXG4gICAgICAgIHRoaXMuc2VsZWN0ZWRUYWJzdG9wID0gdHM7XG4gICAgICAgIHZhciByYW5nZSA9IHRzLmZpcnN0Tm9uTGlua2VkIHx8IHRzO1xuICAgICAgICBpZiAodHMuY2hvaWNlcykgcmFuZ2UuY3Vyc29yID0gcmFuZ2Uuc3RhcnQ7XG4gICAgICAgIGlmICghdGhpcy5lZGl0b3IuaW5WaXJ0dWFsU2VsZWN0aW9uTW9kZSkge1xuICAgICAgICAgICAgdmFyIHNlbCA9IHRoaXMuZWRpdG9yLm11bHRpU2VsZWN0O1xuICAgICAgICAgICAgc2VsLnRvU2luZ2xlUmFuZ2UocmFuZ2UpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmICh0cy5oYXNMaW5rZWRSYW5nZXMgJiYgdHNbaV0ubGlua2VkKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBzZWwuYWRkUmFuZ2UodHNbaV0uY2xvbmUoKSwgdHJ1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmVkaXRvci5zZWxlY3Rpb24uZnJvbU9yaWVudGVkUmFuZ2UocmFuZ2UpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB0aGlzLmVkaXRvci5rZXlCaW5kaW5nLmFkZEtleWJvYXJkSGFuZGxlcih0aGlzLmtleWJvYXJkSGFuZGxlcik7XG4gICAgICAgIGlmICh0aGlzLnNlbGVjdGVkVGFic3RvcCAmJiB0aGlzLnNlbGVjdGVkVGFic3RvcC5jaG9pY2VzKVxuICAgICAgICAgICAgdGhpcy5lZGl0b3IuZXhlY0NvbW1hbmQoXCJzdGFydEF1dG9jb21wbGV0ZVwiLCB7bWF0Y2hlczogdGhpcy5zZWxlY3RlZFRhYnN0b3AuY2hvaWNlc30pO1xuICAgIH07XG4gICAgdGhpcy5hZGRUYWJzdG9wcyA9IGZ1bmN0aW9uKHRhYnN0b3BzLCBzdGFydCwgZW5kKSB7XG4gICAgICAgIHZhciB1c2VMaW5rID0gdGhpcy51c2VMaW5rIHx8ICF0aGlzLmVkaXRvci5nZXRPcHRpb24oXCJlbmFibGVNdWx0aXNlbGVjdFwiKTtcbiAgICAgICAgXG4gICAgICAgIGlmICghdGhpcy4kb3BlblRhYnN0b3BzKVxuICAgICAgICAgICAgdGhpcy4kb3BlblRhYnN0b3BzID0gW107XG4gICAgICAgIGlmICghdGFic3RvcHNbMF0pIHtcbiAgICAgICAgICAgIHZhciBwID0gUmFuZ2UuZnJvbVBvaW50cyhlbmQsIGVuZCk7XG4gICAgICAgICAgICBtb3ZlUmVsYXRpdmUocC5zdGFydCwgc3RhcnQpO1xuICAgICAgICAgICAgbW92ZVJlbGF0aXZlKHAuZW5kLCBzdGFydCk7XG4gICAgICAgICAgICB0YWJzdG9wc1swXSA9IFtwXTtcbiAgICAgICAgICAgIHRhYnN0b3BzWzBdLmluZGV4ID0gMDtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpID0gdGhpcy5pbmRleDtcbiAgICAgICAgdmFyIGFyZyA9IFtpICsgMSwgMF07XG4gICAgICAgIHZhciByYW5nZXMgPSB0aGlzLnJhbmdlcztcbiAgICAgICAgdGFic3RvcHMuZm9yRWFjaChmdW5jdGlvbih0cywgaW5kZXgpIHtcbiAgICAgICAgICAgIHZhciBkZXN0ID0gdGhpcy4kb3BlblRhYnN0b3BzW2luZGV4XSB8fCB0cztcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBwID0gdHNbaV07XG4gICAgICAgICAgICAgICAgdmFyIHJhbmdlID0gUmFuZ2UuZnJvbVBvaW50cyhwLnN0YXJ0LCBwLmVuZCB8fCBwLnN0YXJ0KTtcbiAgICAgICAgICAgICAgICBtb3ZlUG9pbnQocmFuZ2Uuc3RhcnQsIHN0YXJ0KTtcbiAgICAgICAgICAgICAgICBtb3ZlUG9pbnQocmFuZ2UuZW5kLCBzdGFydCk7XG4gICAgICAgICAgICAgICAgcmFuZ2Uub3JpZ2luYWwgPSBwO1xuICAgICAgICAgICAgICAgIHJhbmdlLnRhYnN0b3AgPSBkZXN0O1xuICAgICAgICAgICAgICAgIHJhbmdlcy5wdXNoKHJhbmdlKTtcbiAgICAgICAgICAgICAgICBpZiAoZGVzdCAhPSB0cylcbiAgICAgICAgICAgICAgICAgICAgZGVzdC51bnNoaWZ0KHJhbmdlKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIGRlc3RbaV0gPSByYW5nZTtcbiAgICAgICAgICAgICAgICBpZiAocC5mbXRTdHJpbmcgfHwgKGRlc3QuZmlyc3ROb25MaW5rZWQgJiYgdXNlTGluaykpIHtcbiAgICAgICAgICAgICAgICAgICAgcmFuZ2UubGlua2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgZGVzdC5oYXNMaW5rZWRSYW5nZXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIWRlc3QuZmlyc3ROb25MaW5rZWQpXG4gICAgICAgICAgICAgICAgICAgIGRlc3QuZmlyc3ROb25MaW5rZWQgPSByYW5nZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghZGVzdC5maXJzdE5vbkxpbmtlZClcbiAgICAgICAgICAgICAgICBkZXN0Lmhhc0xpbmtlZFJhbmdlcyA9IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGRlc3QgPT09IHRzKSB7XG4gICAgICAgICAgICAgICAgYXJnLnB1c2goZGVzdCk7XG4gICAgICAgICAgICAgICAgdGhpcy4kb3BlblRhYnN0b3BzW2luZGV4XSA9IGRlc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFkZFRhYnN0b3BNYXJrZXJzKGRlc3QpO1xuICAgICAgICAgICAgZGVzdC5yYW5nZUxpc3QgPSBkZXN0LnJhbmdlTGlzdCB8fCBuZXcgUmFuZ2VMaXN0KCk7XG4gICAgICAgICAgICBkZXN0LnJhbmdlTGlzdC4kYmlhcyA9IDA7XG4gICAgICAgICAgICBkZXN0LnJhbmdlTGlzdC5hZGRMaXN0KGRlc3QpO1xuICAgICAgICB9LCB0aGlzKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChhcmcubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgaWYgKHRoaXMudGFic3RvcHMubGVuZ3RoKVxuICAgICAgICAgICAgICAgIGFyZy5wdXNoKGFyZy5zcGxpY2UoMiwgMSlbMF0pO1xuICAgICAgICAgICAgdGhpcy50YWJzdG9wcy5zcGxpY2UuYXBwbHkodGhpcy50YWJzdG9wcywgYXJnKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICB0aGlzLmFkZFRhYnN0b3BNYXJrZXJzID0gZnVuY3Rpb24odHMpIHtcbiAgICAgICAgdmFyIHNlc3Npb24gPSB0aGlzLmVkaXRvci5zZXNzaW9uO1xuICAgICAgICB0cy5mb3JFYWNoKGZ1bmN0aW9uKHJhbmdlKSB7XG4gICAgICAgICAgICBpZiAgKCFyYW5nZS5tYXJrZXJJZClcbiAgICAgICAgICAgICAgICByYW5nZS5tYXJrZXJJZCA9IHNlc3Npb24uYWRkTWFya2VyKHJhbmdlLCBcImFjZV9zbmlwcGV0LW1hcmtlclwiLCBcInRleHRcIik7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgdGhpcy5yZW1vdmVUYWJzdG9wTWFya2VycyA9IGZ1bmN0aW9uKHRzKSB7XG4gICAgICAgIHZhciBzZXNzaW9uID0gdGhpcy5lZGl0b3Iuc2Vzc2lvbjtcbiAgICAgICAgdHMuZm9yRWFjaChmdW5jdGlvbihyYW5nZSkge1xuICAgICAgICAgICAgc2Vzc2lvbi5yZW1vdmVNYXJrZXIocmFuZ2UubWFya2VySWQpO1xuICAgICAgICAgICAgcmFuZ2UubWFya2VySWQgPSBudWxsO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIHRoaXMucmVtb3ZlUmFuZ2UgPSBmdW5jdGlvbihyYW5nZSkge1xuICAgICAgICB2YXIgaSA9IHJhbmdlLnRhYnN0b3AuaW5kZXhPZihyYW5nZSk7XG4gICAgICAgIGlmIChpICE9IC0xKSByYW5nZS50YWJzdG9wLnNwbGljZShpLCAxKTtcbiAgICAgICAgaSA9IHRoaXMucmFuZ2VzLmluZGV4T2YocmFuZ2UpO1xuICAgICAgICBpZiAoaSAhPSAtMSkgdGhpcy5yYW5nZXMuc3BsaWNlKGksIDEpO1xuICAgICAgICBpID0gcmFuZ2UudGFic3RvcC5yYW5nZUxpc3QucmFuZ2VzLmluZGV4T2YocmFuZ2UpO1xuICAgICAgICBpZiAoaSAhPSAtMSkgcmFuZ2UudGFic3RvcC5zcGxpY2UoaSwgMSk7XG4gICAgICAgIHRoaXMuZWRpdG9yLnNlc3Npb24ucmVtb3ZlTWFya2VyKHJhbmdlLm1hcmtlcklkKTtcbiAgICAgICAgaWYgKCFyYW5nZS50YWJzdG9wLmxlbmd0aCkge1xuICAgICAgICAgICAgaSA9IHRoaXMudGFic3RvcHMuaW5kZXhPZihyYW5nZS50YWJzdG9wKTtcbiAgICAgICAgICAgIGlmIChpICE9IC0xKVxuICAgICAgICAgICAgICAgIHRoaXMudGFic3RvcHMuc3BsaWNlKGksIDEpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLnRhYnN0b3BzLmxlbmd0aClcbiAgICAgICAgICAgICAgICB0aGlzLmRldGFjaCgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMua2V5Ym9hcmRIYW5kbGVyID0gbmV3IEhhc2hIYW5kbGVyKCk7XG4gICAgdGhpcy5rZXlib2FyZEhhbmRsZXIuYmluZEtleXMoe1xuICAgICAgICBcIlRhYlwiOiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICAgICAgICAgIGlmIChleHBvcnRzLnNuaXBwZXRNYW5hZ2VyICYmIGV4cG9ydHMuc25pcHBldE1hbmFnZXIuZXhwYW5kV2l0aFRhYihlZGl0b3IpKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIGVkaXRvci50YWJzdG9wTWFuYWdlci50YWJOZXh0KDEpO1xuICAgICAgICAgICAgZWRpdG9yLnJlbmRlcmVyLnNjcm9sbEN1cnNvckludG9WaWV3KCk7XG4gICAgICAgIH0sXG4gICAgICAgIFwiU2hpZnQtVGFiXCI6IGZ1bmN0aW9uKGVkaXRvcikge1xuICAgICAgICAgICAgZWRpdG9yLnRhYnN0b3BNYW5hZ2VyLnRhYk5leHQoLTEpO1xuICAgICAgICAgICAgZWRpdG9yLnJlbmRlcmVyLnNjcm9sbEN1cnNvckludG9WaWV3KCk7XG4gICAgICAgIH0sXG4gICAgICAgIFwiRXNjXCI6IGZ1bmN0aW9uKGVkaXRvcikge1xuICAgICAgICAgICAgZWRpdG9yLnRhYnN0b3BNYW5hZ2VyLmRldGFjaCgpO1xuICAgICAgICB9XG4gICAgfSk7XG59KS5jYWxsKFRhYnN0b3BNYW5hZ2VyLnByb3RvdHlwZSk7XG5cblxuXG52YXIgbW92ZVBvaW50ID0gZnVuY3Rpb24ocG9pbnQsIGRpZmYpIHtcbiAgICBpZiAocG9pbnQucm93ID09IDApXG4gICAgICAgIHBvaW50LmNvbHVtbiArPSBkaWZmLmNvbHVtbjtcbiAgICBwb2ludC5yb3cgKz0gZGlmZi5yb3c7XG59O1xuXG52YXIgbW92ZVJlbGF0aXZlID0gZnVuY3Rpb24ocG9pbnQsIHN0YXJ0KSB7XG4gICAgaWYgKHBvaW50LnJvdyA9PSBzdGFydC5yb3cpXG4gICAgICAgIHBvaW50LmNvbHVtbiAtPSBzdGFydC5jb2x1bW47XG4gICAgcG9pbnQucm93IC09IHN0YXJ0LnJvdztcbn07XG5cblxucmVxdWlyZShcIi4vbGliL2RvbVwiKS5pbXBvcnRDc3NTdHJpbmcoXCJcXFxuLmFjZV9zbmlwcGV0LW1hcmtlciB7XFxcbiAgICAtbW96LWJveC1zaXppbmc6IGJvcmRlci1ib3g7XFxcbiAgICBib3gtc2l6aW5nOiBib3JkZXItYm94O1xcXG4gICAgYmFja2dyb3VuZDogcmdiYSgxOTQsIDE5MywgMjA4LCAwLjA5KTtcXFxuICAgIGJvcmRlcjogMXB4IGRvdHRlZCByZ2JhKDIxMSwgMjA4LCAyMzUsIDAuNjIpO1xcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcXG59XCIpO1xuXG5leHBvcnRzLnNuaXBwZXRNYW5hZ2VyID0gbmV3IFNuaXBwZXRNYW5hZ2VyKCk7XG5cblxudmFyIEVkaXRvciA9IHJlcXVpcmUoXCIuL2VkaXRvclwiKS5FZGl0b3I7XG4oZnVuY3Rpb24oKSB7XG4gICAgdGhpcy5pbnNlcnRTbmlwcGV0ID0gZnVuY3Rpb24oY29udGVudCwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5zbmlwcGV0TWFuYWdlci5pbnNlcnRTbmlwcGV0KHRoaXMsIGNvbnRlbnQsIG9wdGlvbnMpO1xuICAgIH07XG4gICAgdGhpcy5leHBhbmRTbmlwcGV0ID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgICByZXR1cm4gZXhwb3J0cy5zbmlwcGV0TWFuYWdlci5leHBhbmRXaXRoVGFiKHRoaXMsIG9wdGlvbnMpO1xuICAgIH07XG59KS5jYWxsKEVkaXRvci5wcm90b3R5cGUpO1xuXG59KTtcblxuYWNlLmRlZmluZShcImFjZS9hdXRvY29tcGxldGUvcG9wdXBcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIixcImFjZS92aXJ0dWFsX3JlbmRlcmVyXCIsXCJhY2UvZWRpdG9yXCIsXCJhY2UvcmFuZ2VcIixcImFjZS9saWIvZXZlbnRcIixcImFjZS9saWIvbGFuZ1wiLFwiYWNlL2xpYi9kb21cIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBSZW5kZXJlciA9IHJlcXVpcmUoXCIuLi92aXJ0dWFsX3JlbmRlcmVyXCIpLlZpcnR1YWxSZW5kZXJlcjtcbnZhciBFZGl0b3IgPSByZXF1aXJlKFwiLi4vZWRpdG9yXCIpLkVkaXRvcjtcbnZhciBSYW5nZSA9IHJlcXVpcmUoXCIuLi9yYW5nZVwiKS5SYW5nZTtcbnZhciBldmVudCA9IHJlcXVpcmUoXCIuLi9saWIvZXZlbnRcIik7XG52YXIgbGFuZyA9IHJlcXVpcmUoXCIuLi9saWIvbGFuZ1wiKTtcbnZhciBkb20gPSByZXF1aXJlKFwiLi4vbGliL2RvbVwiKTtcblxudmFyICRzaW5nbGVMaW5lRWRpdG9yID0gZnVuY3Rpb24oZWwpIHtcbiAgICB2YXIgcmVuZGVyZXIgPSBuZXcgUmVuZGVyZXIoZWwpO1xuXG4gICAgcmVuZGVyZXIuJG1heExpbmVzID0gNDtcblxuICAgIHZhciBlZGl0b3IgPSBuZXcgRWRpdG9yKHJlbmRlcmVyKTtcblxuICAgIGVkaXRvci5zZXRIaWdobGlnaHRBY3RpdmVMaW5lKGZhbHNlKTtcbiAgICBlZGl0b3Iuc2V0U2hvd1ByaW50TWFyZ2luKGZhbHNlKTtcbiAgICBlZGl0b3IucmVuZGVyZXIuc2V0U2hvd0d1dHRlcihmYWxzZSk7XG4gICAgZWRpdG9yLnJlbmRlcmVyLnNldEhpZ2hsaWdodEd1dHRlckxpbmUoZmFsc2UpO1xuXG4gICAgZWRpdG9yLiRtb3VzZUhhbmRsZXIuJGZvY3VzVGltZW91dCA9IDA7XG4gICAgZWRpdG9yLiRoaWdobGlnaHRUYWdQZW5kaW5nID0gdHJ1ZTtcblxuICAgIHJldHVybiBlZGl0b3I7XG59O1xuXG52YXIgQWNlUG9wdXAgPSBmdW5jdGlvbihwYXJlbnROb2RlKSB7XG4gICAgdmFyIGVsID0gZG9tLmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgdmFyIHBvcHVwID0gbmV3ICRzaW5nbGVMaW5lRWRpdG9yKGVsKTtcblxuICAgIGlmIChwYXJlbnROb2RlKVxuICAgICAgICBwYXJlbnROb2RlLmFwcGVuZENoaWxkKGVsKTtcbiAgICBlbC5zdHlsZS5kaXNwbGF5ID0gXCJub25lXCI7XG4gICAgcG9wdXAucmVuZGVyZXIuY29udGVudC5zdHlsZS5jdXJzb3IgPSBcImRlZmF1bHRcIjtcbiAgICBwb3B1cC5yZW5kZXJlci5zZXRTdHlsZShcImFjZV9hdXRvY29tcGxldGVcIik7XG5cbiAgICBwb3B1cC5zZXRPcHRpb24oXCJkaXNwbGF5SW5kZW50R3VpZGVzXCIsIGZhbHNlKTtcbiAgICBwb3B1cC5zZXRPcHRpb24oXCJkcmFnRGVsYXlcIiwgMTUwKTtcblxuICAgIHZhciBub29wID0gZnVuY3Rpb24oKXt9O1xuXG4gICAgcG9wdXAuZm9jdXMgPSBub29wO1xuICAgIHBvcHVwLiRpc0ZvY3VzZWQgPSB0cnVlO1xuXG4gICAgcG9wdXAucmVuZGVyZXIuJGN1cnNvckxheWVyLnJlc3RhcnRUaW1lciA9IG5vb3A7XG4gICAgcG9wdXAucmVuZGVyZXIuJGN1cnNvckxheWVyLmVsZW1lbnQuc3R5bGUub3BhY2l0eSA9IDA7XG5cbiAgICBwb3B1cC5yZW5kZXJlci4kbWF4TGluZXMgPSA4O1xuICAgIHBvcHVwLnJlbmRlcmVyLiRrZWVwVGV4dEFyZWFBdEN1cnNvciA9IGZhbHNlO1xuXG4gICAgcG9wdXAuc2V0SGlnaGxpZ2h0QWN0aXZlTGluZShmYWxzZSk7XG4gICAgcG9wdXAuc2Vzc2lvbi5oaWdobGlnaHQoXCJcIik7XG4gICAgcG9wdXAuc2Vzc2lvbi4kc2VhcmNoSGlnaGxpZ2h0LmNsYXp6ID0gXCJhY2VfaGlnaGxpZ2h0LW1hcmtlclwiO1xuXG4gICAgcG9wdXAub24oXCJtb3VzZWRvd25cIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgcG9zID0gZS5nZXREb2N1bWVudFBvc2l0aW9uKCk7XG4gICAgICAgIHBvcHVwLnNlbGVjdGlvbi5tb3ZlVG9Qb3NpdGlvbihwb3MpO1xuICAgICAgICBzZWxlY3Rpb25NYXJrZXIuc3RhcnQucm93ID0gc2VsZWN0aW9uTWFya2VyLmVuZC5yb3cgPSBwb3Mucm93O1xuICAgICAgICBlLnN0b3AoKTtcbiAgICB9KTtcblxuICAgIHZhciBsYXN0TW91c2VFdmVudDtcbiAgICB2YXIgaG92ZXJNYXJrZXIgPSBuZXcgUmFuZ2UoLTEsMCwtMSxJbmZpbml0eSk7XG4gICAgdmFyIHNlbGVjdGlvbk1hcmtlciA9IG5ldyBSYW5nZSgtMSwwLC0xLEluZmluaXR5KTtcbiAgICBzZWxlY3Rpb25NYXJrZXIuaWQgPSBwb3B1cC5zZXNzaW9uLmFkZE1hcmtlcihzZWxlY3Rpb25NYXJrZXIsIFwiYWNlX2FjdGl2ZS1saW5lXCIsIFwiZnVsbExpbmVcIik7XG4gICAgcG9wdXAuc2V0U2VsZWN0T25Ib3ZlciA9IGZ1bmN0aW9uKHZhbCkge1xuICAgICAgICBpZiAoIXZhbCkge1xuICAgICAgICAgICAgaG92ZXJNYXJrZXIuaWQgPSBwb3B1cC5zZXNzaW9uLmFkZE1hcmtlcihob3Zlck1hcmtlciwgXCJhY2VfbGluZS1ob3ZlclwiLCBcImZ1bGxMaW5lXCIpO1xuICAgICAgICB9IGVsc2UgaWYgKGhvdmVyTWFya2VyLmlkKSB7XG4gICAgICAgICAgICBwb3B1cC5zZXNzaW9uLnJlbW92ZU1hcmtlcihob3Zlck1hcmtlci5pZCk7XG4gICAgICAgICAgICBob3Zlck1hcmtlci5pZCA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHBvcHVwLnNldFNlbGVjdE9uSG92ZXIoZmFsc2UpO1xuICAgIHBvcHVwLm9uKFwibW91c2Vtb3ZlXCIsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKCFsYXN0TW91c2VFdmVudCkge1xuICAgICAgICAgICAgbGFzdE1vdXNlRXZlbnQgPSBlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsYXN0TW91c2VFdmVudC54ID09IGUueCAmJiBsYXN0TW91c2VFdmVudC55ID09IGUueSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RNb3VzZUV2ZW50ID0gZTtcbiAgICAgICAgbGFzdE1vdXNlRXZlbnQuc2Nyb2xsVG9wID0gcG9wdXAucmVuZGVyZXIuc2Nyb2xsVG9wO1xuICAgICAgICB2YXIgcm93ID0gbGFzdE1vdXNlRXZlbnQuZ2V0RG9jdW1lbnRQb3NpdGlvbigpLnJvdztcbiAgICAgICAgaWYgKGhvdmVyTWFya2VyLnN0YXJ0LnJvdyAhPSByb3cpIHtcbiAgICAgICAgICAgIGlmICghaG92ZXJNYXJrZXIuaWQpXG4gICAgICAgICAgICAgICAgcG9wdXAuc2V0Um93KHJvdyk7XG4gICAgICAgICAgICBzZXRIb3Zlck1hcmtlcihyb3cpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcG9wdXAucmVuZGVyZXIub24oXCJiZWZvcmVSZW5kZXJcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChsYXN0TW91c2VFdmVudCAmJiBob3Zlck1hcmtlci5zdGFydC5yb3cgIT0gLTEpIHtcbiAgICAgICAgICAgIGxhc3RNb3VzZUV2ZW50LiRwb3MgPSBudWxsO1xuICAgICAgICAgICAgdmFyIHJvdyA9IGxhc3RNb3VzZUV2ZW50LmdldERvY3VtZW50UG9zaXRpb24oKS5yb3c7XG4gICAgICAgICAgICBpZiAoIWhvdmVyTWFya2VyLmlkKVxuICAgICAgICAgICAgICAgIHBvcHVwLnNldFJvdyhyb3cpO1xuICAgICAgICAgICAgc2V0SG92ZXJNYXJrZXIocm93LCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHBvcHVwLnJlbmRlcmVyLm9uKFwiYWZ0ZXJSZW5kZXJcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciByb3cgPSBwb3B1cC5nZXRSb3coKTtcbiAgICAgICAgdmFyIHQgPSBwb3B1cC5yZW5kZXJlci4kdGV4dExheWVyO1xuICAgICAgICB2YXIgc2VsZWN0ZWQgPSB0LmVsZW1lbnQuY2hpbGROb2Rlc1tyb3cgLSB0LmNvbmZpZy5maXJzdFJvd107XG4gICAgICAgIGlmIChzZWxlY3RlZCAhPT0gdC5zZWxlY3RlZE5vZGUgJiYgdC5zZWxlY3RlZE5vZGUpXG4gICAgICAgICAgICBkb20ucmVtb3ZlQ3NzQ2xhc3ModC5zZWxlY3RlZE5vZGUsIFwiYWNlX3NlbGVjdGVkXCIpO1xuICAgICAgICB0LnNlbGVjdGVkTm9kZSA9IHNlbGVjdGVkO1xuICAgICAgICBpZiAoc2VsZWN0ZWQpXG4gICAgICAgICAgICBkb20uYWRkQ3NzQ2xhc3Moc2VsZWN0ZWQsIFwiYWNlX3NlbGVjdGVkXCIpO1xuICAgIH0pO1xuICAgIHZhciBoaWRlSG92ZXJNYXJrZXIgPSBmdW5jdGlvbigpIHsgc2V0SG92ZXJNYXJrZXIoLTEpOyB9O1xuICAgIHZhciBzZXRIb3Zlck1hcmtlciA9IGZ1bmN0aW9uKHJvdywgc3VwcHJlc3NSZWRyYXcpIHtcbiAgICAgICAgaWYgKHJvdyAhPT0gaG92ZXJNYXJrZXIuc3RhcnQucm93KSB7XG4gICAgICAgICAgICBob3Zlck1hcmtlci5zdGFydC5yb3cgPSBob3Zlck1hcmtlci5lbmQucm93ID0gcm93O1xuICAgICAgICAgICAgaWYgKCFzdXBwcmVzc1JlZHJhdylcbiAgICAgICAgICAgICAgICBwb3B1cC5zZXNzaW9uLl9lbWl0KFwiY2hhbmdlQmFja01hcmtlclwiKTtcbiAgICAgICAgICAgIHBvcHVwLl9lbWl0KFwiY2hhbmdlSG92ZXJNYXJrZXJcIik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHBvcHVwLmdldEhvdmVyZWRSb3cgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIGhvdmVyTWFya2VyLnN0YXJ0LnJvdztcbiAgICB9O1xuXG4gICAgZXZlbnQuYWRkTGlzdGVuZXIocG9wdXAuY29udGFpbmVyLCBcIm1vdXNlb3V0XCIsIGhpZGVIb3Zlck1hcmtlcik7XG4gICAgcG9wdXAub24oXCJoaWRlXCIsIGhpZGVIb3Zlck1hcmtlcik7XG4gICAgcG9wdXAub24oXCJjaGFuZ2VTZWxlY3Rpb25cIiwgaGlkZUhvdmVyTWFya2VyKTtcblxuICAgIHBvcHVwLnNlc3Npb24uZG9jLmdldExlbmd0aCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gcG9wdXAuZGF0YS5sZW5ndGg7XG4gICAgfTtcbiAgICBwb3B1cC5zZXNzaW9uLmRvYy5nZXRMaW5lID0gZnVuY3Rpb24oaSkge1xuICAgICAgICB2YXIgZGF0YSA9IHBvcHVwLmRhdGFbaV07XG4gICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PSBcInN0cmluZ1wiKVxuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIHJldHVybiAoZGF0YSAmJiBkYXRhLnZhbHVlKSB8fCBcIlwiO1xuICAgIH07XG5cbiAgICB2YXIgYmdUb2tlbml6ZXIgPSBwb3B1cC5zZXNzaW9uLmJnVG9rZW5pemVyO1xuICAgIGJnVG9rZW5pemVyLiR0b2tlbml6ZVJvdyA9IGZ1bmN0aW9uKHJvdykge1xuICAgICAgICB2YXIgZGF0YSA9IHBvcHVwLmRhdGFbcm93XTtcbiAgICAgICAgdmFyIHRva2VucyA9IFtdO1xuICAgICAgICBpZiAoIWRhdGEpXG4gICAgICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIGRhdGEgPSB7dmFsdWU6IGRhdGF9O1xuICAgICAgICB2YXIgY2FwdGlvbiA9IGRhdGEuY2FwdGlvbiB8fCBkYXRhLnZhbHVlIHx8IGRhdGEubmFtZTtcblxuICAgICAgICBmdW5jdGlvbiBhZGRUb2tlbih2YWx1ZSwgY2xhc3NOYW1lKSB7XG4gICAgICAgICAgICB2YWx1ZSAmJiB0b2tlbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogKGRhdGEuY2xhc3NOYW1lIHx8IFwiXCIpICsgKGNsYXNzTmFtZSB8fCBcIlwiKSwgXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgdmFyIGxvd2VyID0gY2FwdGlvbi50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB2YXIgZmlsdGVyVGV4dCA9IChwb3B1cC5maWx0ZXJUZXh0IHx8IFwiXCIpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHZhciBsYXN0SW5kZXggPSAwO1xuICAgICAgICB2YXIgbGFzdEkgPSAwO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8PSBmaWx0ZXJUZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaSAhPSBsYXN0SSAmJiAoZGF0YS5tYXRjaE1hc2sgJiAoMSA8PCBpKSB8fCBpID09IGZpbHRlclRleHQubGVuZ3RoKSkge1xuICAgICAgICAgICAgICAgIHZhciBzdWIgPSBmaWx0ZXJUZXh0LnNsaWNlKGxhc3RJLCBpKTtcbiAgICAgICAgICAgICAgICBsYXN0SSA9IGk7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gbG93ZXIuaW5kZXhPZihzdWIsIGxhc3RJbmRleCk7XG4gICAgICAgICAgICAgICAgaWYgKGluZGV4ID09IC0xKSBjb250aW51ZTtcbiAgICAgICAgICAgICAgICBhZGRUb2tlbihjYXB0aW9uLnNsaWNlKGxhc3RJbmRleCwgaW5kZXgpLCBcIlwiKTtcbiAgICAgICAgICAgICAgICBsYXN0SW5kZXggPSBpbmRleCArIHN1Yi5sZW5ndGg7XG4gICAgICAgICAgICAgICAgYWRkVG9rZW4oY2FwdGlvbi5zbGljZShpbmRleCwgbGFzdEluZGV4KSwgXCJjb21wbGV0aW9uLWhpZ2hsaWdodFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBhZGRUb2tlbihjYXB0aW9uLnNsaWNlKGxhc3RJbmRleCwgY2FwdGlvbi5sZW5ndGgpLCBcIlwiKTtcbiAgICAgICAgXG4gICAgICAgIGlmIChkYXRhLm1ldGEpXG4gICAgICAgICAgICB0b2tlbnMucHVzaCh7dHlwZTogXCJjb21wbGV0aW9uLW1ldGFcIiwgdmFsdWU6IGRhdGEubWV0YX0pO1xuICAgICAgICBpZiAoZGF0YS5tZXNzYWdlKVxuICAgICAgICAgICAgdG9rZW5zLnB1c2goe3R5cGU6IFwiY29tcGxldGlvbi1tZXNzYWdlXCIsIHZhbHVlOiBkYXRhLm1lc3NhZ2V9KTtcblxuICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgIH07XG4gICAgYmdUb2tlbml6ZXIuJHVwZGF0ZU9uQ2hhbmdlID0gbm9vcDtcbiAgICBiZ1Rva2VuaXplci5zdGFydCA9IG5vb3A7XG5cbiAgICBwb3B1cC5zZXNzaW9uLiRjb21wdXRlV2lkdGggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2NyZWVuV2lkdGggPSAwO1xuICAgIH07XG4gICAgcG9wdXAuaXNPcGVuID0gZmFsc2U7XG4gICAgcG9wdXAuaXNUb3Bkb3duID0gZmFsc2U7XG4gICAgcG9wdXAuYXV0b1NlbGVjdCA9IHRydWU7XG4gICAgcG9wdXAuZmlsdGVyVGV4dCA9IFwiXCI7XG5cbiAgICBwb3B1cC5kYXRhID0gW107XG4gICAgcG9wdXAuc2V0RGF0YSA9IGZ1bmN0aW9uKGxpc3QsIGZpbHRlclRleHQpIHtcbiAgICAgICAgcG9wdXAuZmlsdGVyVGV4dCA9IGZpbHRlclRleHQgfHwgXCJcIjtcbiAgICAgICAgcG9wdXAuc2V0VmFsdWUobGFuZy5zdHJpbmdSZXBlYXQoXCJcXG5cIiwgbGlzdC5sZW5ndGgpLCAtMSk7XG4gICAgICAgIHBvcHVwLmRhdGEgPSBsaXN0IHx8IFtdO1xuICAgICAgICBwb3B1cC5zZXRSb3coMCk7XG4gICAgfTtcbiAgICBwb3B1cC5nZXREYXRhID0gZnVuY3Rpb24ocm93KSB7XG4gICAgICAgIHJldHVybiBwb3B1cC5kYXRhW3Jvd107XG4gICAgfTtcblxuICAgIHBvcHVwLmdldFJvdyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICByZXR1cm4gc2VsZWN0aW9uTWFya2VyLnN0YXJ0LnJvdztcbiAgICB9O1xuICAgIHBvcHVwLnNldFJvdyA9IGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgICAgbGluZSA9IE1hdGgubWF4KHRoaXMuYXV0b1NlbGVjdCA/IDAgOiAtMSwgTWF0aC5taW4odGhpcy5kYXRhLmxlbmd0aCwgbGluZSkpO1xuICAgICAgICBpZiAoc2VsZWN0aW9uTWFya2VyLnN0YXJ0LnJvdyAhPSBsaW5lKSB7XG4gICAgICAgICAgICBwb3B1cC5zZWxlY3Rpb24uY2xlYXJTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgIHNlbGVjdGlvbk1hcmtlci5zdGFydC5yb3cgPSBzZWxlY3Rpb25NYXJrZXIuZW5kLnJvdyA9IGxpbmUgfHwgMDtcbiAgICAgICAgICAgIHBvcHVwLnNlc3Npb24uX2VtaXQoXCJjaGFuZ2VCYWNrTWFya2VyXCIpO1xuICAgICAgICAgICAgcG9wdXAubW92ZUN1cnNvclRvKGxpbmUgfHwgMCwgMCk7XG4gICAgICAgICAgICBpZiAocG9wdXAuaXNPcGVuKVxuICAgICAgICAgICAgICAgIHBvcHVwLl9zaWduYWwoXCJzZWxlY3RcIik7XG4gICAgICAgIH1cbiAgICB9O1xuXG4gICAgcG9wdXAub24oXCJjaGFuZ2VTZWxlY3Rpb25cIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChwb3B1cC5pc09wZW4pXG4gICAgICAgICAgICBwb3B1cC5zZXRSb3cocG9wdXAuc2VsZWN0aW9uLmxlYWQucm93KTtcbiAgICAgICAgcG9wdXAucmVuZGVyZXIuc2Nyb2xsQ3Vyc29ySW50b1ZpZXcoKTtcbiAgICB9KTtcblxuICAgIHBvcHVwLmhpZGUgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy5jb250YWluZXIuc3R5bGUuZGlzcGxheSA9IFwibm9uZVwiO1xuICAgICAgICB0aGlzLl9zaWduYWwoXCJoaWRlXCIpO1xuICAgICAgICBwb3B1cC5pc09wZW4gPSBmYWxzZTtcbiAgICB9O1xuICAgIHBvcHVwLnNob3cgPSBmdW5jdGlvbihwb3MsIGxpbmVIZWlnaHQsIHRvcGRvd25Pbmx5KSB7XG4gICAgICAgIHZhciBlbCA9IHRoaXMuY29udGFpbmVyO1xuICAgICAgICB2YXIgc2NyZWVuSGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0O1xuICAgICAgICB2YXIgc2NyZWVuV2lkdGggPSB3aW5kb3cuaW5uZXJXaWR0aDtcbiAgICAgICAgdmFyIHJlbmRlcmVyID0gdGhpcy5yZW5kZXJlcjtcbiAgICAgICAgdmFyIG1heEggPSByZW5kZXJlci4kbWF4TGluZXMgKiBsaW5lSGVpZ2h0ICogMS40O1xuICAgICAgICB2YXIgdG9wID0gcG9zLnRvcCArIHRoaXMuJGJvcmRlclNpemU7XG4gICAgICAgIHZhciBhbGxvd1RvcGRvd24gPSB0b3AgPiBzY3JlZW5IZWlnaHQgLyAyICYmICF0b3Bkb3duT25seTtcbiAgICAgICAgaWYgKGFsbG93VG9wZG93biAmJiB0b3AgKyBsaW5lSGVpZ2h0ICsgbWF4SCA+IHNjcmVlbkhlaWdodCkge1xuICAgICAgICAgICAgcmVuZGVyZXIuJG1heFBpeGVsSGVpZ2h0ID0gdG9wIC0gMiAqIHRoaXMuJGJvcmRlclNpemU7XG4gICAgICAgICAgICBlbC5zdHlsZS50b3AgPSBcIlwiO1xuICAgICAgICAgICAgZWwuc3R5bGUuYm90dG9tID0gc2NyZWVuSGVpZ2h0IC0gdG9wICsgXCJweFwiO1xuICAgICAgICAgICAgcG9wdXAuaXNUb3Bkb3duID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0b3AgKz0gbGluZUhlaWdodDtcbiAgICAgICAgICAgIHJlbmRlcmVyLiRtYXhQaXhlbEhlaWdodCA9IHNjcmVlbkhlaWdodCAtIHRvcCAtIDAuMiAqIGxpbmVIZWlnaHQ7XG4gICAgICAgICAgICBlbC5zdHlsZS50b3AgPSB0b3AgKyBcInB4XCI7XG4gICAgICAgICAgICBlbC5zdHlsZS5ib3R0b20gPSBcIlwiO1xuICAgICAgICAgICAgcG9wdXAuaXNUb3Bkb3duID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuXG4gICAgICAgIHZhciBsZWZ0ID0gcG9zLmxlZnQ7XG4gICAgICAgIGlmIChsZWZ0ICsgZWwub2Zmc2V0V2lkdGggPiBzY3JlZW5XaWR0aClcbiAgICAgICAgICAgIGxlZnQgPSBzY3JlZW5XaWR0aCAtIGVsLm9mZnNldFdpZHRoO1xuXG4gICAgICAgIGVsLnN0eWxlLmxlZnQgPSBsZWZ0ICsgXCJweFwiO1xuXG4gICAgICAgIHRoaXMuX3NpZ25hbChcInNob3dcIik7XG4gICAgICAgIGxhc3RNb3VzZUV2ZW50ID0gbnVsbDtcbiAgICAgICAgcG9wdXAuaXNPcGVuID0gdHJ1ZTtcbiAgICB9O1xuXG4gICAgcG9wdXAuZ29UbyA9IGZ1bmN0aW9uKHdoZXJlKSB7XG4gICAgICAgIHZhciByb3cgPSB0aGlzLmdldFJvdygpO1xuICAgICAgICB2YXIgbWF4ID0gdGhpcy5zZXNzaW9uLmdldExlbmd0aCgpIC0gMTtcblxuICAgICAgICBzd2l0Y2god2hlcmUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ1cFwiOiByb3cgPSByb3cgPD0gMCA/IG1heCA6IHJvdyAtIDE7IGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImRvd25cIjogcm93ID0gcm93ID49IG1heCA/IC0xIDogcm93ICsgMTsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwic3RhcnRcIjogcm93ID0gMDsgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZW5kXCI6IHJvdyA9IG1heDsgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLnNldFJvdyhyb3cpO1xuICAgIH07XG5cblxuICAgIHBvcHVwLmdldFRleHRMZWZ0T2Zmc2V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRib3JkZXJTaXplICsgdGhpcy5yZW5kZXJlci4kcGFkZGluZyArIHRoaXMuJGltYWdlU2l6ZTtcbiAgICB9O1xuXG4gICAgcG9wdXAuJGltYWdlU2l6ZSA9IDA7XG4gICAgcG9wdXAuJGJvcmRlclNpemUgPSAxO1xuXG4gICAgcmV0dXJuIHBvcHVwO1xufTtcblxuZG9tLmltcG9ydENzc1N0cmluZyhcIlxcXG4uYWNlX2VkaXRvci5hY2VfYXV0b2NvbXBsZXRlIC5hY2VfbWFya2VyLWxheWVyIC5hY2VfYWN0aXZlLWxpbmUge1xcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogI0NBRDZGQTtcXFxuICAgIHotaW5kZXg6IDE7XFxcbn1cXFxuLmFjZV9kYXJrLmFjZV9lZGl0b3IuYWNlX2F1dG9jb21wbGV0ZSAuYWNlX21hcmtlci1sYXllciAuYWNlX2FjdGl2ZS1saW5lIHtcXFxuICAgIGJhY2tncm91bmQtY29sb3I6ICMzYTY3NGU7XFxcbn1cXFxuLmFjZV9lZGl0b3IuYWNlX2F1dG9jb21wbGV0ZSAuYWNlX2xpbmUtaG92ZXIge1xcXG4gICAgYm9yZGVyOiAxcHggc29saWQgI2FiYmZmZTtcXFxuICAgIG1hcmdpbi10b3A6IC0xcHg7XFxcbiAgICBiYWNrZ3JvdW5kOiByZ2JhKDIzMywyMzMsMjUzLDAuNCk7XFxcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxcbiAgICB6LWluZGV4OiAyO1xcXG59XFxcbi5hY2VfZGFyay5hY2VfZWRpdG9yLmFjZV9hdXRvY29tcGxldGUgLmFjZV9saW5lLWhvdmVyIHtcXFxuICAgIGJvcmRlcjogMXB4IHNvbGlkIHJnYmEoMTA5LCAxNTAsIDEzLCAwLjgpO1xcXG4gICAgYmFja2dyb3VuZDogcmdiYSg1OCwgMTAzLCA3OCwgMC42Mik7XFxcbn1cXFxuLmFjZV9jb21wbGV0aW9uLW1ldGEge1xcXG4gICAgb3BhY2l0eTogMC41O1xcXG4gICAgbWFyZ2luOiAwLjllbTtcXFxufVxcXG4uYWNlX2NvbXBsZXRpb24tbWVzc2FnZSB7XFxcbiAgICBjb2xvcjogYmx1ZTtcXFxufVxcXG4uYWNlX2VkaXRvci5hY2VfYXV0b2NvbXBsZXRlIC5hY2VfY29tcGxldGlvbi1oaWdobGlnaHR7XFxcbiAgICBjb2xvcjogIzJkNjljNztcXFxufVxcXG4uYWNlX2RhcmsuYWNlX2VkaXRvci5hY2VfYXV0b2NvbXBsZXRlIC5hY2VfY29tcGxldGlvbi1oaWdobGlnaHR7XFxcbiAgICBjb2xvcjogIzkzY2ExMjtcXFxufVxcXG4uYWNlX2VkaXRvci5hY2VfYXV0b2NvbXBsZXRlIHtcXFxuICAgIHdpZHRoOiAzMDBweDtcXFxuICAgIHotaW5kZXg6IDIwMDAwMDtcXFxuICAgIGJvcmRlcjogMXB4IGxpZ2h0Z3JheSBzb2xpZDtcXFxuICAgIHBvc2l0aW9uOiBmaXhlZDtcXFxuICAgIGJveC1zaGFkb3c6IDJweCAzcHggNXB4IHJnYmEoMCwwLDAsLjIpO1xcXG4gICAgbGluZS1oZWlnaHQ6IDEuNDtcXFxuICAgIGJhY2tncm91bmQ6ICNmZWZlZmU7XFxcbiAgICBjb2xvcjogIzExMTtcXFxufVxcXG4uYWNlX2RhcmsuYWNlX2VkaXRvci5hY2VfYXV0b2NvbXBsZXRlIHtcXFxuICAgIGJvcmRlcjogMXB4ICM0ODQ3NDcgc29saWQ7XFxcbiAgICBib3gtc2hhZG93OiAycHggM3B4IDVweCByZ2JhKDAsIDAsIDAsIDAuNTEpO1xcXG4gICAgbGluZS1oZWlnaHQ6IDEuNDtcXFxuICAgIGJhY2tncm91bmQ6ICMyNTI4MmM7XFxcbiAgICBjb2xvcjogI2MxYzFjMTtcXFxufVwiLCBcImF1dG9jb21wbGV0aW9uLmNzc1wiKTtcblxuZXhwb3J0cy5BY2VQb3B1cCA9IEFjZVBvcHVwO1xuZXhwb3J0cy4kc2luZ2xlTGluZUVkaXRvciA9ICRzaW5nbGVMaW5lRWRpdG9yO1xufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvYXV0b2NvbXBsZXRlL3V0aWxcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbmV4cG9ydHMucGFyRm9yRWFjaCA9IGZ1bmN0aW9uKGFycmF5LCBmbiwgY2FsbGJhY2spIHtcbiAgICB2YXIgY29tcGxldGVkID0gMDtcbiAgICB2YXIgYXJMZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgaWYgKGFyTGVuZ3RoID09PSAwKVxuICAgICAgICBjYWxsYmFjaygpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJMZW5ndGg7IGkrKykge1xuICAgICAgICBmbihhcnJheVtpXSwgZnVuY3Rpb24ocmVzdWx0LCBlcnIpIHtcbiAgICAgICAgICAgIGNvbXBsZXRlZCsrO1xuICAgICAgICAgICAgaWYgKGNvbXBsZXRlZCA9PT0gYXJMZW5ndGgpXG4gICAgICAgICAgICAgICAgY2FsbGJhY2socmVzdWx0LCBlcnIpO1xuICAgICAgICB9KTtcbiAgICB9XG59O1xuXG52YXIgSURfUkVHRVggPSAvW2EtekEtWl8wLTlcXCRcXC1cXHUwMEEyLVxcdTIwMDBcXHUyMDcwLVxcdUZGRkZdLztcblxuZXhwb3J0cy5yZXRyaWV2ZVByZWNlZGluZ0lkZW50aWZpZXIgPSBmdW5jdGlvbih0ZXh0LCBwb3MsIHJlZ2V4KSB7XG4gICAgcmVnZXggPSByZWdleCB8fCBJRF9SRUdFWDtcbiAgICB2YXIgYnVmID0gW107XG4gICAgZm9yICh2YXIgaSA9IHBvcy0xOyBpID49IDA7IGktLSkge1xuICAgICAgICBpZiAocmVnZXgudGVzdCh0ZXh0W2ldKSlcbiAgICAgICAgICAgIGJ1Zi5wdXNoKHRleHRbaV0pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIGJ1Zi5yZXZlcnNlKCkuam9pbihcIlwiKTtcbn07XG5cbmV4cG9ydHMucmV0cmlldmVGb2xsb3dpbmdJZGVudGlmaWVyID0gZnVuY3Rpb24odGV4dCwgcG9zLCByZWdleCkge1xuICAgIHJlZ2V4ID0gcmVnZXggfHwgSURfUkVHRVg7XG4gICAgdmFyIGJ1ZiA9IFtdO1xuICAgIGZvciAodmFyIGkgPSBwb3M7IGkgPCB0ZXh0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChyZWdleC50ZXN0KHRleHRbaV0pKVxuICAgICAgICAgICAgYnVmLnB1c2godGV4dFtpXSk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gYnVmO1xufTtcblxuZXhwb3J0cy5nZXRDb21wbGV0aW9uUHJlZml4ID0gZnVuY3Rpb24gKGVkaXRvcikge1xuICAgIHZhciBwb3MgPSBlZGl0b3IuZ2V0Q3Vyc29yUG9zaXRpb24oKTtcbiAgICB2YXIgbGluZSA9IGVkaXRvci5zZXNzaW9uLmdldExpbmUocG9zLnJvdyk7XG4gICAgdmFyIHByZWZpeDtcbiAgICBlZGl0b3IuY29tcGxldGVycy5mb3JFYWNoKGZ1bmN0aW9uKGNvbXBsZXRlcikge1xuICAgICAgICBpZiAoY29tcGxldGVyLmlkZW50aWZpZXJSZWdleHBzKSB7XG4gICAgICAgICAgICBjb21wbGV0ZXIuaWRlbnRpZmllclJlZ2V4cHMuZm9yRWFjaChmdW5jdGlvbihpZGVudGlmaWVyUmVnZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXByZWZpeCAmJiBpZGVudGlmaWVyUmVnZXgpXG4gICAgICAgICAgICAgICAgICAgIHByZWZpeCA9IHRoaXMucmV0cmlldmVQcmVjZWRpbmdJZGVudGlmaWVyKGxpbmUsIHBvcy5jb2x1bW4sIGlkZW50aWZpZXJSZWdleCk7XG4gICAgICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgICAgICB9XG4gICAgfS5iaW5kKHRoaXMpKTtcbiAgICByZXR1cm4gcHJlZml4IHx8IHRoaXMucmV0cmlldmVQcmVjZWRpbmdJZGVudGlmaWVyKGxpbmUsIHBvcy5jb2x1bW4pO1xufTtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvYXV0b2NvbXBsZXRlXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2Uva2V5Ym9hcmQvaGFzaF9oYW5kbGVyXCIsXCJhY2UvYXV0b2NvbXBsZXRlL3BvcHVwXCIsXCJhY2UvYXV0b2NvbXBsZXRlL3V0aWxcIixcImFjZS9saWIvbGFuZ1wiLFwiYWNlL2xpYi9kb21cIixcImFjZS9zbmlwcGV0c1wiLFwiYWNlL2NvbmZpZ1wiXSwgZnVuY3Rpb24ocmVxdWlyZSwgZXhwb3J0cywgbW9kdWxlKSB7XG5cInVzZSBzdHJpY3RcIjtcblxudmFyIEhhc2hIYW5kbGVyID0gcmVxdWlyZShcIi4va2V5Ym9hcmQvaGFzaF9oYW5kbGVyXCIpLkhhc2hIYW5kbGVyO1xudmFyIEFjZVBvcHVwID0gcmVxdWlyZShcIi4vYXV0b2NvbXBsZXRlL3BvcHVwXCIpLkFjZVBvcHVwO1xudmFyIHV0aWwgPSByZXF1aXJlKFwiLi9hdXRvY29tcGxldGUvdXRpbFwiKTtcbnZhciBsYW5nID0gcmVxdWlyZShcIi4vbGliL2xhbmdcIik7XG52YXIgZG9tID0gcmVxdWlyZShcIi4vbGliL2RvbVwiKTtcbnZhciBzbmlwcGV0TWFuYWdlciA9IHJlcXVpcmUoXCIuL3NuaXBwZXRzXCIpLnNuaXBwZXRNYW5hZ2VyO1xudmFyIGNvbmZpZyA9IHJlcXVpcmUoXCIuL2NvbmZpZ1wiKTtcblxudmFyIEF1dG9jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHRoaXMuYXV0b0luc2VydCA9IGZhbHNlO1xuICAgIHRoaXMuYXV0b1NlbGVjdCA9IHRydWU7XG4gICAgdGhpcy5leGFjdE1hdGNoID0gZmFsc2U7XG4gICAgdGhpcy5nYXRoZXJDb21wbGV0aW9uc0lkID0gMDtcbiAgICB0aGlzLmtleWJvYXJkSGFuZGxlciA9IG5ldyBIYXNoSGFuZGxlcigpO1xuICAgIHRoaXMua2V5Ym9hcmRIYW5kbGVyLmJpbmRLZXlzKHRoaXMuY29tbWFuZHMpO1xuXG4gICAgdGhpcy5ibHVyTGlzdGVuZXIgPSB0aGlzLmJsdXJMaXN0ZW5lci5iaW5kKHRoaXMpO1xuICAgIHRoaXMuY2hhbmdlTGlzdGVuZXIgPSB0aGlzLmNoYW5nZUxpc3RlbmVyLmJpbmQodGhpcyk7XG4gICAgdGhpcy5tb3VzZWRvd25MaXN0ZW5lciA9IHRoaXMubW91c2Vkb3duTGlzdGVuZXIuYmluZCh0aGlzKTtcbiAgICB0aGlzLm1vdXNld2hlZWxMaXN0ZW5lciA9IHRoaXMubW91c2V3aGVlbExpc3RlbmVyLmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLmNoYW5nZVRpbWVyID0gbGFuZy5kZWxheWVkQ2FsbChmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy51cGRhdGVDb21wbGV0aW9ucyh0cnVlKTtcbiAgICB9LmJpbmQodGhpcykpO1xuXG4gICAgdGhpcy50b29sdGlwVGltZXIgPSBsYW5nLmRlbGF5ZWRDYWxsKHRoaXMudXBkYXRlRG9jVG9vbHRpcC5iaW5kKHRoaXMpLCA1MCk7XG59O1xuXG4oZnVuY3Rpb24oKSB7XG5cbiAgICB0aGlzLiRpbml0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMucG9wdXAgPSBuZXcgQWNlUG9wdXAoZG9jdW1lbnQuYm9keSB8fCBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpO1xuICAgICAgICB0aGlzLnBvcHVwLm9uKFwiY2xpY2tcIiwgZnVuY3Rpb24oZSkge1xuICAgICAgICAgICAgdGhpcy5pbnNlcnRNYXRjaCgpO1xuICAgICAgICAgICAgZS5zdG9wKCk7XG4gICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgIHRoaXMucG9wdXAuZm9jdXMgPSB0aGlzLmVkaXRvci5mb2N1cy5iaW5kKHRoaXMuZWRpdG9yKTtcbiAgICAgICAgdGhpcy5wb3B1cC5vbihcInNob3dcIiwgdGhpcy50b29sdGlwVGltZXIuYmluZChudWxsLCBudWxsKSk7XG4gICAgICAgIHRoaXMucG9wdXAub24oXCJzZWxlY3RcIiwgdGhpcy50b29sdGlwVGltZXIuYmluZChudWxsLCBudWxsKSk7XG4gICAgICAgIHRoaXMucG9wdXAub24oXCJjaGFuZ2VIb3Zlck1hcmtlclwiLCB0aGlzLnRvb2x0aXBUaW1lci5iaW5kKG51bGwsIG51bGwpKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9wdXA7XG4gICAgfTtcblxuICAgIHRoaXMuZ2V0UG9wdXAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucG9wdXAgfHwgdGhpcy4kaW5pdCgpO1xuICAgIH07XG5cbiAgICB0aGlzLm9wZW5Qb3B1cCA9IGZ1bmN0aW9uKGVkaXRvciwgcHJlZml4LCBrZWVwUG9wdXBQb3NpdGlvbikge1xuICAgICAgICBpZiAoIXRoaXMucG9wdXApXG4gICAgICAgICAgICB0aGlzLiRpbml0KCk7XG5cbiAgICAgICAgdGhpcy5wb3B1cC5hdXRvU2VsZWN0ID0gdGhpcy5hdXRvU2VsZWN0O1xuXG4gICAgICAgIHRoaXMucG9wdXAuc2V0RGF0YSh0aGlzLmNvbXBsZXRpb25zLmZpbHRlcmVkLCB0aGlzLmNvbXBsZXRpb25zLmZpbHRlclRleHQpO1xuXG4gICAgICAgIGVkaXRvci5rZXlCaW5kaW5nLmFkZEtleWJvYXJkSGFuZGxlcih0aGlzLmtleWJvYXJkSGFuZGxlcik7XG4gICAgICAgIFxuICAgICAgICB2YXIgcmVuZGVyZXIgPSBlZGl0b3IucmVuZGVyZXI7XG4gICAgICAgIHRoaXMucG9wdXAuc2V0Um93KHRoaXMuYXV0b1NlbGVjdCA/IDAgOiAtMSk7XG4gICAgICAgIGlmICgha2VlcFBvcHVwUG9zaXRpb24pIHtcbiAgICAgICAgICAgIHRoaXMucG9wdXAuc2V0VGhlbWUoZWRpdG9yLmdldFRoZW1lKCkpO1xuICAgICAgICAgICAgdGhpcy5wb3B1cC5zZXRGb250U2l6ZShlZGl0b3IuZ2V0Rm9udFNpemUoKSk7XG5cbiAgICAgICAgICAgIHZhciBsaW5lSGVpZ2h0ID0gcmVuZGVyZXIubGF5ZXJDb25maWcubGluZUhlaWdodDtcblxuICAgICAgICAgICAgdmFyIHBvcyA9IHJlbmRlcmVyLiRjdXJzb3JMYXllci5nZXRQaXhlbFBvc2l0aW9uKHRoaXMuYmFzZSwgdHJ1ZSk7XG4gICAgICAgICAgICBwb3MubGVmdCAtPSB0aGlzLnBvcHVwLmdldFRleHRMZWZ0T2Zmc2V0KCk7XG5cbiAgICAgICAgICAgIHZhciByZWN0ID0gZWRpdG9yLmNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgICAgIHBvcy50b3AgKz0gcmVjdC50b3AgLSByZW5kZXJlci5sYXllckNvbmZpZy5vZmZzZXQ7XG4gICAgICAgICAgICBwb3MubGVmdCArPSByZWN0LmxlZnQgLSBlZGl0b3IucmVuZGVyZXIuc2Nyb2xsTGVmdDtcbiAgICAgICAgICAgIHBvcy5sZWZ0ICs9IHJlbmRlcmVyLmd1dHRlcldpZHRoO1xuXG4gICAgICAgICAgICB0aGlzLnBvcHVwLnNob3cocG9zLCBsaW5lSGVpZ2h0KTtcbiAgICAgICAgfSBlbHNlIGlmIChrZWVwUG9wdXBQb3NpdGlvbiAmJiAhcHJlZml4KSB7XG4gICAgICAgICAgICB0aGlzLmRldGFjaCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2hhbmdlVGltZXIuY2FuY2VsKCk7XG4gICAgfTtcblxuICAgIHRoaXMuZGV0YWNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZWRpdG9yLmtleUJpbmRpbmcucmVtb3ZlS2V5Ym9hcmRIYW5kbGVyKHRoaXMua2V5Ym9hcmRIYW5kbGVyKTtcbiAgICAgICAgdGhpcy5lZGl0b3Iub2ZmKFwiY2hhbmdlU2VsZWN0aW9uXCIsIHRoaXMuY2hhbmdlTGlzdGVuZXIpO1xuICAgICAgICB0aGlzLmVkaXRvci5vZmYoXCJibHVyXCIsIHRoaXMuYmx1ckxpc3RlbmVyKTtcbiAgICAgICAgdGhpcy5lZGl0b3Iub2ZmKFwibW91c2Vkb3duXCIsIHRoaXMubW91c2Vkb3duTGlzdGVuZXIpO1xuICAgICAgICB0aGlzLmVkaXRvci5vZmYoXCJtb3VzZXdoZWVsXCIsIHRoaXMubW91c2V3aGVlbExpc3RlbmVyKTtcbiAgICAgICAgdGhpcy5jaGFuZ2VUaW1lci5jYW5jZWwoKTtcbiAgICAgICAgdGhpcy5oaWRlRG9jVG9vbHRpcCgpO1xuXG4gICAgICAgIHRoaXMuZ2F0aGVyQ29tcGxldGlvbnNJZCArPSAxO1xuICAgICAgICBpZiAodGhpcy5wb3B1cCAmJiB0aGlzLnBvcHVwLmlzT3BlbilcbiAgICAgICAgICAgIHRoaXMucG9wdXAuaGlkZSgpO1xuXG4gICAgICAgIGlmICh0aGlzLmJhc2UpXG4gICAgICAgICAgICB0aGlzLmJhc2UuZGV0YWNoKCk7XG4gICAgICAgIHRoaXMuYWN0aXZhdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuY29tcGxldGlvbnMgPSB0aGlzLmJhc2UgPSBudWxsO1xuICAgIH07XG5cbiAgICB0aGlzLmNoYW5nZUxpc3RlbmVyID0gZnVuY3Rpb24oZSkge1xuICAgICAgICB2YXIgY3Vyc29yID0gdGhpcy5lZGl0b3Iuc2VsZWN0aW9uLmxlYWQ7XG4gICAgICAgIGlmIChjdXJzb3Iucm93ICE9IHRoaXMuYmFzZS5yb3cgfHwgY3Vyc29yLmNvbHVtbiA8IHRoaXMuYmFzZS5jb2x1bW4pIHtcbiAgICAgICAgICAgIHRoaXMuZGV0YWNoKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYWN0aXZhdGVkKVxuICAgICAgICAgICAgdGhpcy5jaGFuZ2VUaW1lci5zY2hlZHVsZSgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLmRldGFjaCgpO1xuICAgIH07XG5cbiAgICB0aGlzLmJsdXJMaXN0ZW5lciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdmFyIGVsID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudDtcbiAgICAgICAgdmFyIHRleHQgPSB0aGlzLmVkaXRvci50ZXh0SW5wdXQuZ2V0RWxlbWVudCgpO1xuICAgICAgICB2YXIgZnJvbVRvb2x0aXAgPSBlLnJlbGF0ZWRUYXJnZXQgJiYgdGhpcy50b29sdGlwTm9kZSAmJiB0aGlzLnRvb2x0aXBOb2RlLmNvbnRhaW5zKGUucmVsYXRlZFRhcmdldCk7XG4gICAgICAgIHZhciBjb250YWluZXIgPSB0aGlzLnBvcHVwICYmIHRoaXMucG9wdXAuY29udGFpbmVyO1xuICAgICAgICBpZiAoZWwgIT0gdGV4dCAmJiBlbC5wYXJlbnROb2RlICE9IGNvbnRhaW5lciAmJiAhZnJvbVRvb2x0aXBcbiAgICAgICAgICAgICYmIGVsICE9IHRoaXMudG9vbHRpcE5vZGUgJiYgZS5yZWxhdGVkVGFyZ2V0ICE9IHRleHRcbiAgICAgICAgKSB7XG4gICAgICAgICAgICB0aGlzLmRldGFjaCgpO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMubW91c2Vkb3duTGlzdGVuZXIgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIHRoaXMuZGV0YWNoKCk7XG4gICAgfTtcblxuICAgIHRoaXMubW91c2V3aGVlbExpc3RlbmVyID0gZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGlzLmRldGFjaCgpO1xuICAgIH07XG5cbiAgICB0aGlzLmdvVG8gPSBmdW5jdGlvbih3aGVyZSkge1xuICAgICAgICB0aGlzLnBvcHVwLmdvVG8od2hlcmUpO1xuICAgIH07XG5cbiAgICB0aGlzLmluc2VydE1hdGNoID0gZnVuY3Rpb24oZGF0YSwgb3B0aW9ucykge1xuICAgICAgICBpZiAoIWRhdGEpXG4gICAgICAgICAgICBkYXRhID0gdGhpcy5wb3B1cC5nZXREYXRhKHRoaXMucG9wdXAuZ2V0Um93KCkpO1xuICAgICAgICBpZiAoIWRhdGEpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgdmFyIGNvbXBsZXRpb25zID0gdGhpcy5jb21wbGV0aW9ucztcbiAgICAgICAgdGhpcy5lZGl0b3Iuc3RhcnRPcGVyYXRpb24oe2NvbW1hbmQ6IHtuYW1lOiBcImluc2VydE1hdGNoXCJ9fSk7XG4gICAgICAgIGlmIChkYXRhLmNvbXBsZXRlciAmJiBkYXRhLmNvbXBsZXRlci5pbnNlcnRNYXRjaCkge1xuICAgICAgICAgICAgZGF0YS5jb21wbGV0ZXIuaW5zZXJ0TWF0Y2godGhpcy5lZGl0b3IsIGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKGNvbXBsZXRpb25zLmZpbHRlclRleHQpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmFuZ2VzID0gdGhpcy5lZGl0b3Iuc2VsZWN0aW9uLmdldEFsbFJhbmdlcygpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCByYW5nZTsgcmFuZ2UgPSByYW5nZXNbaV07IGkrKykge1xuICAgICAgICAgICAgICAgICAgICByYW5nZS5zdGFydC5jb2x1bW4gLT0gY29tcGxldGlvbnMuZmlsdGVyVGV4dC5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZWRpdG9yLnNlc3Npb24ucmVtb3ZlKHJhbmdlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZGF0YS5zbmlwcGV0KVxuICAgICAgICAgICAgICAgIHNuaXBwZXRNYW5hZ2VyLmluc2VydFNuaXBwZXQodGhpcy5lZGl0b3IsIGRhdGEuc25pcHBldCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5lZGl0b3IuZXhlY0NvbW1hbmQoXCJpbnNlcnRzdHJpbmdcIiwgZGF0YS52YWx1ZSB8fCBkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5jb21wbGV0aW9ucyA9PSBjb21wbGV0aW9ucylcbiAgICAgICAgICAgIHRoaXMuZGV0YWNoKCk7XG4gICAgICAgIHRoaXMuZWRpdG9yLmVuZE9wZXJhdGlvbigpO1xuICAgIH07XG5cblxuICAgIHRoaXMuY29tbWFuZHMgPSB7XG4gICAgICAgIFwiVXBcIjogZnVuY3Rpb24oZWRpdG9yKSB7IGVkaXRvci5jb21wbGV0ZXIuZ29UbyhcInVwXCIpOyB9LFxuICAgICAgICBcIkRvd25cIjogZnVuY3Rpb24oZWRpdG9yKSB7IGVkaXRvci5jb21wbGV0ZXIuZ29UbyhcImRvd25cIik7IH0sXG4gICAgICAgIFwiQ3RybC1VcHxDdHJsLUhvbWVcIjogZnVuY3Rpb24oZWRpdG9yKSB7IGVkaXRvci5jb21wbGV0ZXIuZ29UbyhcInN0YXJ0XCIpOyB9LFxuICAgICAgICBcIkN0cmwtRG93bnxDdHJsLUVuZFwiOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLmNvbXBsZXRlci5nb1RvKFwiZW5kXCIpOyB9LFxuXG4gICAgICAgIFwiRXNjXCI6IGZ1bmN0aW9uKGVkaXRvcikgeyBlZGl0b3IuY29tcGxldGVyLmRldGFjaCgpOyB9LFxuICAgICAgICBcIlJldHVyblwiOiBmdW5jdGlvbihlZGl0b3IpIHsgcmV0dXJuIGVkaXRvci5jb21wbGV0ZXIuaW5zZXJ0TWF0Y2goKTsgfSxcbiAgICAgICAgXCJTaGlmdC1SZXR1cm5cIjogZnVuY3Rpb24oZWRpdG9yKSB7IGVkaXRvci5jb21wbGV0ZXIuaW5zZXJ0TWF0Y2gobnVsbCwge2RlbGV0ZVN1ZmZpeDogdHJ1ZX0pOyB9LFxuICAgICAgICBcIlRhYlwiOiBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBlZGl0b3IuY29tcGxldGVyLmluc2VydE1hdGNoKCk7XG4gICAgICAgICAgICBpZiAoIXJlc3VsdCAmJiAhZWRpdG9yLnRhYnN0b3BNYW5hZ2VyKVxuICAgICAgICAgICAgICAgIGVkaXRvci5jb21wbGV0ZXIuZ29UbyhcImRvd25cIik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSxcblxuICAgICAgICBcIlBhZ2VVcFwiOiBmdW5jdGlvbihlZGl0b3IpIHsgZWRpdG9yLmNvbXBsZXRlci5wb3B1cC5nb3RvUGFnZVVwKCk7IH0sXG4gICAgICAgIFwiUGFnZURvd25cIjogZnVuY3Rpb24oZWRpdG9yKSB7IGVkaXRvci5jb21wbGV0ZXIucG9wdXAuZ290b1BhZ2VEb3duKCk7IH1cbiAgICB9O1xuXG4gICAgdGhpcy5nYXRoZXJDb21wbGV0aW9ucyA9IGZ1bmN0aW9uKGVkaXRvciwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHNlc3Npb24gPSBlZGl0b3IuZ2V0U2Vzc2lvbigpO1xuICAgICAgICB2YXIgcG9zID0gZWRpdG9yLmdldEN1cnNvclBvc2l0aW9uKCk7XG5cbiAgICAgICAgdmFyIHByZWZpeCA9IHV0aWwuZ2V0Q29tcGxldGlvblByZWZpeChlZGl0b3IpO1xuXG4gICAgICAgIHRoaXMuYmFzZSA9IHNlc3Npb24uZG9jLmNyZWF0ZUFuY2hvcihwb3Mucm93LCBwb3MuY29sdW1uIC0gcHJlZml4Lmxlbmd0aCk7XG4gICAgICAgIHRoaXMuYmFzZS4kaW5zZXJ0UmlnaHQgPSB0cnVlO1xuXG4gICAgICAgIHZhciBtYXRjaGVzID0gW107XG4gICAgICAgIHZhciB0b3RhbCA9IGVkaXRvci5jb21wbGV0ZXJzLmxlbmd0aDtcbiAgICAgICAgZWRpdG9yLmNvbXBsZXRlcnMuZm9yRWFjaChmdW5jdGlvbihjb21wbGV0ZXIsIGkpIHtcbiAgICAgICAgICAgIGNvbXBsZXRlci5nZXRDb21wbGV0aW9ucyhlZGl0b3IsIHNlc3Npb24sIHBvcywgcHJlZml4LCBmdW5jdGlvbihlcnIsIHJlc3VsdHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWVyciAmJiByZXN1bHRzKVxuICAgICAgICAgICAgICAgICAgICBtYXRjaGVzID0gbWF0Y2hlcy5jb25jYXQocmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwge1xuICAgICAgICAgICAgICAgICAgICBwcmVmaXg6IHV0aWwuZ2V0Q29tcGxldGlvblByZWZpeChlZGl0b3IpLFxuICAgICAgICAgICAgICAgICAgICBtYXRjaGVzOiBtYXRjaGVzLFxuICAgICAgICAgICAgICAgICAgICBmaW5pc2hlZDogKC0tdG90YWwgPT09IDApXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG5cbiAgICB0aGlzLnNob3dQb3B1cCA9IGZ1bmN0aW9uKGVkaXRvciwgb3B0aW9ucykge1xuICAgICAgICBpZiAodGhpcy5lZGl0b3IpXG4gICAgICAgICAgICB0aGlzLmRldGFjaCgpO1xuXG4gICAgICAgIHRoaXMuYWN0aXZhdGVkID0gdHJ1ZTtcblxuICAgICAgICB0aGlzLmVkaXRvciA9IGVkaXRvcjtcbiAgICAgICAgaWYgKGVkaXRvci5jb21wbGV0ZXIgIT0gdGhpcykge1xuICAgICAgICAgICAgaWYgKGVkaXRvci5jb21wbGV0ZXIpXG4gICAgICAgICAgICAgICAgZWRpdG9yLmNvbXBsZXRlci5kZXRhY2goKTtcbiAgICAgICAgICAgIGVkaXRvci5jb21wbGV0ZXIgPSB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgZWRpdG9yLm9uKFwiY2hhbmdlU2VsZWN0aW9uXCIsIHRoaXMuY2hhbmdlTGlzdGVuZXIpO1xuICAgICAgICBlZGl0b3Iub24oXCJibHVyXCIsIHRoaXMuYmx1ckxpc3RlbmVyKTtcbiAgICAgICAgZWRpdG9yLm9uKFwibW91c2Vkb3duXCIsIHRoaXMubW91c2Vkb3duTGlzdGVuZXIpO1xuICAgICAgICBlZGl0b3Iub24oXCJtb3VzZXdoZWVsXCIsIHRoaXMubW91c2V3aGVlbExpc3RlbmVyKTtcblxuICAgICAgICB0aGlzLnVwZGF0ZUNvbXBsZXRpb25zKGZhbHNlLCBvcHRpb25zKTtcbiAgICB9O1xuXG4gICAgdGhpcy51cGRhdGVDb21wbGV0aW9ucyA9IGZ1bmN0aW9uKGtlZXBQb3B1cFBvc2l0aW9uLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChrZWVwUG9wdXBQb3NpdGlvbiAmJiB0aGlzLmJhc2UgJiYgdGhpcy5jb21wbGV0aW9ucykge1xuICAgICAgICAgICAgdmFyIHBvcyA9IHRoaXMuZWRpdG9yLmdldEN1cnNvclBvc2l0aW9uKCk7XG4gICAgICAgICAgICB2YXIgcHJlZml4ID0gdGhpcy5lZGl0b3Iuc2Vzc2lvbi5nZXRUZXh0UmFuZ2Uoe3N0YXJ0OiB0aGlzLmJhc2UsIGVuZDogcG9zfSk7XG4gICAgICAgICAgICBpZiAocHJlZml4ID09IHRoaXMuY29tcGxldGlvbnMuZmlsdGVyVGV4dClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB0aGlzLmNvbXBsZXRpb25zLnNldEZpbHRlcihwcmVmaXgpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLmNvbXBsZXRpb25zLmZpbHRlcmVkLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZXRhY2goKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbXBsZXRpb25zLmZpbHRlcmVkLmxlbmd0aCA9PSAxXG4gICAgICAgICAgICAmJiB0aGlzLmNvbXBsZXRpb25zLmZpbHRlcmVkWzBdLnZhbHVlID09IHByZWZpeFxuICAgICAgICAgICAgJiYgIXRoaXMuY29tcGxldGlvbnMuZmlsdGVyZWRbMF0uc25pcHBldClcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZXRhY2goKTtcbiAgICAgICAgICAgIHRoaXMub3BlblBvcHVwKHRoaXMuZWRpdG9yLCBwcmVmaXgsIGtlZXBQb3B1cFBvc2l0aW9uKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5tYXRjaGVzKSB7XG4gICAgICAgICAgICB2YXIgcG9zID0gdGhpcy5lZGl0b3IuZ2V0U2VsZWN0aW9uUmFuZ2UoKS5zdGFydDtcbiAgICAgICAgICAgIHRoaXMuYmFzZSA9IHRoaXMuZWRpdG9yLnNlc3Npb24uZG9jLmNyZWF0ZUFuY2hvcihwb3Mucm93LCBwb3MuY29sdW1uKTtcbiAgICAgICAgICAgIHRoaXMuYmFzZS4kaW5zZXJ0UmlnaHQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5jb21wbGV0aW9ucyA9IG5ldyBGaWx0ZXJlZExpc3Qob3B0aW9ucy5tYXRjaGVzKTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9wZW5Qb3B1cCh0aGlzLmVkaXRvciwgXCJcIiwga2VlcFBvcHVwUG9zaXRpb24pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBfaWQgPSB0aGlzLmdhdGhlckNvbXBsZXRpb25zSWQ7XG4gICAgICAgIHRoaXMuZ2F0aGVyQ29tcGxldGlvbnModGhpcy5lZGl0b3IsIGZ1bmN0aW9uKGVyciwgcmVzdWx0cykge1xuICAgICAgICAgICAgdmFyIGRldGFjaElmRmluaXNoZWQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc3VsdHMuZmluaXNoZWQpIHJldHVybjtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5kZXRhY2goKTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKTtcblxuICAgICAgICAgICAgdmFyIHByZWZpeCA9IHJlc3VsdHMucHJlZml4O1xuICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSByZXN1bHRzICYmIHJlc3VsdHMubWF0Y2hlcztcblxuICAgICAgICAgICAgaWYgKCFtYXRjaGVzIHx8ICFtYXRjaGVzLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gZGV0YWNoSWZGaW5pc2hlZCgpO1xuICAgICAgICAgICAgaWYgKHByZWZpeC5pbmRleE9mKHJlc3VsdHMucHJlZml4KSAhPT0gMCB8fCBfaWQgIT0gdGhpcy5nYXRoZXJDb21wbGV0aW9uc0lkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcblxuICAgICAgICAgICAgdGhpcy5jb21wbGV0aW9ucyA9IG5ldyBGaWx0ZXJlZExpc3QobWF0Y2hlcyk7XG5cbiAgICAgICAgICAgIGlmICh0aGlzLmV4YWN0TWF0Y2gpXG4gICAgICAgICAgICAgICAgdGhpcy5jb21wbGV0aW9ucy5leGFjdE1hdGNoID0gdHJ1ZTtcblxuICAgICAgICAgICAgdGhpcy5jb21wbGV0aW9ucy5zZXRGaWx0ZXIocHJlZml4KTtcbiAgICAgICAgICAgIHZhciBmaWx0ZXJlZCA9IHRoaXMuY29tcGxldGlvbnMuZmlsdGVyZWQ7XG4gICAgICAgICAgICBpZiAoIWZpbHRlcmVkLmxlbmd0aClcbiAgICAgICAgICAgICAgICByZXR1cm4gZGV0YWNoSWZGaW5pc2hlZCgpO1xuICAgICAgICAgICAgaWYgKGZpbHRlcmVkLmxlbmd0aCA9PSAxICYmIGZpbHRlcmVkWzBdLnZhbHVlID09IHByZWZpeCAmJiAhZmlsdGVyZWRbMF0uc25pcHBldClcbiAgICAgICAgICAgICAgICByZXR1cm4gZGV0YWNoSWZGaW5pc2hlZCgpO1xuICAgICAgICAgICAgaWYgKHRoaXMuYXV0b0luc2VydCAmJiBmaWx0ZXJlZC5sZW5ndGggPT0gMSAmJiByZXN1bHRzLmZpbmlzaGVkKVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmluc2VydE1hdGNoKGZpbHRlcmVkWzBdKTtcblxuICAgICAgICAgICAgdGhpcy5vcGVuUG9wdXAodGhpcy5lZGl0b3IsIHByZWZpeCwga2VlcFBvcHVwUG9zaXRpb24pO1xuICAgICAgICB9LmJpbmQodGhpcykpO1xuICAgIH07XG5cbiAgICB0aGlzLmNhbmNlbENvbnRleHRNZW51ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoaXMuZWRpdG9yLiRtb3VzZUhhbmRsZXIuY2FuY2VsQ29udGV4dE1lbnUoKTtcbiAgICB9O1xuXG4gICAgdGhpcy51cGRhdGVEb2NUb29sdGlwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBwb3B1cCA9IHRoaXMucG9wdXA7XG4gICAgICAgIHZhciBhbGwgPSBwb3B1cC5kYXRhO1xuICAgICAgICB2YXIgc2VsZWN0ZWQgPSBhbGwgJiYgKGFsbFtwb3B1cC5nZXRIb3ZlcmVkUm93KCldIHx8IGFsbFtwb3B1cC5nZXRSb3coKV0pO1xuICAgICAgICB2YXIgZG9jID0gbnVsbDtcbiAgICAgICAgaWYgKCFzZWxlY3RlZCB8fCAhdGhpcy5lZGl0b3IgfHwgIXRoaXMucG9wdXAuaXNPcGVuKVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGlkZURvY1Rvb2x0aXAoKTtcbiAgICAgICAgdGhpcy5lZGl0b3IuY29tcGxldGVycy5zb21lKGZ1bmN0aW9uKGNvbXBsZXRlcikge1xuICAgICAgICAgICAgaWYgKGNvbXBsZXRlci5nZXREb2NUb29sdGlwKVxuICAgICAgICAgICAgICAgIGRvYyA9IGNvbXBsZXRlci5nZXREb2NUb29sdGlwKHNlbGVjdGVkKTtcbiAgICAgICAgICAgIHJldHVybiBkb2M7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWRvYyAmJiB0eXBlb2Ygc2VsZWN0ZWQgIT0gXCJzdHJpbmdcIilcbiAgICAgICAgICAgIGRvYyA9IHNlbGVjdGVkO1xuXG4gICAgICAgIGlmICh0eXBlb2YgZG9jID09IFwic3RyaW5nXCIpXG4gICAgICAgICAgICBkb2MgPSB7ZG9jVGV4dDogZG9jfTtcbiAgICAgICAgaWYgKCFkb2MgfHwgIShkb2MuZG9jSFRNTCB8fCBkb2MuZG9jVGV4dCkpXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oaWRlRG9jVG9vbHRpcCgpO1xuICAgICAgICB0aGlzLnNob3dEb2NUb29sdGlwKGRvYyk7XG4gICAgfTtcblxuICAgIHRoaXMuc2hvd0RvY1Rvb2x0aXAgPSBmdW5jdGlvbihpdGVtKSB7XG4gICAgICAgIGlmICghdGhpcy50b29sdGlwTm9kZSkge1xuICAgICAgICAgICAgdGhpcy50b29sdGlwTm9kZSA9IGRvbS5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgICAgICAgdGhpcy50b29sdGlwTm9kZS5jbGFzc05hbWUgPSBcImFjZV90b29sdGlwIGFjZV9kb2MtdG9vbHRpcFwiO1xuICAgICAgICAgICAgdGhpcy50b29sdGlwTm9kZS5zdHlsZS5tYXJnaW4gPSAwO1xuICAgICAgICAgICAgdGhpcy50b29sdGlwTm9kZS5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJhdXRvXCI7XG4gICAgICAgICAgICB0aGlzLnRvb2x0aXBOb2RlLnRhYkluZGV4ID0gLTE7XG4gICAgICAgICAgICB0aGlzLnRvb2x0aXBOb2RlLm9uYmx1ciA9IHRoaXMuYmx1ckxpc3RlbmVyLmJpbmQodGhpcyk7XG4gICAgICAgICAgICB0aGlzLnRvb2x0aXBOb2RlLm9uY2xpY2sgPSB0aGlzLm9uVG9vbHRpcENsaWNrLmJpbmQodGhpcyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdG9vbHRpcE5vZGUgPSB0aGlzLnRvb2x0aXBOb2RlO1xuICAgICAgICBpZiAoaXRlbS5kb2NIVE1MKSB7XG4gICAgICAgICAgICB0b29sdGlwTm9kZS5pbm5lckhUTUwgPSBpdGVtLmRvY0hUTUw7XG4gICAgICAgIH0gZWxzZSBpZiAoaXRlbS5kb2NUZXh0KSB7XG4gICAgICAgICAgICB0b29sdGlwTm9kZS50ZXh0Q29udGVudCA9IGl0ZW0uZG9jVGV4dDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghdG9vbHRpcE5vZGUucGFyZW50Tm9kZSlcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodG9vbHRpcE5vZGUpO1xuICAgICAgICB2YXIgcG9wdXAgPSB0aGlzLnBvcHVwO1xuICAgICAgICB2YXIgcmVjdCA9IHBvcHVwLmNvbnRhaW5lci5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgICAgdG9vbHRpcE5vZGUuc3R5bGUudG9wID0gcG9wdXAuY29udGFpbmVyLnN0eWxlLnRvcDtcbiAgICAgICAgdG9vbHRpcE5vZGUuc3R5bGUuYm90dG9tID0gcG9wdXAuY29udGFpbmVyLnN0eWxlLmJvdHRvbTtcblxuICAgICAgICB0b29sdGlwTm9kZS5zdHlsZS5kaXNwbGF5ID0gXCJibG9ja1wiO1xuICAgICAgICBpZiAod2luZG93LmlubmVyV2lkdGggLSByZWN0LnJpZ2h0IDwgMzIwKSB7XG4gICAgICAgICAgICBpZiAocmVjdC5sZWZ0IDwgMzIwKSB7XG4gICAgICAgICAgICAgICAgaWYocG9wdXAuaXNUb3Bkb3duKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXBOb2RlLnN0eWxlLnRvcCA9IHJlY3QuYm90dG9tICsgXCJweFwiO1xuICAgICAgICAgICAgICAgICAgICB0b29sdGlwTm9kZS5zdHlsZS5sZWZ0ID0gcmVjdC5sZWZ0ICsgXCJweFwiO1xuICAgICAgICAgICAgICAgICAgICB0b29sdGlwTm9kZS5zdHlsZS5yaWdodCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIHRvb2x0aXBOb2RlLnN0eWxlLmJvdHRvbSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9vbHRpcE5vZGUuc3R5bGUudG9wID0gcG9wdXAuY29udGFpbmVyLm9mZnNldFRvcCAtIHRvb2x0aXBOb2RlLm9mZnNldEhlaWdodCArIFwicHhcIjtcbiAgICAgICAgICAgICAgICAgICAgdG9vbHRpcE5vZGUuc3R5bGUubGVmdCA9IHJlY3QubGVmdCArIFwicHhcIjtcbiAgICAgICAgICAgICAgICAgICAgdG9vbHRpcE5vZGUuc3R5bGUucmlnaHQgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICB0b29sdGlwTm9kZS5zdHlsZS5ib3R0b20gPSBcIlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9vbHRpcE5vZGUuc3R5bGUucmlnaHQgPSB3aW5kb3cuaW5uZXJXaWR0aCAtIHJlY3QubGVmdCArIFwicHhcIjtcbiAgICAgICAgICAgICAgICB0b29sdGlwTm9kZS5zdHlsZS5sZWZ0ID0gXCJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRvb2x0aXBOb2RlLnN0eWxlLmxlZnQgPSAocmVjdC5yaWdodCArIDEpICsgXCJweFwiO1xuICAgICAgICAgICAgdG9vbHRpcE5vZGUuc3R5bGUucmlnaHQgPSBcIlwiO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuaGlkZURvY1Rvb2x0aXAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhpcy50b29sdGlwVGltZXIuY2FuY2VsKCk7XG4gICAgICAgIGlmICghdGhpcy50b29sdGlwTm9kZSkgcmV0dXJuO1xuICAgICAgICB2YXIgZWwgPSB0aGlzLnRvb2x0aXBOb2RlO1xuICAgICAgICBpZiAoIXRoaXMuZWRpdG9yLmlzRm9jdXNlZCgpICYmIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT0gZWwpXG4gICAgICAgICAgICB0aGlzLmVkaXRvci5mb2N1cygpO1xuICAgICAgICB0aGlzLnRvb2x0aXBOb2RlID0gbnVsbDtcbiAgICAgICAgaWYgKGVsLnBhcmVudE5vZGUpXG4gICAgICAgICAgICBlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGVsKTtcbiAgICB9O1xuICAgIFxuICAgIHRoaXMub25Ub29sdGlwQ2xpY2sgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIHZhciBhID0gZS50YXJnZXQ7XG4gICAgICAgIHdoaWxlIChhICYmIGEgIT0gdGhpcy50b29sdGlwTm9kZSkge1xuICAgICAgICAgICAgaWYgKGEubm9kZU5hbWUgPT0gXCJBXCIgJiYgYS5ocmVmKSB7XG4gICAgICAgICAgICAgICAgYS5yZWwgPSBcIm5vcmVmZXJyZXJcIjtcbiAgICAgICAgICAgICAgICBhLnRhcmdldCA9IFwiX2JsYW5rXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhID0gYS5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIHRoaXMuZGVzdHJveSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGlzLmRldGFjaCgpO1xuICAgICAgICBpZiAodGhpcy5wb3B1cCkge1xuICAgICAgICAgICAgdGhpcy5wb3B1cC5kZXN0cm95KCk7XG4gICAgICAgICAgICB2YXIgZWwgPSB0aGlzLnBvcHVwLmNvbnRhaW5lcjtcbiAgICAgICAgICAgIGlmIChlbCAmJiBlbC5wYXJlbnROb2RlKVxuICAgICAgICAgICAgICAgIGVsLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoZWwpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmVkaXRvciAmJiB0aGlzLmVkaXRvci5jb21wbGV0ZXIgPT0gdGhpcylcbiAgICAgICAgICAgIHRoaXMuZWRpdG9yLmNvbXBsZXRlciA9PSBudWxsO1xuICAgICAgICB0aGlzLnBvcHVwID0gbnVsbDtcbiAgICB9O1xuXG59KS5jYWxsKEF1dG9jb21wbGV0ZS5wcm90b3R5cGUpO1xuXG5cbkF1dG9jb21wbGV0ZS5mb3IgPSBmdW5jdGlvbihlZGl0b3IpIHtcbiAgICBpZiAoZWRpdG9yLmNvbXBsZXRlcikge1xuICAgICAgICByZXR1cm4gZWRpdG9yLmNvbXBsZXRlcjtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5nZXQoXCJzaGFyZWRQb3B1cHNcIikpIHtcbiAgICAgICAgaWYgKCFBdXRvY29tcGxldGUuJHNoYXJlZClcbiAgICAgICAgICAgIEF1dG9jb21wbGV0ZS4kc2hhcmVkSW5zdGFuY2UgPSBuZXcgQXV0b2NvbXBsZXRlKCk7XG4gICAgICAgIGVkaXRvci5jb21wbGV0ZXIgPSBBdXRvY29tcGxldGUuJHNoYXJlZEluc3RhbmNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGVkaXRvci5jb21wbGV0ZXIgPSBuZXcgQXV0b2NvbXBsZXRlKCk7XG4gICAgICAgIGVkaXRvci5vbmNlKFwiZGVzdHJveVwiLCBmdW5jdGlvbihlLCBlZGl0b3IpIHtcbiAgICAgICAgICAgIGVkaXRvci5jb21wbGV0ZXIuZGVzdHJveSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGVkaXRvci5jb21wbGV0ZXI7XG59O1xuXG5BdXRvY29tcGxldGUuc3RhcnRDb21tYW5kID0ge1xuICAgIG5hbWU6IFwic3RhcnRBdXRvY29tcGxldGVcIixcbiAgICBleGVjOiBmdW5jdGlvbihlZGl0b3IsIG9wdGlvbnMpIHtcbiAgICAgICAgdmFyIGNvbXBsZXRlciA9IEF1dG9jb21wbGV0ZS5mb3IoZWRpdG9yKTtcbiAgICAgICAgY29tcGxldGVyLmF1dG9JbnNlcnQgPSBmYWxzZTtcbiAgICAgICAgY29tcGxldGVyLmF1dG9TZWxlY3QgPSB0cnVlO1xuICAgICAgICBjb21wbGV0ZXIuc2hvd1BvcHVwKGVkaXRvciwgb3B0aW9ucyk7XG4gICAgICAgIGNvbXBsZXRlci5jYW5jZWxDb250ZXh0TWVudSgpO1xuICAgIH0sXG4gICAgYmluZEtleTogXCJDdHJsLVNwYWNlfEN0cmwtU2hpZnQtU3BhY2V8QWx0LVNwYWNlXCJcbn07XG5cbnZhciBGaWx0ZXJlZExpc3QgPSBmdW5jdGlvbihhcnJheSwgZmlsdGVyVGV4dCkge1xuICAgIHRoaXMuYWxsID0gYXJyYXk7XG4gICAgdGhpcy5maWx0ZXJlZCA9IGFycmF5O1xuICAgIHRoaXMuZmlsdGVyVGV4dCA9IGZpbHRlclRleHQgfHwgXCJcIjtcbiAgICB0aGlzLmV4YWN0TWF0Y2ggPSBmYWxzZTtcbn07XG4oZnVuY3Rpb24oKXtcbiAgICB0aGlzLnNldEZpbHRlciA9IGZ1bmN0aW9uKHN0cikge1xuICAgICAgICBpZiAoc3RyLmxlbmd0aCA+IHRoaXMuZmlsdGVyVGV4dCAmJiBzdHIubGFzdEluZGV4T2YodGhpcy5maWx0ZXJUZXh0LCAwKSA9PT0gMClcbiAgICAgICAgICAgIHZhciBtYXRjaGVzID0gdGhpcy5maWx0ZXJlZDtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgdmFyIG1hdGNoZXMgPSB0aGlzLmFsbDtcblxuICAgICAgICB0aGlzLmZpbHRlclRleHQgPSBzdHI7XG4gICAgICAgIG1hdGNoZXMgPSB0aGlzLmZpbHRlckNvbXBsZXRpb25zKG1hdGNoZXMsIHRoaXMuZmlsdGVyVGV4dCk7XG4gICAgICAgIG1hdGNoZXMgPSBtYXRjaGVzLnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgICAgICAgICAgcmV0dXJuIGIuZXhhY3RNYXRjaCAtIGEuZXhhY3RNYXRjaCB8fCBiLiRzY29yZSAtIGEuJHNjb3JlIFxuICAgICAgICAgICAgICAgIHx8IChhLmNhcHRpb24gfHwgYS52YWx1ZSkubG9jYWxlQ29tcGFyZShiLmNhcHRpb24gfHwgYi52YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgcHJldiA9IG51bGw7XG4gICAgICAgIG1hdGNoZXMgPSBtYXRjaGVzLmZpbHRlcihmdW5jdGlvbihpdGVtKXtcbiAgICAgICAgICAgIHZhciBjYXB0aW9uID0gaXRlbS5zbmlwcGV0IHx8IGl0ZW0uY2FwdGlvbiB8fCBpdGVtLnZhbHVlO1xuICAgICAgICAgICAgaWYgKGNhcHRpb24gPT09IHByZXYpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHByZXYgPSBjYXB0aW9uO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuZmlsdGVyZWQgPSBtYXRjaGVzO1xuICAgIH07XG4gICAgdGhpcy5maWx0ZXJDb21wbGV0aW9ucyA9IGZ1bmN0aW9uKGl0ZW1zLCBuZWVkbGUpIHtcbiAgICAgICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICAgICAgdmFyIHVwcGVyID0gbmVlZGxlLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIHZhciBsb3dlciA9IG5lZWRsZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBsb29wOiBmb3IgKHZhciBpID0gMCwgaXRlbTsgaXRlbSA9IGl0ZW1zW2ldOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjYXB0aW9uID0gaXRlbS5jYXB0aW9uIHx8IGl0ZW0udmFsdWUgfHwgaXRlbS5zbmlwcGV0O1xuICAgICAgICAgICAgaWYgKCFjYXB0aW9uKSBjb250aW51ZTtcbiAgICAgICAgICAgIHZhciBsYXN0SW5kZXggPSAtMTtcbiAgICAgICAgICAgIHZhciBtYXRjaE1hc2sgPSAwO1xuICAgICAgICAgICAgdmFyIHBlbmFsdHkgPSAwO1xuICAgICAgICAgICAgdmFyIGluZGV4LCBkaXN0YW5jZTtcblxuICAgICAgICAgICAgaWYgKHRoaXMuZXhhY3RNYXRjaCkge1xuICAgICAgICAgICAgICAgIGlmIChuZWVkbGUgIT09IGNhcHRpb24uc3Vic3RyKDAsIG5lZWRsZS5sZW5ndGgpKVxuICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBsb29wO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgZnVsbE1hdGNoSW5kZXggPSBjYXB0aW9uLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihsb3dlcik7XG4gICAgICAgICAgICAgICAgaWYgKGZ1bGxNYXRjaEluZGV4ID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcGVuYWx0eSA9IGZ1bGxNYXRjaEluZGV4O1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbmVlZGxlLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaTEgPSBjYXB0aW9uLmluZGV4T2YobG93ZXJbal0sIGxhc3RJbmRleCArIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGkyID0gY2FwdGlvbi5pbmRleE9mKHVwcGVyW2pdLCBsYXN0SW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZGV4ID0gKGkxID49IDApID8gKChpMiA8IDAgfHwgaTEgPCBpMikgPyBpMSA6IGkyKSA6IGkyO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGluZGV4IDwgMClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZSBsb29wO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBpbmRleCAtIGxhc3RJbmRleCAtIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGlzdGFuY2UgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RJbmRleCA9PT0gLTEpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBlbmFsdHkgKz0gMTA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGVuYWx0eSArPSBkaXN0YW5jZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaE1hc2sgPSBtYXRjaE1hc2sgfCAoMSA8PCBqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RJbmRleCA9IGluZGV4O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaXRlbS5tYXRjaE1hc2sgPSBtYXRjaE1hc2s7XG4gICAgICAgICAgICBpdGVtLmV4YWN0TWF0Y2ggPSBwZW5hbHR5ID8gMCA6IDE7XG4gICAgICAgICAgICBpdGVtLiRzY29yZSA9IChpdGVtLnNjb3JlIHx8IDApIC0gcGVuYWx0eTtcbiAgICAgICAgICAgIHJlc3VsdHMucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0cztcbiAgICB9O1xufSkuY2FsbChGaWx0ZXJlZExpc3QucHJvdG90eXBlKTtcblxuZXhwb3J0cy5BdXRvY29tcGxldGUgPSBBdXRvY29tcGxldGU7XG5leHBvcnRzLkZpbHRlcmVkTGlzdCA9IEZpbHRlcmVkTGlzdDtcblxufSk7XG5cbmFjZS5kZWZpbmUoXCJhY2UvYXV0b2NvbXBsZXRlL3RleHRfY29tcGxldGVyXCIsW1wicmVxdWlyZVwiLFwiZXhwb3J0c1wiLFwibW9kdWxlXCIsXCJhY2UvcmFuZ2VcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuICAgIHZhciBSYW5nZSA9IHJlcXVpcmUoXCIuLi9yYW5nZVwiKS5SYW5nZTtcbiAgICBcbiAgICB2YXIgc3BsaXRSZWdleCA9IC9bXmEtekEtWl8wLTlcXCRcXC1cXHUwMEMwLVxcdTFGRkZcXHUyQzAwLVxcdUQ3RkZcXHddKy87XG5cbiAgICBmdW5jdGlvbiBnZXRXb3JkSW5kZXgoZG9jLCBwb3MpIHtcbiAgICAgICAgdmFyIHRleHRCZWZvcmUgPSBkb2MuZ2V0VGV4dFJhbmdlKFJhbmdlLmZyb21Qb2ludHMoe3JvdzogMCwgY29sdW1uOjB9LCBwb3MpKTtcbiAgICAgICAgcmV0dXJuIHRleHRCZWZvcmUuc3BsaXQoc3BsaXRSZWdleCkubGVuZ3RoIC0gMTtcbiAgICB9XG4gICAgZnVuY3Rpb24gd29yZERpc3RhbmNlKGRvYywgcG9zKSB7XG4gICAgICAgIHZhciBwcmVmaXhQb3MgPSBnZXRXb3JkSW5kZXgoZG9jLCBwb3MpO1xuICAgICAgICB2YXIgd29yZHMgPSBkb2MuZ2V0VmFsdWUoKS5zcGxpdChzcGxpdFJlZ2V4KTtcbiAgICAgICAgdmFyIHdvcmRTY29yZXMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICBcbiAgICAgICAgdmFyIGN1cnJlbnRXb3JkID0gd29yZHNbcHJlZml4UG9zXTtcblxuICAgICAgICB3b3Jkcy5mb3JFYWNoKGZ1bmN0aW9uKHdvcmQsIGlkeCkge1xuICAgICAgICAgICAgaWYgKCF3b3JkIHx8IHdvcmQgPT09IGN1cnJlbnRXb3JkKSByZXR1cm47XG5cbiAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IE1hdGguYWJzKHByZWZpeFBvcyAtIGlkeCk7XG4gICAgICAgICAgICB2YXIgc2NvcmUgPSB3b3Jkcy5sZW5ndGggLSBkaXN0YW5jZTtcbiAgICAgICAgICAgIGlmICh3b3JkU2NvcmVzW3dvcmRdKSB7XG4gICAgICAgICAgICAgICAgd29yZFNjb3Jlc1t3b3JkXSA9IE1hdGgubWF4KHNjb3JlLCB3b3JkU2NvcmVzW3dvcmRdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgd29yZFNjb3Jlc1t3b3JkXSA9IHNjb3JlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHdvcmRTY29yZXM7XG4gICAgfVxuXG4gICAgZXhwb3J0cy5nZXRDb21wbGV0aW9ucyA9IGZ1bmN0aW9uKGVkaXRvciwgc2Vzc2lvbiwgcG9zLCBwcmVmaXgsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciB3b3JkU2NvcmUgPSB3b3JkRGlzdGFuY2Uoc2Vzc2lvbiwgcG9zKTtcbiAgICAgICAgdmFyIHdvcmRMaXN0ID0gT2JqZWN0LmtleXMod29yZFNjb3JlKTtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgd29yZExpc3QubWFwKGZ1bmN0aW9uKHdvcmQpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgY2FwdGlvbjogd29yZCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogd29yZCxcbiAgICAgICAgICAgICAgICBzY29yZTogd29yZFNjb3JlW3dvcmRdLFxuICAgICAgICAgICAgICAgIG1ldGE6IFwibG9jYWxcIlxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSkpO1xuICAgIH07XG59KTtcblxuYWNlLmRlZmluZShcImFjZS9leHQvbGFuZ3VhZ2VfdG9vbHNcIixbXCJyZXF1aXJlXCIsXCJleHBvcnRzXCIsXCJtb2R1bGVcIixcImFjZS9zbmlwcGV0c1wiLFwiYWNlL2F1dG9jb21wbGV0ZVwiLFwiYWNlL2NvbmZpZ1wiLFwiYWNlL2xpYi9sYW5nXCIsXCJhY2UvYXV0b2NvbXBsZXRlL3V0aWxcIixcImFjZS9hdXRvY29tcGxldGUvdGV4dF9jb21wbGV0ZXJcIixcImFjZS9lZGl0b3JcIixcImFjZS9jb25maWdcIl0sIGZ1bmN0aW9uKHJlcXVpcmUsIGV4cG9ydHMsIG1vZHVsZSkge1xuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBzbmlwcGV0TWFuYWdlciA9IHJlcXVpcmUoXCIuLi9zbmlwcGV0c1wiKS5zbmlwcGV0TWFuYWdlcjtcbnZhciBBdXRvY29tcGxldGUgPSByZXF1aXJlKFwiLi4vYXV0b2NvbXBsZXRlXCIpLkF1dG9jb21wbGV0ZTtcbnZhciBjb25maWcgPSByZXF1aXJlKFwiLi4vY29uZmlnXCIpO1xudmFyIGxhbmcgPSByZXF1aXJlKFwiLi4vbGliL2xhbmdcIik7XG52YXIgdXRpbCA9IHJlcXVpcmUoXCIuLi9hdXRvY29tcGxldGUvdXRpbFwiKTtcblxudmFyIHRleHRDb21wbGV0ZXIgPSByZXF1aXJlKFwiLi4vYXV0b2NvbXBsZXRlL3RleHRfY29tcGxldGVyXCIpO1xudmFyIGtleVdvcmRDb21wbGV0ZXIgPSB7XG4gICAgZ2V0Q29tcGxldGlvbnM6IGZ1bmN0aW9uKGVkaXRvciwgc2Vzc2lvbiwgcG9zLCBwcmVmaXgsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChzZXNzaW9uLiRtb2RlLmNvbXBsZXRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHNlc3Npb24uJG1vZGUuY29tcGxldGVyLmdldENvbXBsZXRpb25zKGVkaXRvciwgc2Vzc2lvbiwgcG9zLCBwcmVmaXgsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc3RhdGUgPSBlZGl0b3Iuc2Vzc2lvbi5nZXRTdGF0ZShwb3Mucm93KTtcbiAgICAgICAgdmFyIGNvbXBsZXRpb25zID0gc2Vzc2lvbi4kbW9kZS5nZXRDb21wbGV0aW9ucyhzdGF0ZSwgc2Vzc2lvbiwgcG9zLCBwcmVmaXgpO1xuICAgICAgICBjYWxsYmFjayhudWxsLCBjb21wbGV0aW9ucyk7XG4gICAgfVxufTtcblxudmFyIHNuaXBwZXRDb21wbGV0ZXIgPSB7XG4gICAgZ2V0Q29tcGxldGlvbnM6IGZ1bmN0aW9uKGVkaXRvciwgc2Vzc2lvbiwgcG9zLCBwcmVmaXgsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBzY29wZXMgPSBbXTtcbiAgICAgICAgdmFyIHRva2VuID0gc2Vzc2lvbi5nZXRUb2tlbkF0KHBvcy5yb3csIHBvcy5jb2x1bW4pO1xuICAgICAgICBpZiAodG9rZW4gJiYgdG9rZW4udHlwZS5tYXRjaCgvKHRhZy1uYW1lfHRhZy1vcGVufHRhZy13aGl0ZXNwYWNlfGF0dHJpYnV0ZS1uYW1lfGF0dHJpYnV0ZS12YWx1ZSlcXC54bWwkLykpXG4gICAgICAgICAgICBzY29wZXMucHVzaCgnaHRtbC10YWcnKTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgICAgc2NvcGVzID0gc25pcHBldE1hbmFnZXIuZ2V0QWN0aXZlU2NvcGVzKGVkaXRvcik7XG5cbiAgICAgICAgdmFyIHNuaXBwZXRNYXAgPSBzbmlwcGV0TWFuYWdlci5zbmlwcGV0TWFwO1xuICAgICAgICB2YXIgY29tcGxldGlvbnMgPSBbXTtcbiAgICAgICAgc2NvcGVzLmZvckVhY2goZnVuY3Rpb24oc2NvcGUpIHtcbiAgICAgICAgICAgIHZhciBzbmlwcGV0cyA9IHNuaXBwZXRNYXBbc2NvcGVdIHx8IFtdO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IHNuaXBwZXRzLmxlbmd0aDsgaS0tOykge1xuICAgICAgICAgICAgICAgIHZhciBzID0gc25pcHBldHNbaV07XG4gICAgICAgICAgICAgICAgdmFyIGNhcHRpb24gPSBzLm5hbWUgfHwgcy50YWJUcmlnZ2VyO1xuICAgICAgICAgICAgICAgIGlmICghY2FwdGlvbilcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgY29tcGxldGlvbnMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGNhcHRpb246IGNhcHRpb24sXG4gICAgICAgICAgICAgICAgICAgIHNuaXBwZXQ6IHMuY29udGVudCxcbiAgICAgICAgICAgICAgICAgICAgbWV0YTogcy50YWJUcmlnZ2VyICYmICFzLm5hbWUgPyBzLnRhYlRyaWdnZXIgKyBcIlxcdTIxRTUgXCIgOiBcInNuaXBwZXRcIixcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJzbmlwcGV0XCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgdGhpcyk7XG4gICAgICAgIGNhbGxiYWNrKG51bGwsIGNvbXBsZXRpb25zKTtcbiAgICB9LFxuICAgIGdldERvY1Rvb2x0aXA6IGZ1bmN0aW9uKGl0ZW0pIHtcbiAgICAgICAgaWYgKGl0ZW0udHlwZSA9PSBcInNuaXBwZXRcIiAmJiAhaXRlbS5kb2NIVE1MKSB7XG4gICAgICAgICAgICBpdGVtLmRvY0hUTUwgPSBbXG4gICAgICAgICAgICAgICAgXCI8Yj5cIiwgbGFuZy5lc2NhcGVIVE1MKGl0ZW0uY2FwdGlvbiksIFwiPC9iPlwiLCBcIjxocj48L2hyPlwiLFxuICAgICAgICAgICAgICAgIGxhbmcuZXNjYXBlSFRNTChpdGVtLnNuaXBwZXQpXG4gICAgICAgICAgICBdLmpvaW4oXCJcIik7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgY29tcGxldGVycyA9IFtzbmlwcGV0Q29tcGxldGVyLCB0ZXh0Q29tcGxldGVyLCBrZXlXb3JkQ29tcGxldGVyXTtcbmV4cG9ydHMuc2V0Q29tcGxldGVycyA9IGZ1bmN0aW9uKHZhbCkge1xuICAgIGNvbXBsZXRlcnMubGVuZ3RoID0gMDtcbiAgICBpZiAodmFsKSBjb21wbGV0ZXJzLnB1c2guYXBwbHkoY29tcGxldGVycywgdmFsKTtcbn07XG5leHBvcnRzLmFkZENvbXBsZXRlciA9IGZ1bmN0aW9uKGNvbXBsZXRlcikge1xuICAgIGNvbXBsZXRlcnMucHVzaChjb21wbGV0ZXIpO1xufTtcbmV4cG9ydHMudGV4dENvbXBsZXRlciA9IHRleHRDb21wbGV0ZXI7XG5leHBvcnRzLmtleVdvcmRDb21wbGV0ZXIgPSBrZXlXb3JkQ29tcGxldGVyO1xuZXhwb3J0cy5zbmlwcGV0Q29tcGxldGVyID0gc25pcHBldENvbXBsZXRlcjtcblxudmFyIGV4cGFuZFNuaXBwZXQgPSB7XG4gICAgbmFtZTogXCJleHBhbmRTbmlwcGV0XCIsXG4gICAgZXhlYzogZnVuY3Rpb24oZWRpdG9yKSB7XG4gICAgICAgIHJldHVybiBzbmlwcGV0TWFuYWdlci5leHBhbmRXaXRoVGFiKGVkaXRvcik7XG4gICAgfSxcbiAgICBiaW5kS2V5OiBcIlRhYlwiXG59O1xuXG52YXIgb25DaGFuZ2VNb2RlID0gZnVuY3Rpb24oZSwgZWRpdG9yKSB7XG4gICAgbG9hZFNuaXBwZXRzRm9yTW9kZShlZGl0b3Iuc2Vzc2lvbi4kbW9kZSk7XG59O1xuXG52YXIgbG9hZFNuaXBwZXRzRm9yTW9kZSA9IGZ1bmN0aW9uKG1vZGUpIHtcbiAgICBpZiAodHlwZW9mIG1vZGUgPT0gXCJzdHJpbmdcIilcbiAgICAgICAgbW9kZSA9IGNvbmZpZy4kbW9kZXNbbW9kZV07XG4gICAgaWYgKCFtb2RlKVxuICAgICAgICByZXR1cm47XG4gICAgaWYgKCFzbmlwcGV0TWFuYWdlci5maWxlcylcbiAgICAgICAgc25pcHBldE1hbmFnZXIuZmlsZXMgPSB7fTtcbiAgICBcbiAgICBsb2FkU25pcHBldEZpbGUobW9kZS4kaWQsIG1vZGUuc25pcHBldEZpbGVJZCk7XG4gICAgaWYgKG1vZGUubW9kZXMpXG4gICAgICAgIG1vZGUubW9kZXMuZm9yRWFjaChsb2FkU25pcHBldHNGb3JNb2RlKTtcbn07XG5cbnZhciBsb2FkU25pcHBldEZpbGUgPSBmdW5jdGlvbihpZCwgc25pcHBldEZpbGVQYXRoKSB7XG4gICAgaWYgKCFzbmlwcGV0RmlsZVBhdGggfHwgIWlkIHx8IHNuaXBwZXRNYW5hZ2VyLmZpbGVzW2lkXSlcbiAgICAgICAgcmV0dXJuO1xuICAgIHNuaXBwZXRNYW5hZ2VyLmZpbGVzW2lkXSA9IHt9O1xuICAgIGNvbmZpZy5sb2FkTW9kdWxlKHNuaXBwZXRGaWxlUGF0aCwgZnVuY3Rpb24obSkge1xuICAgICAgICBpZiAoIW0pIHJldHVybjtcbiAgICAgICAgc25pcHBldE1hbmFnZXIuZmlsZXNbaWRdID0gbTtcbiAgICAgICAgaWYgKCFtLnNuaXBwZXRzICYmIG0uc25pcHBldFRleHQpXG4gICAgICAgICAgICBtLnNuaXBwZXRzID0gc25pcHBldE1hbmFnZXIucGFyc2VTbmlwcGV0RmlsZShtLnNuaXBwZXRUZXh0KTtcbiAgICAgICAgc25pcHBldE1hbmFnZXIucmVnaXN0ZXIobS5zbmlwcGV0cyB8fCBbXSwgbS5zY29wZSk7XG4gICAgICAgIGlmIChtLmluY2x1ZGVTY29wZXMpIHtcbiAgICAgICAgICAgIHNuaXBwZXRNYW5hZ2VyLnNuaXBwZXRNYXBbbS5zY29wZV0uaW5jbHVkZVNjb3BlcyA9IG0uaW5jbHVkZVNjb3BlcztcbiAgICAgICAgICAgIG0uaW5jbHVkZVNjb3Blcy5mb3JFYWNoKGZ1bmN0aW9uKHgpIHtcbiAgICAgICAgICAgICAgICBsb2FkU25pcHBldHNGb3JNb2RlKFwiYWNlL21vZGUvXCIgKyB4KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfSk7XG59O1xuXG52YXIgZG9MaXZlQXV0b2NvbXBsZXRlID0gZnVuY3Rpb24oZSkge1xuICAgIHZhciBlZGl0b3IgPSBlLmVkaXRvcjtcbiAgICB2YXIgaGFzQ29tcGxldGVyID0gZWRpdG9yLmNvbXBsZXRlciAmJiBlZGl0b3IuY29tcGxldGVyLmFjdGl2YXRlZDtcbiAgICBpZiAoZS5jb21tYW5kLm5hbWUgPT09IFwiYmFja3NwYWNlXCIpIHtcbiAgICAgICAgaWYgKGhhc0NvbXBsZXRlciAmJiAhdXRpbC5nZXRDb21wbGV0aW9uUHJlZml4KGVkaXRvcikpXG4gICAgICAgICAgICBlZGl0b3IuY29tcGxldGVyLmRldGFjaCgpO1xuICAgIH1cbiAgICBlbHNlIGlmIChlLmNvbW1hbmQubmFtZSA9PT0gXCJpbnNlcnRzdHJpbmdcIikge1xuICAgICAgICB2YXIgcHJlZml4ID0gdXRpbC5nZXRDb21wbGV0aW9uUHJlZml4KGVkaXRvcik7XG4gICAgICAgIGlmIChwcmVmaXggJiYgIWhhc0NvbXBsZXRlcikge1xuICAgICAgICAgICAgdmFyIGNvbXBsZXRlciA9IEF1dG9jb21wbGV0ZS5mb3IoZWRpdG9yKTtcbiAgICAgICAgICAgIGNvbXBsZXRlci5hdXRvSW5zZXJ0ID0gZmFsc2U7XG4gICAgICAgICAgICBjb21wbGV0ZXIuc2hvd1BvcHVwKGVkaXRvcik7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG52YXIgRWRpdG9yID0gcmVxdWlyZShcIi4uL2VkaXRvclwiKS5FZGl0b3I7XG5yZXF1aXJlKFwiLi4vY29uZmlnXCIpLmRlZmluZU9wdGlvbnMoRWRpdG9yLnByb3RvdHlwZSwgXCJlZGl0b3JcIiwge1xuICAgIGVuYWJsZUJhc2ljQXV0b2NvbXBsZXRpb246IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29tcGxldGVycylcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb21wbGV0ZXJzID0gQXJyYXkuaXNBcnJheSh2YWwpPyB2YWw6IGNvbXBsZXRlcnM7XG4gICAgICAgICAgICAgICAgdGhpcy5jb21tYW5kcy5hZGRDb21tYW5kKEF1dG9jb21wbGV0ZS5zdGFydENvbW1hbmQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbW1hbmRzLnJlbW92ZUNvbW1hbmQoQXV0b2NvbXBsZXRlLnN0YXJ0Q29tbWFuZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0sXG4gICAgZW5hYmxlTGl2ZUF1dG9jb21wbGV0aW9uOiB7XG4gICAgICAgIHNldDogZnVuY3Rpb24odmFsKSB7XG4gICAgICAgICAgICBpZiAodmFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmNvbXBsZXRlcnMpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29tcGxldGVycyA9IEFycmF5LmlzQXJyYXkodmFsKT8gdmFsOiBjb21wbGV0ZXJzO1xuICAgICAgICAgICAgICAgIHRoaXMuY29tbWFuZHMub24oJ2FmdGVyRXhlYycsIGRvTGl2ZUF1dG9jb21wbGV0ZSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY29tbWFuZHMucmVtb3ZlTGlzdGVuZXIoJ2FmdGVyRXhlYycsIGRvTGl2ZUF1dG9jb21wbGV0ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0sXG4gICAgZW5hYmxlU25pcHBldHM6IHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbih2YWwpIHtcbiAgICAgICAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmNvbW1hbmRzLmFkZENvbW1hbmQoZXhwYW5kU25pcHBldCk7XG4gICAgICAgICAgICAgICAgdGhpcy5vbihcImNoYW5nZU1vZGVcIiwgb25DaGFuZ2VNb2RlKTtcbiAgICAgICAgICAgICAgICBvbkNoYW5nZU1vZGUobnVsbCwgdGhpcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuY29tbWFuZHMucmVtb3ZlQ29tbWFuZChleHBhbmRTbmlwcGV0KTtcbiAgICAgICAgICAgICAgICB0aGlzLm9mZihcImNoYW5nZU1vZGVcIiwgb25DaGFuZ2VNb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfVxufSk7XG59KTsgICAgICAgICAgICAgICAgKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBhY2UucmVxdWlyZShbXCJhY2UvZXh0L2xhbmd1YWdlX3Rvb2xzXCJdLCBmdW5jdGlvbihtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1vZHVsZSA9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIgJiYgbW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBtO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KSgpO1xuICAgICAgICAgICAgIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/ace-builds/src-noconflict/ext-language_tools.js\n");

/***/ }),

/***/ "./src/components/Editor/index.js":
/*!****************************************!*\
  !*** ./src/components/Editor/index.js ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* WEBPACK VAR INJECTION */(function(module) {/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_ace__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-ace */ \"./node_modules/react-ace/lib/index.js\");\n/* harmony import */ var react_ace__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_ace__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var ace_builds_src_noconflict_mode_mysql__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ace-builds/src-noconflict/mode-mysql */ \"./node_modules/ace-builds/src-noconflict/mode-mysql.js\");\n/* harmony import */ var ace_builds_src_noconflict_mode_mysql__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(ace_builds_src_noconflict_mode_mysql__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var ace_builds_src_noconflict_theme_monokai__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ace-builds/src-noconflict/theme-monokai */ \"./node_modules/ace-builds/src-noconflict/theme-monokai.js\");\n/* harmony import */ var ace_builds_src_noconflict_theme_monokai__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(ace_builds_src_noconflict_theme_monokai__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var ace_builds_src_noconflict_ext_language_tools__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ace-builds/src-noconflict/ext-language_tools */ \"./node_modules/ace-builds/src-noconflict/ext-language_tools.js\");\n/* harmony import */ var ace_builds_src_noconflict_ext_language_tools__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(ace_builds_src_noconflict_ext_language_tools__WEBPACK_IMPORTED_MODULE_5__);\n\n\nvar _jsxFileName = \"/home/tuanquang/admin_ssr/src/components/Editor/index.js\",\n    _this = undefined,\n    _s = $RefreshSig$();\n\n\n\n\n\n\n\nvar Editor = function Editor(props) {\n  _s();\n\n  var _useState = Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useState\"])(''),\n      data = _useState[0],\n      setData = _useState[1];\n\n  Object(react__WEBPACK_IMPORTED_MODULE_1__[\"useEffect\"])(function () {\n    window.addEventListener('message', function (event) {\n      if (event) {\n        setData(localStorage.getItem('json-diagram'));\n      }\n    }, false);\n  }, []);\n  return /*#__PURE__*/Object(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__[\"jsxDEV\"])(react_ace__WEBPACK_IMPORTED_MODULE_2___default.a, {\n    placeholder: \"Placeholder Text\",\n    mode: \"mysql\",\n    theme: \"monokai\",\n    name: \"blah2\",\n    width: \"100%\",\n    height: \"100%\" //   onLoad={this.onLoad}\n    //   onChange={this.onChange}\n    ,\n    fontSize: 14,\n    showPrintMargin: true,\n    showGutter: true,\n    highlightActiveLine: true,\n    value: data,\n    setOptions: {\n      enableBasicAutocompletion: true,\n      enableLiveAutocompletion: true,\n      enableSnippets: true,\n      showLineNumbers: true,\n      tabSize: 2\n    }\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 24,\n    columnNumber: 5\n  }, _this);\n};\n\n_s(Editor, \"VZqd8eS65aqgHhr94QvD8B0VC/4=\");\n\n_c = Editor;\n/* harmony default export */ __webpack_exports__[\"default\"] = (Editor);\n\nvar _c;\n\n$RefreshReg$(_c, \"Editor\");\n\n;\n    var _a, _b;\n    // Legacy CSS implementations will `eval` browser code in a Node.js context\n    // to extract CSS. For backwards compatibility, we need to check we're in a\n    // browser context before continuing.\n    if (typeof self !== 'undefined' &&\n        // AMP / No-JS mode does not inject these helpers:\n        '$RefreshHelpers$' in self) {\n        var currentExports = module.__proto__.exports;\n        var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n        // This cannot happen in MainTemplate because the exports mismatch between\n        // templating and execution.\n        self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.i);\n        // A module can be accepted automatically based on its exports, e.g. when\n        // it is a Refresh Boundary.\n        if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n            // Save the previous exports on update so we can compare the boundary\n            // signatures.\n            module.hot.dispose(function (data) {\n                data.prevExports = currentExports;\n            });\n            // Unconditionally accept an update to this module, we'll check if it's\n            // still a Refresh Boundary later.\n            module.hot.accept();\n            // This field is set when the previous version of this module was a\n            // Refresh Boundary, letting us know we need to check for invalidation or\n            // enqueue an update.\n            if (prevExports !== null) {\n                // A boundary can become ineligible if its exports are incompatible\n                // with the previous exports.\n                //\n                // For example, if you add/remove/change exports, we'll want to\n                // re-execute the importing modules, and force those components to\n                // re-render. Similarly, if you convert a class component to a\n                // function, we want to invalidate the boundary.\n                if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                    module.hot.invalidate();\n                }\n                else {\n                    self.$RefreshHelpers$.scheduleUpdate();\n                }\n            }\n        }\n        else {\n            // Since we just executed the code for the module, it's possible that the\n            // new exports made it ineligible for being a boundary.\n            // We only care about the case when we were _previously_ a boundary,\n            // because we already accepted this update (accidental side effect).\n            var isNoLongerABoundary = prevExports !== null;\n            if (isNoLongerABoundary) {\n                module.hot.invalidate();\n            }\n        }\n    }\n\n/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../node_modules/next/dist/compiled/webpack/harmony-module.js */ \"./node_modules/next/dist/compiled/webpack/harmony-module.js\")(module)))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL2NvbXBvbmVudHMvRWRpdG9yL2luZGV4LmpzPzI0NDMiXSwibmFtZXMiOlsiRWRpdG9yIiwicHJvcHMiLCJ1c2VTdGF0ZSIsImRhdGEiLCJzZXREYXRhIiwidXNlRWZmZWN0Iiwid2luZG93IiwiYWRkRXZlbnRMaXN0ZW5lciIsImV2ZW50IiwibG9jYWxTdG9yYWdlIiwiZ2V0SXRlbSIsImVuYWJsZUJhc2ljQXV0b2NvbXBsZXRpb24iLCJlbmFibGVMaXZlQXV0b2NvbXBsZXRpb24iLCJlbmFibGVTbmlwcGV0cyIsInNob3dMaW5lTnVtYmVycyIsInRhYlNpemUiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBRUE7QUFDQTtBQUNBOztBQUVBLElBQU1BLE1BQU0sR0FBRyxTQUFUQSxNQUFTLENBQUFDLEtBQUssRUFBSTtBQUFBOztBQUFBLGtCQUNFQyxzREFBUSxDQUFDLEVBQUQsQ0FEVjtBQUFBLE1BQ2ZDLElBRGU7QUFBQSxNQUNUQyxPQURTOztBQUd0QkMseURBQVMsQ0FBQyxZQUFNO0FBQ2RDLFVBQU0sQ0FBQ0MsZ0JBQVAsQ0FDRSxTQURGLEVBRUUsVUFBQUMsS0FBSyxFQUFJO0FBQ1AsVUFBSUEsS0FBSixFQUFXO0FBQ1RKLGVBQU8sQ0FBQ0ssWUFBWSxDQUFDQyxPQUFiLENBQXFCLGNBQXJCLENBQUQsQ0FBUDtBQUNEO0FBQ0YsS0FOSCxFQU9FLEtBUEY7QUFTRCxHQVZRLEVBVU4sRUFWTSxDQUFUO0FBWUEsc0JBQ0UscUVBQUMsZ0RBQUQ7QUFDRSxlQUFXLEVBQUMsa0JBRGQ7QUFFRSxRQUFJLEVBQUMsT0FGUDtBQUdFLFNBQUssRUFBQyxTQUhSO0FBSUUsUUFBSSxFQUFDLE9BSlA7QUFLRSxTQUFLLEVBQUMsTUFMUjtBQU1FLFVBQU0sRUFBQyxNQU5ULENBT0U7QUFDQTtBQVJGO0FBU0UsWUFBUSxFQUFFLEVBVFo7QUFVRSxtQkFBZSxFQUFFLElBVm5CO0FBV0UsY0FBVSxFQUFFLElBWGQ7QUFZRSx1QkFBbUIsRUFBRSxJQVp2QjtBQWFFLFNBQUssRUFBRVAsSUFiVDtBQWNFLGNBQVUsRUFBRTtBQUNWUSwrQkFBeUIsRUFBRSxJQURqQjtBQUVWQyw4QkFBd0IsRUFBRSxJQUZoQjtBQUdWQyxvQkFBYyxFQUFFLElBSE47QUFJVkMscUJBQWUsRUFBRSxJQUpQO0FBS1ZDLGFBQU8sRUFBRTtBQUxDO0FBZGQ7QUFBQTtBQUFBO0FBQUE7QUFBQSxXQURGO0FBd0JELENBdkNEOztHQUFNZixNOztLQUFBQSxNO0FBd0NTQSxxRUFBZiIsImZpbGUiOiIuL3NyYy9jb21wb25lbnRzL0VkaXRvci9pbmRleC5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QsIHVzZVN0YXRlIH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IEFjZUVkaXRvciBmcm9tICdyZWFjdC1hY2UnO1xuXG5pbXBvcnQgJ2FjZS1idWlsZHMvc3JjLW5vY29uZmxpY3QvbW9kZS1teXNxbCc7XG5pbXBvcnQgJ2FjZS1idWlsZHMvc3JjLW5vY29uZmxpY3QvdGhlbWUtbW9ub2thaSc7XG5pbXBvcnQgJ2FjZS1idWlsZHMvc3JjLW5vY29uZmxpY3QvZXh0LWxhbmd1YWdlX3Rvb2xzJztcblxuY29uc3QgRWRpdG9yID0gcHJvcHMgPT4ge1xuICBjb25zdCBbZGF0YSwgc2V0RGF0YV0gPSB1c2VTdGF0ZSgnJyk7XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcbiAgICAgICdtZXNzYWdlJyxcbiAgICAgIGV2ZW50ID0+IHtcbiAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgc2V0RGF0YShsb2NhbFN0b3JhZ2UuZ2V0SXRlbSgnanNvbi1kaWFncmFtJykpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZmFsc2VcbiAgICApO1xuICB9LCBbXSk7XG5cbiAgcmV0dXJuIChcbiAgICA8QWNlRWRpdG9yXG4gICAgICBwbGFjZWhvbGRlcj1cIlBsYWNlaG9sZGVyIFRleHRcIlxuICAgICAgbW9kZT1cIm15c3FsXCJcbiAgICAgIHRoZW1lPVwibW9ub2thaVwiXG4gICAgICBuYW1lPVwiYmxhaDJcIlxuICAgICAgd2lkdGg9XCIxMDAlXCJcbiAgICAgIGhlaWdodD1cIjEwMCVcIlxuICAgICAgLy8gICBvbkxvYWQ9e3RoaXMub25Mb2FkfVxuICAgICAgLy8gICBvbkNoYW5nZT17dGhpcy5vbkNoYW5nZX1cbiAgICAgIGZvbnRTaXplPXsxNH1cbiAgICAgIHNob3dQcmludE1hcmdpbj17dHJ1ZX1cbiAgICAgIHNob3dHdXR0ZXI9e3RydWV9XG4gICAgICBoaWdobGlnaHRBY3RpdmVMaW5lPXt0cnVlfVxuICAgICAgdmFsdWU9e2RhdGF9XG4gICAgICBzZXRPcHRpb25zPXt7XG4gICAgICAgIGVuYWJsZUJhc2ljQXV0b2NvbXBsZXRpb246IHRydWUsXG4gICAgICAgIGVuYWJsZUxpdmVBdXRvY29tcGxldGlvbjogdHJ1ZSxcbiAgICAgICAgZW5hYmxlU25pcHBldHM6IHRydWUsXG4gICAgICAgIHNob3dMaW5lTnVtYmVyczogdHJ1ZSxcbiAgICAgICAgdGFiU2l6ZTogMixcbiAgICAgIH19XG4gICAgLz5cbiAgKTtcbn07XG5leHBvcnQgZGVmYXVsdCBFZGl0b3I7XG4iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./src/components/Editor/index.js\n");

/***/ })

})